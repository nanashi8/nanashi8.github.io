# 母国語コーディングと日本語の可能性について（構想）

**作成日**: 2026年1月14日  
**ステータス**: 構想（検証ロードマップ策定フェーズ）  
**主題**: 日本語を「意図記述言語」として用い、AI時代の開発を再設計する

関連（詳細版）:
- 構想（戦略統合・参照アーキテクチャ）: [JAPANESE_CENTRIC_DOMESTIC_AI_NATIVE_CODING_VISION.md](JAPANESE_CENTRIC_DOMESTIC_AI_NATIVE_CODING_VISION.md)
- 煮詰め手順（Gate運用）: [NATIVE_CODING_REFINEMENT_WORKFLOW.md](NATIVE_CODING_REFINEMENT_WORKFLOW.md)
- 評価ベンチ（指標・課題設計）: [NATIVE_CODING_EVALUATION_BENCHMARK.md](NATIVE_CODING_EVALUATION_BENCHMARK.md)
- 監査ログ・責任分界: [NATIVE_CODING_AUDIT_GOVERNANCE_SPEC.md](NATIVE_CODING_AUDIT_GOVERNANCE_SPEC.md)
- 課題集（このリポジトリ向け）: [NATIVE_CODING_BENCHMARK_TASKS_2026-01.md](NATIVE_CODING_BENCHMARK_TASKS_2026-01.md)

---

## 要約

AIの普及により、ソフトウェア開発の中心は「コードを書く」から **「意図を言語化し、検証可能な仕様へ落とす」** へ移る。
この局面で日本語は、高文脈性・粒度可変・専門語と日常語の混在・依頼表現（要求強度の階層）といった特性により、AIとの対話における **高解像度の意図記述言語** として強い可能性がある。

一方で日本語の曖昧さは、探索を加速するが、誤実装を「静かに」混入させやすい。
したがって母国語コーディングの本質は、自然言語→コード生成ではなく、

- 曖昧さの検出
- 確認質問による仕様確定
- 制約（型・契約・非目標）への変換
- テスト・監査ログによる検証

という **安全な変換器（pipeline）** を持つことである。
日本語の可能性は、言語特性そのものではなく、この変換器を日本語に最適化できる点にある。

---

## 1. 背景：開発は「言語化」の比重が増える

### 1-1. 変化の要点

- 旧：実装者が形式言語（コード）を直接書く
- 新：実装者は意図・制約・受け入れ条件を定め、AIが差分とテストを生成する

結果として、競争優位は「コードを書く速さ」より **仕様を確定させる速さ・正確さ** に寄る。

### 1-2. ここで問う「母国語コーディング」

母国語コーディングは「日本語で命令してコードを出す」ことではない。
**日本語で意図を記述し、それを検証可能な形に落とし込んで前進する** 開発様式である。

---

## 2. 日本語の可能性（AI時代の再解釈）

日本語の特性は、従来は“曖昧さ”として弱点扱いされがちだった。
しかしAIが文脈補完・要約・変換を得意とするなら、日本語は「探索言語」として価値が上がる。

### 2-1. 高文脈性：背景条件を自然に含められる

- 強み：暗黙の前提（背景・目的・ニュアンス）を短い指示に圧縮できる
- リスク：前提の取り違えが誤実装に直結する

結論：高文脈性を利得にするには「確認質問（Ask-to-commit）」が必須。

### 2-2. 粒度可変：抽象↔具体の切り替えが自然

日本語は、
- 「もう少し自然に」
- 「閾値0.3を超えたら警告」

のように、抽象的な方向付けから具体条件への移行が滑らか。
これは、探索→確定を反復する開発と相性が良い。

### 2-3. 専門語×日常語混在：現場の言葉がそのまま仕様になる

実務の要求は、技術語彙（CI、PR、型、SLO）と日常語（いい感じ、なるべく）が混ざる。
日本語は混在したまま意図を運べるため、専門家が“翻訳せず”に仕様を書ける。

### 2-4. 依頼表現：要求強度の階層（MUST/SHOULD/MAY）を運べる

「できれば」「なるべく」「必ず」は要求強度のシグナル。
これを仕様テンプレに落とすと、優先度衝突（速度 vs 品質等）の処理がやりやすくなる。

---

## 3. 母国語コーディングの中核：安全な変換器（pipeline）

### 3-1. 参照フロー

```
日本語（意図）
  ↓ 目的/制約/非目標/受け入れ条件
日本語（仕様ドラフト）
  ↓ 曖昧さlint → 確認質問
日本語（確定仕様）
  ↓ 制約化（型・契約・不変条件・エラー規約）
差分生成（小さく）
  ↓ テスト生成（受け入れ条件に対応）
実行・観測
  ↓ 監査ログ（意図→差分→テスト→結果）
次の反復
```

### 3-2. 成功条件（この構想の勝ち筋）

- 日本語の曖昧さを “事故” にせず “探索” に変える
- 生成物の正しさだけでなく、検証と追跡（監査）を標準化する
- 反復の単位を小さくし、誤りを早く発見して戻れるようにする

---

## 4. 日本語の可能性を最大化する設計原則

### 4-1. 曖昧さを検出する（Ambiguity lint）

危険語（少し/自然に/適切に/早めに）や主語省略、指示語、優先度衝突を機械的に検出し、必ず質問へ回す。

### 4-2. 受け入れ条件を必須にする（Evaluate-first）

「良い感じ」では実装が確定しない。
受け入れ条件は、テスト可能な形（例：ログ、閾値、画面の文言、回帰条件）へ落とす。

### 4-3. 差分最小（Diff-first）

自然言語が強いほど変更が大きくなりがち。
レビュー可能なサイズに落とし、失敗時の原因分解を容易にする。

### 4-4. 監査可能性（Traceability）

意図・仮定・差分・テスト・結果が追えないなら、母国語コーディングは運用に載らない。

---

## 5. 「これからの日本語」の論点

日本語の可能性は、“言語”ではなく“開発様式”として立ち上がる。

- **日本語が一次言語の仕様** になる（メモ→仕様→テストへ落ちる）
- **専門家が翻訳しない**（医療・行政・教育の文書がそのまま入力になる）
- **依頼表現がポリシー化**される（MUST/SHOULD/MAY）
- **監査・説明責任**が日本語のまま完結する（国内制度と相性が良い）

一方で、曖昧さが増えるほど「確認質問」「制約化」「検証」が重要になる。
つまり、日本語の優位性は **安全装置込み** で初めて成立する。

---

## 6. 次の一歩（構想を前に進める）

- 手順に従って煮詰める: [NATIVE_CODING_REFINEMENT_WORKFLOW.md](NATIVE_CODING_REFINEMENT_WORKFLOW.md)
- 評価で潰す: [NATIVE_CODING_EVALUATION_BENCHMARK.md](NATIVE_CODING_EVALUATION_BENCHMARK.md)
- まず10件回す（日本語/英語/確認質問なしで比較）: [NATIVE_CODING_BENCHMARK_TASKS_2026-01.md](NATIVE_CODING_BENCHMARK_TASKS_2026-01.md)

