# 大失敗分析レポート: 再出題メカニズムの重複実装

**日時**: 2025年12月21日
**重大度**: 🔴 Critical（大災害級）
**影響範囲**: 暗記タブの再出題システム全体

---

## 📊 失敗の概要

### 何が起きたか

ユーザーから「学習AIで再出題が行われない」という報告を受けた際、既存の再出題メカニズムを確認せずに、新しい再出題ロジックを実装してしまった。

### 実際の状況

**既存システム**:
1. ✅ `useQuestionRequeue` フック（src/hooks/useQuestionRequeue.ts）
   - `reAddQuestion()`: 不正解問題を次の1問後に再出題
   - `clearExpiredFlags()`: 5問経過後のフラグクリア
   - KPIトラッキング機能付き

2. ✅ `QuestionScheduler` クラス（src/ai/scheduler/QuestionScheduler.ts）
   - `incorrectSkipQueue`: incorrect待機キュー
   - ランダム飛ばし機能（3-5問後に再出題）
   - 振動防止機能

3. ✅ `MemoryAcquisitionAlgorithm`（src/strategies/memoryAcquisitionAlgorithm.ts）
   - 4段階復習システム（即時/早期/中期/終了時）
   - SuperMemo SM-2アルゴリズム
   - 動的閾値システム

**追加してしまったコード**:
❌ 重複した再出題ロジック（3-5問後にランダム挿入）
```typescript
// MemorizationView.tsx Line 750付近
if (!isCorrect) {
  const skipCount = Math.floor(Math.random() * 3) + 3;
  const reinsertIndex = Math.min(currentIndex + skipCount, questions.length);
  const updatedQuestions = [...questions];
  updatedQuestions.splice(reinsertIndex, 0, answeredQuestion);
  setQuestions(updatedQuestions);
}
```

---

## 🔍 根本原因分析（5 Whys）

### Why 1: なぜ重複実装したのか？
→ 既存の再出題メカニズムを確認しなかったから

### Why 2: なぜ確認しなかったのか？
→ 仕様書・既存コードの調査を省略したから

### Why 3: なぜ調査を省略したのか？
→ 「再出題が行われない」という報告から、「再出題機能が存在しない」と早合点したから

### Why 4: なぜ早合点したのか？
→ コード変更前の必須確認プロセスが存在しなかったから

### Why 5: なぜプロセスが存在しなかったのか？
→ **AI動作ガイドラインに「仕様確認の強制」が明記されていなかったから**

---

## 💥 影響と問題点

### 技術的影響

1. **機能の重複**
   - 既存: `useQuestionRequeue.reAddQuestion()`（次の1問後）
   - 追加: 独自実装（3-5問後）
   - → 2つの再出題ロジックが競合

2. **設計思想の無視**
   - `useQuestionRequeue`は科学的根拠に基づく即座再出題（スキップ連打対応）
   - 独自実装は根拠なしのランダム配置
   - → 学習効率が低下

3. **既存システムとの不整合**
   - `QuestionScheduler`の待機キューを無視
   - `MemoryAcquisitionAlgorithm`の4段階復習を無視
   - → AIシステム全体が機能不全

### プロセス上の問題

1. **調査不足**
   - `semantic_search` を実行せず
   - 既存ファイルの `read_file` を実行せず
   - 仕様書（docs/specifications/）を確認せず

2. **確認の欠如**
   - meta-ai-priority.instructions.md を読まず
   - QuestionScheduler.ts（752行）の仕様を理解せず
   - useQuestionRequeue.ts の存在を把握せず

3. **思い込みによる判断**
   - 「再出題されない」→「機能が存在しない」と即断
   - 実際は「既存機能が正しく呼ばれていない可能性」を調査すべきだった

---

## 🛡️ 再発防止策

### 即時対応（完了）

1. ✅ 追加したコードをロールバック
2. ✅ 既存の `useQuestionRequeue` を使用するように修正
3. ✅ デバッグログで動作確認できるよう改善

### 短期対策（完了）

1. ✅ **強制的な仕様確認プロセスの導入**
   - `.aitk/instructions/mandatory-spec-check.instructions.md` を作成
   - priority: 1（最優先）で適用
   - すべてのコード変更前に仕様確認を強制

2. ✅ **失敗パターンの文書化**
   - このレポート自体が今後の教訓
   - NG例・OK例を明記

### 中期対策（必要）

1. **既存システムの動作確認**
   - `useQuestionRequeue` が正しく動作しているか検証
   - `QuestionScheduler` の待機キューが機能しているか確認
   - ログ出力で再出題タイミングを可視化

2. **統合テストの追加**
   - 不正解時に再出題されることを確認するテスト
   - 再出題タイミングが適切かを検証するテスト

3. **ドキュメント整備**
   - 再出題メカニズムの全体像を1つの仕様書にまとめる
   - 各コンポーネントの役割を明確化

### 長期対策（提案）

1. **AI動作ガイドラインの強化**
   - コード変更前のチェックリスト
   - 既存機能の調査手順書
   - 失敗事例集の整備

2. **自動チェックの導入**
   - 重複コードの検出ツール
   - 未使用のユーティリティ警告

3. **定期的なレビュー**
   - 既存システムの理解度確認
   - 仕様書と実装の整合性チェック

---

## 📚 学んだ教訓

### Do（今後実践すること）

1. **常に既存実装を最優先で調査**
   - semantic_search → grep_search → read_file の順で徹底調査
   - 最低3つのファイルは読んでから判断

2. **仕様書を必ず確認**
   - docs/specifications/
   - docs/guidelines/
   - .aitk/instructions/

3. **既存のパターンに従う**
   - 独自実装よりも既存のユーティリティ・フックを優先
   - 設計思想を理解してから実装

4. **疑問があれば即座に確認**
   - 「多分こうだろう」は禁止
   - 不明点はユーザーに確認

### Don't（絶対にやってはいけないこと）

1. **調査なしでコードを書かない**
   - 「存在しないだろう」という思い込み禁止
   - 既存機能の重複実装は最悪のアンチパターン

2. **早合点しない**
   - 「動かない」→「機能がない」ではない
   - 「動かない」→「なぜ動かないのか」を調査

3. **仕様を無視しない**
   - 既存の設計思想を尊重
   - 科学的根拠のあるアルゴリズムを勝手に変更しない

---

## ✅ 今後のアクションプラン

### Phase 1: 既存システムの完全理解（優先度: 高）

- [ ] `useQuestionRequeue` の動作を実機で確認
- [ ] `QuestionScheduler` の待機キューの動作を検証
- [ ] `MemoryAcquisitionAlgorithm` の4段階復習を理解
- [ ] 再出題タイミングのログを確認

### Phase 2: 動作確認と調整（優先度: 高）

- [ ] 「まだまだ」「分からない」で再出題されることを確認
- [ ] 再出題タイミングが学習AIの推奨に沿っているか検証
- [ ] 学習効率の最適化（必要に応じて調整）

### Phase 3: ドキュメント整備（優先度: 中）

- [ ] 再出題メカニズムの全体仕様書を作成
- [ ] 各コンポーネントの役割分担図を作成
- [ ] 開発者向けガイドの更新

---

## 🎯 まとめ

今回の失敗は、**既存システムの調査を怠り、重複実装してしまった**という重大なミスでした。

根本原因は、**コード変更前の仕様確認プロセスが存在しなかった**ことです。

再発防止策として、**強制的な仕様確認プロセス**を導入しました。今後は必ず既存実装を調査してからコードを書きます。

**この失敗を教訓に、より慎重かつ正確な開発を行います。**

---

**作成者**: AI Assistant  
**承認**: 要ユーザー確認  
**更新日**: 2025-12-21
