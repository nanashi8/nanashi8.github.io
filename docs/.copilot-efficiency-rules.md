# Copilot作業効率化ルール

**作成日**: 2025年12月12日  
**目的**: 時間のかかる作業を避け、効率的なリファクタリングを実現

---

## ❌ 避けるべき作業パターン

### 1. 重いターミナルコマンド
```bash
# ❌ 避ける - 時間がかかりすぎる
npm run lint 2>&1 | grep "warning"
npm run lint 2>&1 | grep "@typescript-eslint/no-unused-vars"
npm run typecheck  # 全体チェックは最後だけ
```

**理由**: 
- プロジェクト全体のlint/typecheckは数十秒〜数分かかる
- リアルタイム応答が必要な作業には不向き
- ユーザー待機時間が長すぎる

**代替方法**:
- `grep_search`でコード内を直接検索
- `get_errors`で特定ファイルのエラーのみ取得
- 最終確認時のみ実行

---

### 2. パイプ処理の多段接続
```bash
# ❌ 避ける
command1 | command2 | command3 | head -50
```

**理由**: パイプが詰まると全体が停止

**代替方法**:
- 単純なコマンドに分割
- ファイル出力して確認

---

### 3. 大量出力の可能性があるコマンド
```bash
# ❌ 避ける
npm run lint  # 全出力
find . -name "*.ts"  # 数百ファイル出力
```

**代替方法**:
- `wc -l`で件数のみ確認
- `head -10`で最初の数件のみ
- `file_search`や`grep_search`ツール使用

---

## ✅ 推奨する効率的な作業パターン

### 1. ファイル検索優先
```
✅ grep_search - 高速で正確
✅ file_search - パターンマッチ
✅ semantic_search - 意味検索
```

### 2. 段階的確認
```
✅ 小範囲のテスト実行
✅ 特定ファイルの型チェック
✅ 変更箇所のみのlint
```

### 3. 直接編集優先
```
✅ read_file → 確認 → replace_string_in_file
✅ multi_replace_string_in_file で一括編集
✅ create_file で新規作成
```

---

## 📊 作業効率履歴

### 時間がかかった作業 (避けるべき)

| 日時 | コマンド | 問題 | 代替案 |
|------|---------|------|--------|
| 2025-12-12 | `npm run lint 2>&1 \| grep "warning"` | ユーザーキャンセル | grep_search使用 |
| 2025-12-12 | `npm run lint 2>&1 \| grep "@typescript..."` | 実行エラー | get_errors使用 |
| 2025-12-12 | `npm run test:unit -- --run --reporter=verbose` | ユーザーキャンセル | --reporter不要、--run のみ |

### 効率的だった作業

| 日時 | 方法 | 成果 |
|------|------|------|
| 2025-12-12 | grep_search + multi_replace | any型16箇所を数分で置換 |
| 2025-12-12 | create_file (テスト作成) | 2ファイル即座に作成 |
| 2025-12-12 | npm run test:unit (小規模) | 25テスト1秒で完了 |

---

## 🎯 効率化ワークフロー

### Phase開始時
1. `grep_search`で対象箇所を特定 (3-5秒)
2. `read_file`で詳細確認 (1-2秒)
3. `multi_replace_string_in_file`で一括修正 (2-3秒)

### Phase完了時
1. `npm run test:unit -- --run` (小規模テスト: 1秒)
2. `npm run build` (最終確認のみ)
3. ドキュメント更新

### 全体完了時のみ
- `npm run typecheck` (Phase完了後1回のみ)
- `npm run lint` (Phase完了後1回のみ)
- `npm run test:all` (リリース前のみ)

---

## 💡 ベストプラクティス

1. **並列処理を活用**
   - 複数ファイルの読み込みは並列実行
   - 独立した編集は`multi_replace_string_in_file`

2. **段階的確認**
   - 小さな変更 → テスト → 次の変更
   - 一気に大量変更しない

3. **ユーザー待機時間最小化**
   - 5秒以上かかる作業は避ける
   - 重い作業は事前に警告

4. **キャンセル可能性を考慮**
   - 長時間作業は分割
   - 中断されても復旧可能に

---

## 🔄 継続的改善

このドキュメントは作業中に更新:
- 新しい非効率パターンを発見したら追記
- より良い代替方法を見つけたら更新
- 成功パターンを記録して再利用

---

**最終更新**: 2025年12月12日
