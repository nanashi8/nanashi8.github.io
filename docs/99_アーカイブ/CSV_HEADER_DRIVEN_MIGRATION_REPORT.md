# CSVヘッダ駆動型パーサへの移行レポート

**作成日**: 2025-10-27  
**バージョン**: 2.2  
**対象プロジェクト**: SimpleWord

---

## 概要

CSVファイルのヘッダを最優先で扱うため、システム全体を**固定列順パーサ**から**ヘッダ駆動型パーサ**に移行しました。

これにより、CSVファイルのヘッダ行に記載された列名に基づいて、列の順序に関わらず正しくデータをパースできるようになりました。

---

## 変更の背景

### 問題点
- **固定列順への依存**: 従来のパーサは列の順序（インデックス）に依存しており、CSVファイルの列順が変更されると正しくパースできませんでした
- **ヘッダの軽視**: CSVファイルに記載されたヘッダ情報が活用されておらず、表示ラベルの取得にのみ使用されていました
- **柔軟性の欠如**: ユーザーがCSVファイルを手動編集した際、列順が異なると読み込みエラーになる可能性がありました

### 解決方針
- **ヘッダ駆動型パーサの導入**: CSVファイルのヘッダ行を読み取り、列名に基づいて動的に列マッピングを構築
- **列順の自由化**: 列の順序に関わらず、ヘッダに記載された列名で正しいフィールドを識別
- **後方互換性の維持**: 既存の固定列順モードも残し、段階的な移行を可能に

---

## 変更されたファイル

### 1. CSVDataSource.swift
**場所**: `Common/Data/DataSource/CSVDataSource.swift`

**変更内容**:
- ヘッダ駆動型モードを追加
- 新しいイニシャライザ `init(fileName:headerDrivenParser:)` を追加
- `fetchWithHeaderDriven()` メソッドを追加してヘッダ駆動型のパース処理を実装
- `buildColumnMapping()` メソッドを追加してヘッダから列マッピングを構築
- 固定列順モードも後方互換性のため維持

**主要な新機能**:
```swift
// ヘッダ駆動型イニシャライザ
public init(
    fileName: String,
    headerDrivenParser: @escaping (Int, [String], [String: Int]) throws -> T?
)

// ヘッダマッピング構築
private func buildColumnMapping(_ headers: [String]) -> [String: Int]
```

**列名の識別ロジック**:
- **語句**: "語句", "term", "単語", "フレーズ", "年号"
- **読み/発音**: "読み", "発音", "reading", "登場人物", "人物"
- **意味/和訳**: "意味", "和訳", "meaning", "translation", "史実"
- **語源/解説**: "語源", "解説", "etymology", "経緯"
- **関連語**: "関連語", "relatedword"
- **関連分野**: "関連分野", "分野", "relatedfield", "カテゴリ", "シチュエーション"
- **難易度**: "難易度", "difficulty", "level", "レベル"

### 2. QuestionItemParser.swift
**場所**: `Common/Data/Parcer/QuestionItemParser.swift`

**変更内容**:
- ヘッダ駆動型パーサメソッド `makeHeaderDrivenParser()` を追加
- 既存の `makeParser()` は後方互換性のため維持

**新しいメソッド**:
```swift
public static func makeHeaderDrivenParser() -> (Int, [String], [String: Int]) throws -> QuestionItem
```

**動作**:
- ヘッダマッピング `[String: Int]` を受け取る
- 各フィールドをマッピングから取得（存在しない場合は空文字列）
- 列順に依存せずにQuestionItemを構築

### 3. QuestionItemRepository.swift
**場所**: `Common/Data/Repository/QuestionItemRepository.swift`

**変更内容**:
- イニシャライザを刷新し、デフォルトでヘッダ駆動型を使用
- `useHeaderDriven` パラメータを追加（デフォルト: true）
- 旧イニシャライザは非推奨としてマーク

**新しいイニシャライザ**:
```swift
public init(fileName: String, useHeaderDriven: Bool = true)
```

**動作**:
- `useHeaderDriven = true`（デフォルト）: ヘッダ駆動型モードで動作
- `useHeaderDriven = false`: 固定列順モードで動作（後方互換性）

### 4. CSVLoader.swift
**場所**: `SimpleWord/Utils/CSVLoader.swift`

**変更内容**:
- `parseContent()` メソッドを完全にヘッダ駆動型に変更
- ヘッダ行の検証を必須化
- 列マッピング構築ロジックを追加
- 安全な配列アクセスのための拡張メソッドを追加

**主要な新機能**:
```swift
private func buildColumnMapping(_ headers: [String]) -> [String: Int]
private func parseItemFromColumns(_ columns: [String], mapping: [String: Int], lineNumber: Int) throws -> QuestionItem
```

---

## ヘッダ駆動型パーサの動作フロー

### 1. CSVファイル読み込み
```
中学英会話.csv:
語句,発音（カタカナ）,和訳,語源等解説（日本語）,関連語（英語）と意味（日本語）,関連分野（日本語）,難易度
Hello!,ハロー,こんにちは,英語の挨拶の定番,Hi:やあ,感情,1
```

### 2. ヘッダ行の解析
```swift
headers = ["語句", "発音（カタカナ）", "和訳", "語源等解説（日本語）", "関連語（英語）と意味（日本語）", "関連分野（日本語）", "難易度"]
```

### 3. 列マッピングの構築
```swift
mapping = [
    "term": 0,           // "語句"
    "reading": 1,        // "発音（カタカナ）"
    "meaning": 2,        // "和訳"
    "etymology": 3,      // "語源等解説（日本語）"
    "relatedWords": 4,   // "関連語（英語）と意味（日本語）"
    "relatedFields": 5,  // "関連分野（日本語）"
    "difficulty": 6      // "難易度"
]
```

### 4. データ行のパース
```swift
columns = ["Hello!", "ハロー", "こんにちは", "英語の挨拶の定番", "Hi:やあ", "感情", "1"]

item = QuestionItem(
    term: columns[mapping["term"]!],           // "Hello!"
    reading: columns[mapping["reading"]!],     // "ハロー"
    meaning: columns[mapping["meaning"]!],     // "こんにちは"
    etymology: columns[mapping["etymology"]!], // "英語の挨拶の定番"
    ...
)
```

---

## メリット

### 1. 柔軟性の向上
- **列順の自由化**: 列の順序を変更してもヘッダさえ正しければ正常に動作
- **列の追加/削除**: 将来的に列を追加する場合も、既存のコードへの影響を最小化

### 2. 可読性の向上
- **CSVファイルの自己記述性**: ヘッダを見れば各列の意味が明確
- **ユーザーフレンドリー**: ユーザーがCSVファイルを手動編集しやすくなる

### 3. 保守性の向上
- **変更の局所化**: 列定義の変更がパーサのマッピングロジックに集約
- **エラーメッセージの改善**: "ヘッダがありません" など、より具体的なエラー

### 4. 多様なCSVフォーマットへの対応
- **中学古典単語**: 語句, 読み（ひらがな）, 意味, ...
- **中学英会話**: 語句, 発音（カタカナ）, 和訳, ...
- **中学歴史**: 年号, 登場人物, 史実名, ...

すべて同じパーサで対応可能！

---

## 後方互換性

### 固定列順モードの維持
既存のコードやテストが固定列順モードに依存している場合、以下の方法で使用できます：

```swift
// ヘッダ駆動型（デフォルト）
let repository1 = QuestionItemRepository(fileName: "中学英会話")

// 固定列順モード（後方互換性）
let repository2 = QuestionItemRepository(fileName: "中学英会話", useHeaderDriven: false)
```

### 移行パス
1. **現在**: デフォルトでヘッダ駆動型を使用
2. **将来**: すべてのCSVファイルがヘッダ駆動型に移行したら、固定列順モードを削除可能

---

## テスト推奨事項

### 1. ヘッダ駆動型の動作確認
- [ ] 各CSVファイル（中学英会話、中学古典単語、中学歴史など）が正しく読み込まれること
- [ ] QuizViewで問題が正しく出題されること
- [ ] 回答後の詳細情報が正しく表示されること（発音表示含む）

### 2. エラーハンドリング
- [ ] ヘッダ行がない場合のエラーメッセージ
- [ ] 列数が不一致の場合のエラーメッセージ
- [ ] 不正なCSVフォーマットの場合のエラーメッセージ

### 3. エッジケース
- [ ] 列順が変更されたCSVファイル
- [ ] 一部の列が欠けているCSVファイル（空文字列として扱われるか）
- [ ] 列名のバリエーション（全角/半角、スペース有無など）

---

## 今後の拡張可能性

### 1. 列の動的追加
ヘッダ駆動型により、将来的に以下のような列を追加しても既存コードへの影響が最小限：
- 例文列
- 音声ファイルパス列
- 画像URL列
- タグ列

### 2. 多言語対応
ヘッダ名の識別ロジックを拡張すれば、英語ヘッダのCSVにも対応可能：
- "term" / "語句"
- "reading" / "読み"
- "meaning" / "意味"

### 3. カスタム列マッピング
ユーザーが独自の列名を定義できる機能の追加も可能：
```swift
let customMapping = [
    "question": "term",
    "answer": "meaning",
    ...
]
```

---

## 注意事項

### 1. ヘッダは必須
ヘッダ駆動型モードでは、CSVファイルの1行目が必ずヘッダである必要があります。ヘッダがない場合はエラーになります。

### 2. 列名の正確性
ヘッダの列名が認識可能な形式である必要があります。認識されない列名の場合、そのフィールドは空文字列として扱われます。

### 3. 既存CSVファイルの互換性
すべての既存CSVファイル（Resources配下）は、既にヘッダ行を持っているため、問題なく動作します。

---

## まとめ

### 達成したこと
1. ✅ CSVファイルのヘッダを最優先で扱うヘッダ駆動型パーサの実装
2. ✅ 列順に依存しない柔軟なパース処理
3. ✅ 後方互換性の維持（固定列順モードも利用可能）
4. ✅ 多様なCSVフォーマットへの対応（古典単語、英会話、歴史など）
5. ✅ エラーハンドリングの改善

### 利点
- **ユーザーフレンドリー**: CSVファイルを手動編集しやすい
- **保守性**: 列定義の変更が局所化される
- **拡張性**: 将来的な機能追加が容易

### 次のステップ
1. アプリを起動してQuizViewで各CSVファイルの出題を確認
2. 回答後の詳細表示が正しく動作することを確認
3. 発音表示が適切に表示されることを確認

**最終更新**: 2025-10-27  
**ステータス**: ✅ 実装完了
