# 02. 技術的課題と解決策

**作成日**: 2025年11月5日  
**最終更新**: 2025年11月5日

---

## 📋 概要

SimpleWordアプリの開発過程で発生した技術的課題と、それらの解決策を記録します。

---

## 🔥 主要な技術的課題

### 1. 画面遷移の無限ループ問題

#### 発生した問題
**症状**:
- ContentViewからQuizViewへの画面遷移が動作しない
- CPU使用率が100%に達する
- シミュレータが応答不能になる

**根本原因**:
1. **環境オブジェクトの注入漏れ**
   ```swift
   // ❌ 間違い
   NavigationLink(destination: QuizView())
   
   // ✅ 正しい
   NavigationLink(destination: QuizView()
       .environmentObject(wordScoreStore)
       .environmentObject(currentCSV)
       .environmentObject(quizSettings)
       .environmentObject(scoreStore))
   ```

2. **`.onReceive`による無限ループ**
   ```swift
   // ❌ 間違い: Published変数を変更すると再度onReceiveが発火
   .onReceive(currentCSV.$currentFile) { _ in
       currentCSV.loadCSV()  // Published変数を変更
   }
   
   // ✅ 正しい: 条件分岐で無限ループを防止
   .onReceive(currentCSV.$currentFile) { newFile in
       if needsReload {
           currentCSV.loadCSV()
       }
   }
   ```

#### 解決策

**1. 環境オブジェクトの一元管理**
```swift
// SimpleWordApp.swift
@main
struct SimpleWordApp: App {
    @StateObject private var wordScoreStore = WordScoreStore()
    @StateObject private var currentCSV = CurrentCSV()
    @StateObject private var quizSettings = QuizSettings()
    @StateObject private var scoreStore = ScoreStore()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(wordScoreStore)
                .environmentObject(currentCSV)
                .environmentObject(quizSettings)
                .environmentObject(scoreStore)
        }
    }
}
```

**2. エラー解決プロトコルの確立**
- ビルド成功 ≠ 正常動作の原則
- 実機/シミュレータでの動作確認を必須化
- CPU/メモリ監視による無限ループの早期発見
- 3回で解決しない場合は立ち止まるルール

**ドキュメント**: `docs/03_開発ガイド/03_エラー解決プロトコル.md`

---

### 2. ファイル混入問題

#### 発生した問題
**症状**:
- QuizView.swiftにREADME.mdの内容が混入（2回）
- README.mdにPythonスクリプトが混入
- コードファイルが正常に動作しなくなる

**原因**:
- AIによるファイル編集時の誤操作
- ファイル内容の誤認識

#### 解決策

**1. gitコマンドを使わない復元手法**
```
理由: run_in_terminal でgitコマンドが停止する問題を回避

方法:
1. 仕様書を参照（docs/01_仕様書/）
2. コンポーネントファイルを分析
3. 完全なコードを再構築
4. replace_string_in_file で置換
```

**2. 混入内容の適切な保存**
- Pythonスクリプト → `Tools/translate_relatedfields_categories.py`
- 正しいREADME → `README_RECOVERED.md`

**3. 再発防止策**
- 仕様書の整備と最新化
- コンポーネント単位での管理
- ファイル編集前の内容確認の徹底

---

### 3. CSV固定列インデックス依存の問題

#### 発生した問題
**症状**:
- CSV種類（中学歴史、古典単語、英単語など）ごとに列構成が異なる
- 固定インデックス（0, 1, 2, ...）では対応できない
- 新しいCSV形式を追加するたびにコード修正が必要

**従来の実装**:
```swift
// ❌ 問題のある実装
let term = columns[0]      // 常に0列目が語句とは限らない
let reading = columns[1]   // 常に1列目が読みとは限らない
let meaning = columns[2]   // 常に2列目が意味とは限らない
```

#### 解決策: ヘッダ駆動型パーサの実装

**1. HeaderLabels構造体**
```swift
struct HeaderLabels: Codable, Equatable {
    // 各列の役割を保持
    var term: String = ""          // 語句の列名
    var reading: String = ""       // 読みの列名
    var meaning: String = ""       // 意味の列名
    var etymology: String = ""     // 語源の列名
    var relatedWords: String = ""  // 関連語の列名
    var relatedField: String = ""  // 関連分野の列名
    var difficulty: String = ""    // 難易度の列名
    
    // ヘッダから自動生成
    init(from header: [String]) {
        // ヘッダ内容を解析してマッピング
    }
}
```

**2. QuestionItem構造体の拡張**
```swift
struct QuestionItem: Identifiable, Codable {
    // 標準フィールド
    var term: String
    var reading: String
    var meaning: String
    var etymology: String
    var relatedWords: String
    var relatedField: String
    var difficulty: Int
    
    // メタデータ
    var headerLabels: HeaderLabels  // ヘッダ情報を保持
    var rawColumns: [String]        // 元データを保持（選択肢生成用）
}
```

**3. CSVParserの改良**
```swift
class CSVParser {
    func parse(fileURL: URL) -> ([QuestionItem], HeaderLabels) {
        // 1. ヘッダ行を解析
        let headerLabels = HeaderLabels(from: headerRow)
        
        // 2. 各データ行をHeaderLabelsに基づいて解析
        let items = dataRows.map { row in
            QuestionItem(from: row, headerLabels: headerLabels)
        }
        
        return (items, headerLabels)
    }
}
```

**メリット**:
- CSV種類を問わず統一的にデータアクセス
- 新しいCSV形式への対応が容易
- コードの可読性と保守性が向上
- 動的なラベル表示が可能

**ドキュメント**: `docs/01_仕様書/03_CSV仕様書.md`

---

### 4. 選択肢生成の不整合問題

#### 発生した問題
**症状**:
- ヘッダ駆動型パーサ導入後、選択肢の内容が不正確になる
- CSV種類によって選択肢が正しく表示されない

**原因**:
- ヘッダマッピングの影響で`meaning`フィールドが期待した列を指さない
- CSV種類ごとに「正解」となる列が異なる（和訳、史実名、意味など）

#### 解決策: 固定列選択肢生成

**重要な決定**:
```swift
// ✅ 選択肢は常にCSV固定列3（rawColumns[2]）から生成
let choiceText = questionItem.rawColumns[2]

// rawColumns[2] の内容:
// - 中学英単語: 和訳
// - 中学歴史: 史実名
// - 中学古典単語: 意味
```

**実装**:
```swift
// ChoiceCardView.swift
struct ChoiceCardView: View {
    let questionItem: QuestionItem
    
    var body: some View {
        VStack {
            // メインテキスト: 常にrawColumns[2]を使用
            Text(questionItem.rawColumns[2])
            
            // 詳細情報: headerLabelsに基づいて動的に表示
            displayDetails(questionItem)
        }
    }
}
```

**メリット**:
- すべてのCSV種類で一貫した選択肢表示
- ヘッダ駆動型パーサの影響を受けない
- 正確な選択肢生成を保証

**ドキュメント**: `.github/copilot-instructions.md`

---

### 5. CSV種類別の表示順序問題

#### 発生した問題
**症状**:
- すべてのCSV種類で同じ順序で詳細情報を表示
- 学習内容に適さない情報提示順序
- ユーザビリティの低下

**例**:
```
中学英単語で「年号」を最初に表示 ❌
中学歴史で「発音」を表示 ❌
```

#### 解決策: CSV種類別の最適化

**1. CSV種類の自動判定**
```swift
private enum CSVType {
    case history    // 中学歴史
    case classical  // 中学古典単語
    case english    // 中学英単語・英熟語・英会話
}

private func detectCSVType(from headerLabels: HeaderLabels) -> CSVType {
    // ヘッダラベルの内容から自動判定
    if headerLabels.term.contains("年号") &&
       headerLabels.reading.contains("登場人物") &&
       headerLabels.meaning.contains("史実") {
        return .history
    }
    // ...
}
```

**2. 各CSV種類別の表示関数**
```swift
// 中学歴史: 年号 → 解説 → 登場人物 → ...
@ViewBuilder
private func displayHistoryDetails(_ item: QuestionItem, _ color: Color) -> some View {
    if !item.term.isEmpty {
        DetailRow(label: labelFor("term", fallback: "年号:"), 
                  value: item.term, color: color)
    }
    if !item.etymology.isEmpty {
        DetailRow(label: labelFor("etymology", fallback: "解説:"), 
                  value: item.etymology, color: color)
    }
    // ...
}

// 中学英単語: 語句(発音) → 語源等解説 → ...
@ViewBuilder
private func displayEnglishDetails(_ item: QuestionItem, _ color: Color) -> some View {
    let termWithReading = item.term + 
        (item.reading.isEmpty ? "" : " (\(item.reading))")
    DetailRow(label: labelFor("term", fallback: "語句:"), 
              value: termWithReading, color: color)
    // ...
}
```

**メリット**:
- 各科目の学習に最適な情報順序
- ユーザーが必要な情報を見つけやすい
- 学習効率の向上

**ドキュメント**: `.github/copilot-instructions.md`

---

## 🎯 学んだ教訓

### 1. SwiftUI開発
- **ビルド成功 ≠ 正常動作**: 必ず実機/シミュレータで確認
- **環境オブジェクトは慎重に**: 注入漏れが無限ループを引き起こす
- **`.onReceive`は要注意**: Published変数の変更で無限ループ

### 2. アーキテクチャ設計
- **柔軟性を重視**: 固定インデックスではなくヘッダ駆動
- **単一責任の原則**: コンポーネント単位での管理
- **メタデータの保持**: `rawColumns`で元データを保持

### 3. 開発プロセス
- **仕様書の重要性**: ファイル混入時の復元に不可欠
- **段階的な実装**: 大規模変更は小さなステップで
- **事前確認の徹底**: シミュレーション実行前に確認

### 4. AI支援開発
- **プロンプトの明確化**: 具体的な指示で誤操作を防ぐ
- **ファイル編集の慎重さ**: 内容確認を徹底
- **エラー発生時の対処**: 3回で解決しない場合は方針転換

---

## 📚 関連ドキュメント

- **エラー解決プロトコル**: `docs/03_開発ガイド/03_エラー解決プロトコル.md`
- **CSV仕様書**: `docs/01_仕様書/03_CSV仕様書.md`
- **アーキテクチャ仕様書**: `docs/01_仕様書/02_アーキテクチャ仕様書.md`
- **AI活用ガイド**: `docs/03_開発ガイド/02_AI活用ガイド.md`

---

**以上、技術的課題と解決策をまとめました。** 🔧
