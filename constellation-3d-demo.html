<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Constellation 3D - å›è»¢å¯èƒ½ãƒ‡ãƒ¢</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #e0e0e0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      width: 100%;
      height: 100vh;
    }

    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 13px;
      max-width: 300px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #info h1 {
      font-size: 16px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #info h1::before {
      content: "â­";
      font-size: 20px;
    }

    .section {
      margin: 8px 0;
      padding: 6px 0;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .label-text {
      color: #999;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .current-file {
      color: #ff4444;
      font-weight: 600;
    }

    .related-files {
      color: #44ff88;
      font-size: 11px;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #controls div {
      margin: 4px 0;
      color: #aaa;
    }

    #controls kbd {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      color: #fff;
    }

    #axis-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #axis-controls h2 {
      font-size: 14px;
      margin-bottom: 12px;
      color: #ffd700;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #axis-controls h2::before {
      content: "ğŸ¯";
    }

    .axis-toggle {
      display: flex;
      align-items: center;
      margin: 8px 0;
      gap: 8px;
    }

    .axis-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .axis-toggle label {
      cursor: pointer;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .axis-x { color: #ff4444; }
    .axis-y { color: #44ff44; }
    .axis-z { color: #4444ff; }

    .vr-note {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: #888;
      font-size: 10px;
      font-style: italic;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #ffd700;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="loading">ğŸŒŸ å¤©ä½“å„€ã‚’åˆæœŸåŒ–ä¸­...</div>

  <div id="info">
    <h1>Neural Constellation 3D</h1>
    <div class="section">
      <div class="label-text">ç·¨é›†ä¸­</div>
      <div class="current-file" id="current">ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„</div>
    </div>
    <div class="section">
      <div class="label-text">é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«</div>
      <div class="related-files" id="related">-</div>
    </div>
  </div>

  <div id="controls">
    <div><kbd>å·¦ãƒ‰ãƒ©ãƒƒã‚°</kbd> å›è»¢</div>
    <div><kbd>ãƒ›ã‚¤ãƒ¼ãƒ«</kbd> ã‚ºãƒ¼ãƒ </div>
    <div><kbd>å³ãƒ‰ãƒ©ãƒƒã‚°</kbd> ãƒ‘ãƒ³ï¼ˆç§»å‹•ï¼‰</div>
    <div><kbd>ã‚¯ãƒªãƒƒã‚¯</kbd> ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ</div>
  </div>

  <div id="axis-controls">
    <h2>3è»¸è¡¨ç¤º</h2>
    <div class="axis-toggle">
      <input type="checkbox" id="toggle-x" checked>
      <label for="toggle-x"><span class="axis-x">â”</span> Xè»¸ï¼ˆæ§‹é€ ï¼‰</label>
    </div>
    <div class="axis-toggle">
      <input type="checkbox" id="toggle-y" checked>
      <label for="toggle-y"><span class="axis-y">â”</span> Yè»¸ï¼ˆéšå±¤ï¼‰</label>
    </div>
    <div class="axis-toggle">
      <input type="checkbox" id="toggle-z" checked>
      <label for="toggle-z"><span class="axis-z">â”</span> Zè»¸ï¼ˆæ™‚ç³»åˆ—ï¼‰</label>
    </div>
    <div class="axis-toggle">
      <input type="checkbox" id="toggle-grid" checked>
      <label for="toggle-grid">ğŸ“ ã‚°ãƒªãƒƒãƒ‰</label>
    </div>
    <div class="axis-toggle">
      <input type="checkbox" id="toggle-orbits" checked>
      <label for="toggle-orbits">ğŸ”„ è»Œé“ç·š</label>
    </div>
    <div class="vr-note">
      ğŸ¥½ å°†æ¥çš„ã«VRå¯¾å¿œäºˆå®š<br>
      ï¼ˆWebXR Device APIï¼‰
    </div>
  </div>

  <script defer src="./vendor/es-module-shims/es-module-shims.js"></script>
  <script type="importmap-shim">
    {
      "imports": {
        "three": "./vendor/three/three.module.js",
        "three/addons/": "./vendor/three/addons/"
      }
    }
  </script>

  <script type="module-shim">
    const loadingEl = document.getElementById('loading');
    const showInitError = (error) => {
      const message = error instanceof Error ? error.message : String(error);
      console.error('[Constellation3D] init failed:', error);
      if (loadingEl) {
        loadingEl.textContent = `âŒ å¤©ä½“å„€ã®åˆæœŸåŒ–ã«å¤±æ•—: ${message}`;
        loadingEl.style.display = 'block';
      }
    };

    (async () => {
      try {
        const THREE = await import('three');
        const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');

    // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
    const sampleNodes = [
      { id: 'QuestionScheduler.ts', label: 'QuestionScheduler', priority: 1.0, category: 'AI', connections: 8 },
      { id: 'MemoryAI.ts', label: 'MemoryAI', priority: 0.9, category: 'AI', connections: 6 },
      { id: 'GamificationAI.ts', label: 'GamificationAI', priority: 0.85, category: 'AI', connections: 5 },
      { id: 'AICoordinator.ts', label: 'AICoordinator', priority: 0.8, category: 'AI', connections: 7 },
      { id: 'Button.tsx', label: 'Button', priority: 0.6, category: 'UI', connections: 3 },
      { id: 'QuestionCard.tsx', label: 'QuestionCard', priority: 0.7, category: 'UI', connections: 4 },
      { id: 'progressStorage.ts', label: 'progressStorage', priority: 0.75, category: 'Data', connections: 5 },
      { id: 'memoryAlgorithm.ts', label: 'memoryAlgorithm', priority: 0.65, category: 'Data', connections: 4 },
      { id: 'scheduler.test.ts', label: 'scheduler.test', priority: 0.5, category: 'Test', connections: 2 },
      { id: 'utils.ts', label: 'utils', priority: 0.4, category: 'Util', connections: 8 }
    ];

      // ã‚·ãƒ¼ãƒ³åˆæœŸåŒ–
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0f);

      // ã‚«ãƒ¡ãƒ©
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 50, 150);

      // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
      const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    // OrbitControlsï¼ˆå›è»¢ãƒ»ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ï¼‰
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // æ…£æ€§
    controls.dampingFactor = 0.05;
    controls.minDistance = 50;
    controls.maxDistance = 300;

    // ç…§æ˜
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffd700, 1.5, 200);
    pointLight.position.set(0, 0, 0);
    scene.add(pointLight);

    // 3è»¸ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆX=èµ¤ã€Y=ç·‘ã€Z=é’ï¼‰
    const axisHelper = new THREE.AxesHelper(80);
    axisHelper.material.linewidth = 2;
    scene.add(axisHelper);

    // ã‚°ãƒªãƒƒãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆXZå¹³é¢ï¼‰
    const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
    scene.add(gridHelper);

    // è»Œé“ç·šï¼ˆå„ªå…ˆåº¦ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
    const orbitGroup = new THREE.Group();
    [40, 70, 100].forEach((radius, i) => {
      const orbitGeometry = new THREE.RingGeometry(radius - 0.5, radius + 0.5, 64);
      const orbitMaterial = new THREE.MeshBasicMaterial({
        color: 0x333333,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide
      });
      const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      orbitGroup.add(orbit);
    });
    scene.add(orbitGroup);

    // èƒŒæ™¯ã®æ˜Ÿï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.7,
      transparent: true,
      opacity: 0.8
    });

    const starsVertices = [];
    for (let i = 0; i < 1000; i++) {
      const x = (Math.random() - 0.5) * 500;
      const y = (Math.random() - 0.5) * 500;
      const z = (Math.random() - 0.5) * 500;
      starsVertices.push(x, y, z);
    }

    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // ä¸­å¿ƒã‚´ãƒ¼ãƒ«ï¼ˆå¤ªé™½ï¼‰
    const goalGeometry = new THREE.SphereGeometry(4, 32, 32);
    const goalMaterial = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      emissive: 0xff8c00,
      emissiveIntensity: 2,
      metalness: 0.5,
      roughness: 0.3
    });
    const goal = new THREE.Mesh(goalGeometry, goalMaterial);
    scene.add(goal);

    // ã‚´ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼åŠ¹æœ
    const goalGlowGeometry = new THREE.SphereGeometry(5, 32, 32);
    const goalGlowMaterial = new THREE.MeshBasicMaterial({
      color: 0xff8c00,
      transparent: true,
      opacity: 0.3
    });
    const goalGlow = new THREE.Mesh(goalGlowGeometry, goalGlowMaterial);
    scene.add(goalGlow);

    // ãƒãƒ¼ãƒ‰é…ç½®ï¼ˆçƒé¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰
    const nodeObjects = [];
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    sampleNodes.forEach((node, i) => {
      // çƒé¢åº§æ¨™ï¼ˆå„ªå…ˆåº¦ãŒé«˜ã„ã»ã©ä¸­å¿ƒã«è¿‘ã„ï¼‰
      const phi = Math.acos(-1 + (2 * i) / sampleNodes.length);
      const theta = Math.sqrt(sampleNodes.length * Math.PI) * phi;
      const radius = 40 + (1 - node.priority) * 60;

      const x = radius * Math.cos(theta) * Math.sin(phi);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(theta) * Math.sin(phi);

      // ãƒãƒ¼ãƒ‰ï¼ˆçƒä½“ï¼‰
      const size = 1.5 + node.priority * 2;
      const geometry = new THREE.SphereGeometry(size, 16, 16);

      let color;
      if (node.priority >= 0.8) color = 0x4a9eff; // é’ï¼ˆé‡è¦ï¼‰
      else if (node.priority >= 0.6) color = 0x8b9eff; // è–„é’
      else color = 0x888888; // ç°è‰²

      const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.5,
        metalness: 0.7,
        roughness: 0.2
      });

      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, y, z);
      sphere.userData = node;
      scene.add(sphere);
      nodeObjects.push(sphere);

      // ãƒ©ãƒ™ãƒ«ï¼ˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼‰
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, 256, 64);
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(node.label, 128, 40);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.set(x, y + size + 3, z);
      sprite.scale.set(15, 4, 1);
      scene.add(sprite);

      // ä¸­å¿ƒã¸ã®ç·šï¼ˆå„ªå…ˆåº¦é«˜ã„ã‚‚ã®ã®ã¿ï¼‰
      if (node.priority > 0.65) {
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(x, y, z)
        ]);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: node.priority > 0.8 ? 0x4a9eff : 0x666666,
          transparent: true,
          opacity: node.priority > 0.8 ? 0.6 : 0.3
        });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
      }
    });

    // ã‚¨ãƒƒã‚¸ï¼ˆæ¥ç¶šç·šï¼‰ã®è¿½åŠ  - çµåˆåº¦ã«ã‚ˆã‚‹å¤ªã•ã‚’åæ˜ 
    const edgeObjects = [];
    const sampleEdges = [
      { from: 'QuestionScheduler', to: 'MemoryAI', strength: 0.9 },
      { from: 'QuestionScheduler', to: 'ConfigLoader', strength: 0.7 },
      { from: 'MemoryAI', to: 'StrategyFinder', strength: 0.8 },
      { from: 'ConfigLoader', to: 'StrategyFinder', strength: 0.6 },
      { from: 'StrategyFinder', to: 'RandomGenerator', strength: 0.5 },
      { from: 'DataPersistence', to: 'MemoryAI', strength: 0.85 },
      { from: 'ConfigLoader', to: 'DataPersistence', strength: 0.75 },
      { from: 'LearningSolver', to: 'StrategyFinder', strength: 0.65 },
      { from: 'UIDisplay', to: 'QuestionScheduler', strength: 0.7 },
      { from: 'TimeHandler', to: 'LearningSolver', strength: 0.55 }
    ];

    sampleEdges.forEach(edge => {
      const fromNode = sampleNodes.find(n => n.id === edge.from);
      const toNode = sampleNodes.find(n => n.id === edge.to);
      if (!fromNode || !toNode) return;

      const fromObj = nodeObjects.find(obj => obj.userData.id === edge.from);
      const toObj = nodeObjects.find(obj => obj.userData.id === edge.to);
      if (!fromObj || !toObj) return;

      // å¼·åº¦ã«å¿œã˜ãŸå¤ªã•ï¼ˆ1-5ãƒ”ã‚¯ã‚»ãƒ«ç›¸å½“ï¼‰
      const thickness = Math.max(1, Math.min(5, edge.strength * 5));
      // å¼·åº¦ã«å¿œã˜ãŸä¸é€æ˜åº¦ï¼ˆ0.3-0.9ï¼‰
      const opacity = 0.3 + edge.strength * 0.6;

      // è‰²ã¯å¼·åº¦ã«ã‚ˆã‚‹
      let color = 0x4444ff; // é’
      if (edge.strength >= 0.8) color = 0xff4444; // èµ¤
      else if (edge.strength >= 0.6) color = 0xffaa44; // ã‚ªãƒ¬ãƒ³ã‚¸
      else if (edge.strength >= 0.4) color = 0xffff44; // é»„è‰²

      const points = [fromObj.position, toObj.position];
      const curve = new THREE.LineCurve3(points[0], points[1]);
      const tubeGeometry = new THREE.TubeGeometry(curve, 1, thickness * 0.15, 8, false);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: opacity
      });

      const tube = new THREE.Mesh(tubeGeometry, material);
      tube.userData = {
        edge: edge,
        originalOpacity: opacity,
        originalThickness: thickness
      };
      scene.add(tube);
      edgeObjects.push(tube);
    });

    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    let selectedNode = null;

    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodeObjects);

      if (intersects.length > 0) {
        const clicked = intersects[0].object;
        const node = clicked.userData;

        // æ·±åº¦è¨ˆç®—ç”¨ã®é–¢æ•°
        function calculateDepths(startId, maxDepth) {
          const depths = new Map();
          depths.set(startId, 0);
          let currentLayer = [startId];

          for (let depth = 1; depth <= maxDepth; depth++) {
            const nextLayer = [];
            currentLayer.forEach(nodeId => {
              sampleEdges.forEach(edge => {
                if (edge.from === nodeId && !depths.has(edge.to)) {
                  depths.set(edge.to, depth);
                  nextLayer.push(edge.to);
                }
                if (edge.to === nodeId && !depths.has(edge.from)) {
                  depths.set(edge.from, depth);
                  nextLayer.push(edge.from);
                }
              });
            });
            currentLayer = nextLayer;
          }
          return depths;
        }

        // æ—¢å­˜ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
        nodeObjects.forEach(obj => {
          obj.material.emissiveIntensity = 0.5;
          obj.material.opacity = 1.0;
          obj.material.transparent = false;
          obj.scale.set(1, 1, 1);
        });

        edgeObjects.forEach(obj => {
          obj.material.opacity = obj.userData.originalOpacity;
          obj.scale.set(1, 1, 1);
        });

        // æ·±åº¦è¨ˆç®—ï¼ˆ3æ¬¡æ¥ç¶šã¾ã§ï¼‰
        const depths = calculateDepths(node.id, 3);

        // é¸æŠãƒãƒ¼ãƒ‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        clicked.material.emissive.setHex(0xffff00); // é»„è‰²
        clicked.material.emissiveIntensity = 1.2;
        clicked.scale.set(2.0, 2.0, 2.0);

        selectedNode = node.id;

        // æ·±åº¦ã«å¿œã˜ãŸãƒã‚¤ãƒ©ã‚¤ãƒˆ
        nodeObjects.forEach(obj => {
          const depth = depths.get(obj.userData.id);
          if (depth !== undefined && depth > 0) {
            if (depth === 1) {
              // ç¬¬1æ¬¡æ¥ç¶š - æ˜ã‚‹ã„ç·‘
              obj.material.emissive.setHex(0x00ff00);
              obj.material.emissiveIntensity = 0.8;
              obj.scale.set(1.6, 1.6, 1.6);
            } else if (depth === 2) {
              // ç¬¬2æ¬¡æ¥ç¶š - ã‚·ã‚¢ãƒ³
              obj.material.emissive.setHex(0x00ffff);
              obj.material.emissiveIntensity = 0.6;
              obj.scale.set(1.3, 1.3, 1.3);
            } else if (depth === 3) {
              // ç¬¬3æ¬¡æ¥ç¶š - é’
              obj.material.emissive.setHex(0x4444ff);
              obj.material.emissiveIntensity = 0.4;
              obj.scale.set(1.1, 1.1, 1.1);
            }
          } else if (obj.userData.id !== node.id) {
            // ç„¡é–¢ä¿‚ãªãƒãƒ¼ãƒ‰ - éå¸¸ã«è–„ã
            obj.material.opacity = 0.15;
            obj.material.transparent = true;
          }
        });

        // ã‚¨ãƒƒã‚¸ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ - æ·±åº¦ã‚’è€ƒæ…®
        edgeObjects.forEach(obj => {
          const edge = obj.userData.edge;
          const fromDepth = depths.get(edge.from) ?? Infinity;
          const toDepth = depths.get(edge.to) ?? Infinity;
          const isRelated = depths.has(edge.from) && depths.has(edge.to);

          if (isRelated) {
            const minDepth = Math.min(fromDepth, toDepth);
            if (minDepth === 0) {
              // é¸æŠãƒãƒ¼ãƒ‰ã¸ã®ç›´æ¥æ¥ç¶š
              obj.material.opacity = Math.min(1.0, obj.userData.originalOpacity * 3);
              obj.scale.set(2.5, 2.5, 2.5);
            } else if (minDepth === 1) {
              obj.material.opacity = Math.min(0.9, obj.userData.originalOpacity * 2.5);
              obj.scale.set(2.0, 2.0, 2.0);
            } else if (minDepth === 2) {
              obj.material.opacity = Math.min(0.8, obj.userData.originalOpacity * 2);
              obj.scale.set(1.5, 1.5, 1.5);
            } else {
              obj.material.opacity = Math.min(0.7, obj.userData.originalOpacity * 1.5);
              obj.scale.set(1.2, 1.2, 1.2);
            }
          } else {
            // ç„¡é–¢ä¿‚ãªã‚¨ãƒƒã‚¸ - éå¸¸ã«è–„ãç´°ã
            obj.material.opacity = 0.05;
            obj.scale.set(0.5, 0.5, 0.5);
          }
        });

        // æƒ…å ±ãƒ‘ãƒãƒ«æ›´æ–° - æ·±åº¦æƒ…å ±ã‚’è¿½åŠ 
        const depthCounts = new Map();
        depths.forEach((depth, nodeId) => {
          depthCounts.set(depth, (depthCounts.get(depth) || 0) + 1);
        });

        let depthInfo = '';
        for (let d = 1; d <= 3; d++) {
          const count = depthCounts.get(d) || 0;
          if (count > 0) {
            depthInfo += `ç¬¬${d}æ¬¡: ${count}å€‹<br>`;
          }
        }

        document.getElementById('current').innerHTML = `
          <strong>ğŸ“Œ é¸æŠä¸­</strong><br>
          ğŸ“„ ${node.label}.ts<br>
          å„ªå…ˆåº¦: ${node.priority.toFixed(3)}<br><br>
          <strong>ğŸ”— é–¢é€£ãƒãƒ¼ãƒ‰:</strong><br>
          ${depthInfo}
          åˆè¨ˆ: ${depths.size - 1}å€‹
        `;

        const relatedNodes = [];
        depths.forEach((depth, nodeId) => {
          if (depth > 0 && depth <= 3) {
            const n = sampleNodes.find(sn => sn.id === nodeId);
            if (n) relatedNodes.push(n.label + '.ts');
          }
        });
        document.getElementById('related').textContent = relatedNodes.join(', ');
      }
    });

    // 3è»¸è¡¨ç¤ºã‚ªãƒ³ã‚ªãƒ•
    document.getElementById('toggle-x').addEventListener('change', (e) => {
      // Xè»¸ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆï¼ˆèµ¤è‰²ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰
      axisHelper.visible = e.target.checked ||
        document.getElementById('toggle-y').checked ||
        document.getElementById('toggle-z').checked;
    });

    document.getElementById('toggle-y').addEventListener('change', (e) => {
      // Yè»¸ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆï¼ˆç·‘è‰²ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰
      axisHelper.visible = e.target.checked ||
        document.getElementById('toggle-x').checked ||
        document.getElementById('toggle-z').checked;
    });

    document.getElementById('toggle-z').addEventListener('change', (e) => {
      // Zè»¸ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆï¼ˆé’è‰²ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰
      axisHelper.visible = e.target.checked ||
        document.getElementById('toggle-x').checked ||
        document.getElementById('toggle-y').checked;
    });

    document.getElementById('toggle-grid').addEventListener('change', (e) => {
      gridHelper.visible = e.target.checked;
    });

    document.getElementById('toggle-orbits').addEventListener('change', (e) => {
      orbitGroup.visible = e.target.checked;
    });

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
    function animate() {
      requestAnimationFrame(animate);

      // ã‚´ãƒ¼ãƒ«ã‚’å›è»¢
      goal.rotation.y += 0.005;
      goalGlow.rotation.y -= 0.003;

      // èƒŒæ™¯ã®æ˜Ÿã‚’ã‚†ã£ãã‚Šå›è»¢
      stars.rotation.y += 0.0002;

      controls.update();
      renderer.render(scene, camera);
    }

    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Œäº†
    if (loadingEl) loadingEl.style.display = 'none';

    animate();
      } catch (error) {
        showInitError(error);
      }
    })();
  </script>
</body>
</html>
