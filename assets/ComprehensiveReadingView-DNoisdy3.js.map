{"version":3,"file":"ComprehensiveReadingView-DNoisdy3.js","sources":["../../src/utils/passageLoader.ts","../../src/utils/passageAdapter.ts","../../src/utils/readingTechniquesLoader.ts","../../src/utils/dependencySvocm.ts","../../src/utils/grammarAnalyzer.ts","../../src/components/ComprehensiveReadingView.tsx"],"sourcesContent":["/**\n * パッセージローダー - public/data/passages/*.txt ファイルの読み込み\n * PASSAGE_CREATION_GUIDELINES.md の仕様に基づく\n */\n\nimport { logger } from '@/utils/logger';\n\nexport interface PassageMetadata {\n  id: string;\n  title: string;\n  level: 'beginner' | 'intermediate' | 'advanced';\n  topic: string;\n  wordCount: number;\n  filePath: string;\n}\n\nexport interface LoadedPassage extends PassageMetadata {\n  content: string;\n  sections: PassageSection[];\n}\n\nexport interface PassageSection {\n  title: string;\n  paragraphs: string[];\n}\n\n/**\n * ファイルパスからタイトルを抽出\n * 例: /data/passages-for-phrase-work/beginner_1200_Shopping-at-the-Supermarket.txt\n *     → \"Shopping-at-the-Supermarket\"\n */\nfunction extractTitleFromPath(filePath: string): string {\n  const fileName = filePath.split('/').pop() || '';\n  const withoutExt = fileName.replace(/\\.txt$/, '');\n  const parts = withoutExt.split('_');\n\n  if (parts.length >= 3) {\n    // 難易度_語数_タイトル の形式\n    const titlePart = parts.slice(2).join('_');\n    // ファイル名と完全一致させるためハイフンはそのまま維持\n    return titlePart;\n  }\n\n  return fileName;\n}\n\n// パッセージ一覧定義（public/data/passages-for-phrase-work/ 配下の全ファイル）\n// ファイル名形式: 難易度_語数_タイトル.txt\n// titleはファイルパスから自動抽出される\nconst PASSAGE_FILES_RAW = [\n  // Beginner (6 passages)\n  {\n    id: 'beginner-morning-routine',\n    level: 'beginner',\n    topic: 'daily-life',\n    wordCount: 50,\n    filePath: '/data/passages-for-phrase-work/beginner_50_Morning-Routine.txt',\n  },\n  {\n    id: 'beginner-supermarket-shopping',\n    level: 'beginner',\n    topic: 'daily-life',\n    wordCount: 1910,\n    filePath: '/data/passages-for-phrase-work/beginner_1910_Shopping-at-the-Supermarket.txt',\n  },\n  {\n    id: 'beginner-cafe-day',\n    level: 'beginner',\n    topic: 'food-culture',\n    wordCount: 1380,\n    filePath: '/data/passages-for-phrase-work/beginner_1380_A-Day-at-the-Cafe.txt',\n  },\n  {\n    id: 'beginner-conversation-daily',\n    level: 'beginner',\n    topic: 'communication',\n    wordCount: 3018,\n    filePath: '/data/passages-for-phrase-work/beginner_3018_Daily-Conversations.txt',\n  },\n  {\n    id: 'beginner-weather-seasons',\n    level: 'beginner',\n    topic: 'nature',\n    wordCount: 2111,\n    filePath: '/data/passages-for-phrase-work/beginner_2111_Weather-and-Seasons.txt',\n  },\n  {\n    id: 'beginner-wildlife-park-guide',\n    level: 'beginner',\n    topic: 'animals',\n    wordCount: 2097,\n    filePath: '/data/passages-for-phrase-work/beginner_2097_Wildlife-Park-Guide.txt',\n  },\n\n  // Intermediate (8 passages)\n  {\n    id: 'intermediate-exchange-student-australia',\n    level: 'intermediate',\n    topic: 'culture-exchange',\n    wordCount: 3199,\n    filePath: '/data/passages-for-phrase-work/intermediate_3199_Exchange-Student-in-Australia.txt',\n  },\n  {\n    id: 'intermediate-homestay-america',\n    level: 'intermediate',\n    topic: 'culture-exchange',\n    wordCount: 3148,\n    filePath: '/data/passages-for-phrase-work/intermediate_3148_Homestay-in-America.txt',\n  },\n  {\n    id: 'intermediate-career-day',\n    level: 'intermediate',\n    topic: 'education-career',\n    wordCount: 2895,\n    filePath: '/data/passages-for-phrase-work/intermediate_2895_Career-Day-at-School.txt',\n  },\n  {\n    id: 'intermediate-hospital-visit',\n    level: 'intermediate',\n    topic: 'health',\n    wordCount: 2721,\n    filePath: '/data/passages-for-phrase-work/intermediate_2721_A-Visit-to-the-Hospital.txt',\n  },\n  {\n    id: 'intermediate-science-museum',\n    level: 'intermediate',\n    topic: 'science-education',\n    wordCount: 3265,\n    filePath: '/data/passages-for-phrase-work/intermediate_3265_Science-Museum-Experience.txt',\n  },\n  {\n    id: 'intermediate-community-events',\n    level: 'intermediate',\n    topic: 'community',\n    wordCount: 2216,\n    filePath: '/data/passages-for-phrase-work/intermediate_2216_Community-Events.txt',\n  },\n  {\n    id: 'intermediate-school-events-year',\n    level: 'intermediate',\n    topic: 'school-life',\n    wordCount: 2558,\n    filePath: '/data/passages-for-phrase-work/intermediate_2558_A-Year-of-School-Events.txt',\n  },\n  {\n    id: 'intermediate-school-news',\n    level: 'intermediate',\n    topic: 'school-life',\n    wordCount: 1937,\n    filePath: '/data/passages-for-phrase-work/intermediate_1937_School-News.txt',\n  },\n\n  // Advanced (8 passages)\n  {\n    id: 'advanced-environmental-issues',\n    level: 'advanced',\n    topic: 'environment',\n    wordCount: 4263,\n    filePath: '/data/passages-for-phrase-work/advanced_4263_Environmental-Issues-and-Solutions.txt',\n  },\n  {\n    id: 'advanced-family-gathering',\n    level: 'advanced',\n    topic: 'culture-family',\n    wordCount: 4493,\n    filePath: '/data/passages-for-phrase-work/advanced_4493_Family-Gathering-Traditions.txt',\n  },\n  {\n    id: 'advanced-health-statistics',\n    level: 'advanced',\n    topic: 'health-data',\n    wordCount: 3422,\n    filePath: '/data/passages-for-phrase-work/advanced_3422_Health-Statistics-Analysis.txt',\n  },\n  {\n    id: 'advanced-historical-figures',\n    level: 'advanced',\n    topic: 'history',\n    wordCount: 3115,\n    filePath: '/data/passages-for-phrase-work/advanced_3115_Historical-Figures-Study.txt',\n  },\n  {\n    id: 'advanced-international-exchange',\n    level: 'advanced',\n    topic: 'culture-global',\n    wordCount: 3813,\n    filePath: '/data/passages-for-phrase-work/advanced_3813_Cultural-Exchange-Insights.txt',\n  },\n  {\n    id: 'advanced-school-festival',\n    level: 'advanced',\n    topic: 'school-events',\n    wordCount: 4419,\n    filePath: '/data/passages-for-phrase-work/advanced_4419_School-Festival-Planning.txt',\n  },\n  {\n    id: 'advanced-summer-vacation-stories',\n    level: 'advanced',\n    topic: 'personal-growth',\n    wordCount: 3255,\n    filePath: '/data/passages-for-phrase-work/advanced_3255_Summer-Vacation-Stories.txt',\n  },\n  {\n    id: 'advanced-technology-future',\n    level: 'advanced',\n    topic: 'technology-innovation',\n    wordCount: 3161,\n    filePath: '/data/passages-for-phrase-work/advanced_3161_Technology-and-Future.txt',\n  },\n] as const;\n\n// ファイルパスからtitleを自動生成\nconst PASSAGE_FILES: PassageMetadata[] = PASSAGE_FILES_RAW.map((passage) => ({\n  ...passage,\n  title: extractTitleFromPath(passage.filePath),\n  level: passage.level as 'beginner' | 'intermediate' | 'advanced',\n}));\n\n/**\n * パッセージ一覧を取得\n */\nexport function getPassageList(): PassageMetadata[] {\n  return PASSAGE_FILES;\n}\n\n/**\n * レベル別にパッセージをフィルタ\n */\nexport function getPassagesByLevel(\n  level: 'beginner' | 'intermediate' | 'advanced'\n): PassageMetadata[] {\n  return PASSAGE_FILES.filter((p) => p.level === level);\n}\n\n/**\n * passages-original から元のテキストファイルを読み込み（全文表示用）\n */\nexport async function loadOriginalPassage(passageId: string): Promise<string> {\n  try {\n    // ファイルパスを構築\n    // 例: beginner-morning-routine -> /data/passages-original/beginner_50_Morning-Routine.txt\n    const metadata = PASSAGE_FILES.find((p) => p.id === passageId);\n    if (!metadata) {\n      logger.error(`Passage not found: ${passageId}`);\n      return '';\n    }\n\n    // filePathからファイル名を抽出\n    const fileName = metadata.filePath.split('/').pop() || '';\n    const originalPath = `/data/passages-original/${fileName}`;\n\n    const response = await fetch(originalPath);\n    if (!response.ok) {\n      logger.log(`Original file not found: ${originalPath}`);\n      return '';\n    }\n\n    const content = await response.text();\n    return content;\n  } catch (error) {\n    logger.error(`Error loading original passage ${passageId}:`, error);\n    return '';\n  }\n}\n\n/**\n * パッセージを読み込み\n */\nexport async function loadPassage(passageId: string): Promise<LoadedPassage | null> {\n  const metadata = PASSAGE_FILES.find((p) => p.id === passageId);\n  if (!metadata) {\n    logger.error(`Passage not found: ${passageId}`);\n    return null;\n  }\n\n  try {\n    const response = await fetch(metadata.filePath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n\n    const content = await response.text();\n    const sections = parsePassageContent(content);\n\n    return {\n      ...metadata,\n      content,\n      sections,\n    };\n  } catch (error) {\n    logger.error(`Error loading passage ${passageId}:`, error);\n    return null;\n  }\n}\n\n/**\n * パッセージ内容を解析してセクションに分割\n * PASSAGE_CREATION_GUIDELINES.md の構造に基づく\n */\nfunction parsePassageContent(content: string): PassageSection[] {\n  const lines = content.split('\\n');\n  const sections: PassageSection[] = [];\n  let currentSection: PassageSection | null = null;\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    // 空行はスキップ\n    if (!trimmed) {\n      continue;\n    }\n\n    // セクションタイトル判定（段落字下げなし、短い行）\n    // ガイドラインに基づき、セクションヘッダーは字下げなし\n    if (!line.startsWith('    ') && trimmed.length > 0 && trimmed.length < 80) {\n      // 新しいセクション開始\n      if (currentSection) {\n        sections.push(currentSection);\n      }\n      currentSection = {\n        title: trimmed,\n        paragraphs: [],\n      };\n    } else if (line.startsWith('    ') && currentSection) {\n      // 段落（4スペース字下げ）\n      currentSection.paragraphs.push(trimmed);\n    }\n  }\n\n  // 最後のセクションを追加\n  if (currentSection) {\n    sections.push(currentSection);\n  }\n\n  return sections;\n}\n\n/**\n * パッセージの統計情報を取得\n */\nexport function getPassageStats() {\n  const stats = {\n    total: PASSAGE_FILES.length,\n    byLevel: {\n      beginner: PASSAGE_FILES.filter((p) => p.level === 'beginner').length,\n      intermediate: PASSAGE_FILES.filter((p) => p.level === 'intermediate').length,\n      advanced: PASSAGE_FILES.filter((p) => p.level === 'advanced').length,\n    },\n    totalWords: PASSAGE_FILES.reduce((sum, p) => sum + p.wordCount, 0),\n  };\n\n  return stats;\n}\n","/**\n * パッセージデータアダプター\n * 新しい .txt ベースのパッセージを既存の ReadingPassage 型に変換\n */\n\nimport { ReadingPassage, ReadingSegment } from '../types';\nimport { getPassageList, loadPassage, loadOriginalPassage } from './passageLoader';\nimport { logger } from '@/utils/logger';\n\nconst PASSAGE_FILE_BASE_BY_ID: Record<string, string> = {\n  'beginner-morning-routine': 'beginner_50_Morning-Routine',\n};\n\nfunction resolvePassageFileBase(passageId: string): string {\n  if (PASSAGE_FILE_BASE_BY_ID[passageId]) return PASSAGE_FILE_BASE_BY_ID[passageId];\n  const metadata = getPassageList().find((p) => p.id === passageId);\n  if (!metadata) return passageId;\n  const fileName = metadata.filePath.split('/').pop() || '';\n  return fileName.replace(/\\.txt$/, '') || passageId;\n}\n\n// 補助関数: 単語の基本形を取得（簡易版）\nfunction getLemma(word: string): string {\n  const cleaned = word.toLowerCase().trim();\n\n  // -ing形\n  if (cleaned.endsWith('ing') && cleaned.length > 4) {\n    const base = cleaned.slice(0, -3);\n    if (base.endsWith('n') || base.endsWith('m') || base.endsWith('t')) {\n      return base.slice(0, -1); // running → run\n    }\n    return base + 'e'; // making → make (推測)\n  }\n\n  // -ed形\n  if (cleaned.endsWith('ed') && cleaned.length > 3) {\n    const base = cleaned.slice(0, -2);\n    if (base.endsWith('i')) {\n      return base.slice(0, -1) + 'y'; // studied → study\n    }\n    return base;\n  }\n\n  // -s/-es形\n  if (cleaned.endsWith('es') && cleaned.length > 3) {\n    return cleaned.slice(0, -2);\n  }\n  if (cleaned.endsWith('s') && cleaned.length > 2 && !cleaned.endsWith('ss')) {\n    return cleaned.slice(0, -1);\n  }\n\n  return cleaned;\n}\n\n/**\n * 長い文を接続詞で分割（20単語超の場合）\n */\nfunction _splitLongSentence(sentence: string): string[] {\n  const words = sentence.trim().split(/\\s+/);\n\n  // 20単語以下ならそのまま返す\n  if (words.length <= 20) {\n    return [sentence];\n  }\n\n  // 接続詞パターン（大文字小文字両対応）\n  const conjunctionPattern =\n    /\\b(when|if|because|although|while|since|after|before|unless|until|as|though|whereas)\\b/gi;\n\n  // 接続詞で分割を試みる\n  const parts: string[] = [];\n  let currentPart = '';\n  let wordCount = 0;\n\n  const sentenceWords = sentence.match(/\\S+|\\s+/g) || [];\n\n  for (let i = 0; i < sentenceWords.length; i++) {\n    const token = sentenceWords[i];\n\n    // 空白はスキップ\n    if (/^\\s+$/.test(token)) {\n      currentPart += token;\n      continue;\n    }\n\n    // 接続詞を検出（20単語以上の場合のみ分割）\n    if (wordCount >= 15 && conjunctionPattern.test(token)) {\n      // 現在のパートを保存\n      if (currentPart.trim()) {\n        parts.push(currentPart.trim());\n      }\n      // 新しいパートを開始（接続詞から）\n      currentPart = token;\n      wordCount = 1;\n    } else {\n      currentPart += token;\n      wordCount++;\n    }\n  }\n\n  // 最後のパートを追加\n  if (currentPart.trim()) {\n    parts.push(currentPart.trim());\n  }\n\n  // 分割できなかった場合は元の文を返す\n  return parts.length > 0 ? parts : [sentence];\n}\n\n/**\n * 全訳ファイルを読み込む\n */\nasync function loadFullTranslation(passageId: string): Promise<string> {\n  try {\n    const fileBase = resolvePassageFileBase(passageId);\n    const candidates = [\n      `/data/passages/4_passages-translations/${fileBase}_full.txt`,\n      `/data/passages/4_passages-translations/${fileBase}.txt`,\n      `/data/passages/passages-translations/${passageId}-ja.txt`,\n      `/data/passages-translations/${passageId}-ja.txt`,\n    ];\n\n    for (const translationFilePath of candidates) {\n      const response = await fetch(translationFilePath);\n      if (!response.ok) continue;\n      const content = await response.text();\n      return content;\n    }\n\n    return '';\n  } catch (_error) {\n    console.error(`[全訳] Error loading full translation for ${passageId}:`, _error);\n    return '';\n  }\n}\n\n/**\n * 日本語フレーズファイルを読み込む（passages-for-phrase-work-jaから）\n * フレーズ訳: 全訳を尊重しつつ、フレーズごとに意味が通るように直訳されたもの\n * passages-for-phrase-workの英文と行番号が一致\n */\nasync function loadJapanesePhrases(passageId: string): Promise<string[]> {\n  try {\n    const fileBase = resolvePassageFileBase(passageId);\n    const jaFilePath = `/data/passages/5_passages-for-phrase-work-ja/${fileBase}.txt`;\n\n    const response = await fetch(jaFilePath);\n    if (!response.ok) {\n      logger.log(`No Japanese phrase file found: ${jaFilePath}`);\n      return [];\n    }\n\n    const content = await response.text();\n    const lines = content\n      .split('\\n')\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0); // 空行を除外\n\n    logger.log(`Loaded ${lines.length} Japanese phrases from ${jaFilePath}`);\n    return lines;\n  } catch (_error) {\n    logger.error(`Error loading Japanese phrases for ${passageId}:`, _error);\n    return [];\n  }\n}\n\n/**\n * .txt パッセージを ReadingPassage 型に変換\n */\nexport async function convertPassageToReadingFormat(\n  passageId: string,\n  wordDictionary: Map<string, any>\n): Promise<ReadingPassage | null> {\n  const loaded = await loadPassage(passageId);\n  if (!loaded) return null;\n\n  // 日本語フレーズ、全訳、元の全文を並行して読み込む\n  const [japanesePhrases, fullTranslation, originalText] = await Promise.all([\n    loadJapanesePhrases(passageId),\n    loadFullTranslation(passageId),\n    loadOriginalPassage(passageId),\n  ]);\n  let japaneseIndex = 0;\n\n  // セクションごとにフレーズ（文単位）を生成\n  const phrases: any[] = [];\n\n  loaded.sections.forEach((section) => {\n    section.paragraphs.forEach((paragraph) => {\n      // 会話形式（Speaker: \"...\"）のパターンをチェック\n      const conversationMatch = paragraph.match(/^([^:]+):\\s*\"([^\"]+)\"$/);\n\n      if (conversationMatch) {\n        // 会話文の場合: 全体を1つのフレーズとして扱う\n        const fullText = paragraph.trim();\n        const words = fullText.split(/\\s+/);\n\n        // セグメントを生成\n        const segments: ReadingSegment[] = words\n          .map((word) => {\n            // 先頭の引用符を除去して処理\n            let processWord = word;\n            let leadingQuote = '';\n            if (processWord.startsWith('\"')) {\n              leadingQuote = '\"';\n              processWord = processWord.substring(1);\n            }\n\n            // 略語パターン（Ms., Mr., Dr.など）をチェック\n            const abbreviationPattern =\n              /^(Ms|Mr|Mrs|Dr|Prof|St|Ave|Inc|Ltd|etc)\\.$|^[A-Z]\\.$|^vs\\.$|^e\\.g\\.$|^i\\.e\\.$/;\n            if (abbreviationPattern.test(processWord)) {\n              // 略語は分割せずそのまま1単語として扱う\n              const lemma = getLemma(processWord.replace(/\\.$/, '')); // ピリオドなしで辞書検索\n              const wordData = wordDictionary.get(lemma);\n              const meaning = wordData?.meaning || '';\n\n              const result: ReadingSegment[] = [];\n              if (leadingQuote) {\n                result.push({\n                  word: leadingQuote,\n                  meaning: '',\n                  isUnknown: false,\n                });\n              }\n              result.push({\n                word: processWord,\n                meaning: meaning === '-' ? '' : meaning,\n                isUnknown: false,\n              });\n              return result;\n            }\n\n            // 引用符や句読点を検出\n            const punctuationMatch = processWord.match(/([.,!?;:—\"])$/);\n\n            if (punctuationMatch) {\n              const cleanWord = processWord.replace(/[.,!?;:—\"]$/, '');\n              const punctuation = punctuationMatch[1];\n\n              if (!cleanWord) {\n                // 引用符のみの場合\n                const result: ReadingSegment[] = [];\n                if (leadingQuote) {\n                  result.push({\n                    word: leadingQuote,\n                    meaning: '',\n                    isUnknown: false,\n                  });\n                }\n                result.push({\n                  word: punctuation,\n                  meaning: '',\n                  isUnknown: false,\n                });\n                return result;\n              }\n\n              const lemma = getLemma(cleanWord);\n              const wordData = wordDictionary.get(lemma);\n              const meaning = wordData?.meaning || '';\n\n              const result: ReadingSegment[] = [];\n              if (leadingQuote) {\n                result.push({\n                  word: leadingQuote,\n                  meaning: '',\n                  isUnknown: false,\n                });\n              }\n              result.push({\n                word: cleanWord,\n                meaning: meaning === '-' ? '' : meaning,\n                isUnknown: false,\n              });\n              result.push({\n                word: punctuation,\n                meaning: '',\n                isUnknown: false,\n              });\n              return result;\n            } else {\n              // 句読点なしの通常の単語\n              const lemma = getLemma(processWord);\n              const wordData = wordDictionary.get(lemma);\n              const meaning = wordData?.meaning || '';\n\n              const result: ReadingSegment[] = [];\n              if (leadingQuote) {\n                result.push({\n                  word: leadingQuote,\n                  meaning: '',\n                  isUnknown: false,\n                });\n              }\n              result.push({\n                word: processWord,\n                meaning: meaning === '-' ? '' : meaning,\n                isUnknown: false,\n              });\n              return result;\n            }\n          })\n          .flat();\n\n        // 日本語訳を取得（行番号と対応）\n        const japanese = japanesePhrases[japaneseIndex] || '';\n        japaneseIndex++;\n\n        phrases.push({\n          english: fullText,\n          japanese: japanese,\n          phraseMeaning: japanese, // phraseMeaningも設定\n          words: words,\n          segments: segments,\n        });\n      } else {\n        // passages-for-phrase-workのファイルは既に節・句で改行済み\n        // 各行をそのまま1フレーズとして扱う\n        const phraseText = paragraph.trim();\n\n        // 単語に分割\n        const words = phraseText.split(/\\s+/);\n\n        // セグメントを生成\n        const segments: ReadingSegment[] = words\n          .map((word) => {\n            // 略語パターン（Ms., Mr., Dr.など）をチェック\n            const abbreviationPattern =\n              /^(Ms|Mr|Mrs|Dr|Prof|St|Ave|Inc|Ltd|etc)\\.$|^[A-Z]\\.$|^vs\\.$|^e\\.g\\.$|^i\\.e\\.$/;\n            if (abbreviationPattern.test(word)) {\n              // 略語は分割せずそのまま1単語として扱う\n              const lemma = getLemma(word.replace(/\\.$/, '')); // ピリオドなしで辞書検索\n              const wordData = wordDictionary.get(lemma);\n              const meaning = wordData?.meaning || '';\n              return {\n                word: word,\n                meaning: meaning === '-' ? '' : meaning,\n                isUnknown: false,\n              };\n            }\n\n            // 句読点を検出\n            const punctuationMatch = word.match(/([.,!?;:—])$/);\n\n            if (punctuationMatch) {\n              const cleanWord = word.replace(/[.,!?;:—]$/, '');\n              const punctuation = punctuationMatch[1];\n\n              // 空の場合（句読点のみ）\n              if (!cleanWord) {\n                return {\n                  word: punctuation,\n                  meaning: '',\n                  isUnknown: false,\n                };\n              }\n\n              const lemma = getLemma(cleanWord);\n              const wordData = wordDictionary.get(lemma);\n              const meaning = wordData?.meaning || '';\n\n              return [\n                {\n                  word: cleanWord,\n                  meaning: meaning === '-' ? '' : meaning,\n                  isUnknown: false,\n                },\n                {\n                  word: punctuation,\n                  meaning: '',\n                  isUnknown: false,\n                },\n              ];\n            } else {\n              // 句読点なしの通常の単語\n              const lemma = getLemma(word);\n              const wordData = wordDictionary.get(lemma);\n              const meaning = wordData?.meaning || '';\n\n              return {\n                word: word,\n                meaning: meaning === '-' ? '' : meaning,\n                isUnknown: false,\n              };\n            }\n          })\n          .flat();\n\n        // 日本語訳を取得（行番号と対応）\n        const japanese = japanesePhrases[japaneseIndex] || '';\n        japaneseIndex++;\n\n        phrases.push({\n          english: phraseText,\n          japanese: japanese,\n          phraseMeaning: japanese, // phraseMeaningも設定\n          words: words,\n          segments: segments,\n        });\n      }\n    });\n  });\n\n  // ReadingPassage型に変換\n  const readingPassage: ReadingPassage = {\n    id: loaded.id,\n    title: loaded.title,\n    level: loaded.level,\n    actualWordCount: loaded.wordCount,\n    phrases: phrases,\n    translation: fullTranslation, // 全訳を設定\n    originalText: originalText, // 元の全文を設定\n  };\n\n  return readingPassage;\n}\n\n/**\n * フレーズ学習用JSONファイルを読み込み（新形式）\n * public/data/passages-phrase-learning/*.json\n */\nexport async function loadPhraseLearningJSON(passageId: string): Promise<ReadingPassage | null> {\n  try {\n    const fileBase = resolvePassageFileBase(passageId);\n    const candidates = [\n      `/data/passages/6_passages-phrase-learning/${fileBase}.json`,\n      `/data/passages-phrase-learning/${passageId}.json`,\n    ];\n\n    let response: Response | null = null;\n    for (const path of candidates) {\n      const res = await fetch(path);\n      if (!res.ok) continue;\n      response = res;\n      break;\n    }\n\n    if (!response) {\n      logger.log(`No phrase learning JSON found for ${passageId}, will use .txt conversion`);\n      return null;\n    }\n    const data = await response.json();\n    logger.log(\n      `Loaded phrase learning JSON for ${passageId}, phrases: ${data.phrases?.length || 0}`\n    );\n\n    // 全訳と元の全文を並行して読み込む\n    const [fullTranslation, originalText] = await Promise.all([\n      loadFullTranslation(passageId),\n      loadOriginalPassage(passageId),\n    ]);\n\n    // JSONデータをそのまま返す(ReadingPassage型に準拠)\n    const readingPassage: ReadingPassage = {\n      ...data,\n      phrases: data.phrases || [], // phrasesが存在しない場合は空配列\n      translation: fullTranslation, // 全訳を追加\n      originalText: originalText, // 元の全文を追加\n    };\n\n    return readingPassage;\n  } catch {\n    // oldフォルダに移動したファイルや存在しないファイルのエラーは静かにスキップ\n    // SyntaxErrorは無効なJSONファイル、404は存在しないファイル\n    logger.log(\n      `Skipping phrase learning JSON for ${passageId} (file may be old or moved), will use .txt conversion`\n    );\n    return null;\n  }\n}\n\n/**\n * 全パッセージを読み込んで ReadingPassage[] に変換\n * 優先順位: 1) フレーズ学習JSON, 2) .txtファイル\n */\nexport async function loadAllPassagesAsReadingFormat(\n  wordDictionary: Map<string, any>\n): Promise<ReadingPassage[]> {\n  const metadata = getPassageList();\n  const passages: ReadingPassage[] = [];\n\n  logger.log(`Loading ${metadata.length} passages...`);\n\n  for (const meta of metadata) {\n    // まずフレーズ学習JSONを試す\n    let passage = await loadPhraseLearningJSON(meta.id);\n\n    // JSONがなければ従来の.txt変換を試す\n    if (!passage) {\n      passage = await convertPassageToReadingFormat(meta.id, wordDictionary);\n    }\n\n    if (passage) {\n      logger.log(`✓ Loaded passage: ${meta.id} (${passage.phrases?.length || 0} phrases)`);\n      passages.push(passage);\n    } else {\n      logger.error(`✗ Failed to load passage: ${meta.id}`);\n    }\n  }\n\n  logger.log(`Total passages loaded: ${passages.length}`);\n  return passages;\n}\n\n/**\n * レベルラベルを統一（'beginner' → '初級'）\n */\nexport function getLevelLabel(level: string): string {\n  const levelMap: Record<string, string> = {\n    beginner: '初級',\n    intermediate: '中級',\n    advanced: '上級',\n  };\n  return levelMap[level] || level;\n}\n","import { logger } from '@/utils/logger';\nimport type {\n  ParagraphReadingPatternsFileV1,\n  SentenceReadingPatternsFileV1,\n  QuestionTypeStrategiesFileV1,\n  Reading100ParaphrasedFileV1,\n} from '@/types/readingTechniques';\n\ntype CacheKey =\n  | 'paragraph_reading_patterns'\n  | 'sentence_reading_patterns'\n  | 'question_type_strategies'\n  | 'reading100_paraphrased';\n\nconst cache = new Map<CacheKey, Promise<unknown | null>>();\n\nasync function fetchJson<T>(path: string): Promise<T | null> {\n  try {\n    const res = await fetch(path);\n    if (!res.ok) return null;\n    return (await res.json()) as T;\n  } catch (err) {\n    logger.warn(`[readingTechniquesLoader] Failed to load ${path}:`, err);\n    return null;\n  }\n}\n\nfunction cached<T>(key: CacheKey, path: string): Promise<T | null> {\n  if (!cache.has(key)) {\n    cache.set(key, fetchJson<T>(path));\n  }\n  return cache.get(key) as Promise<T | null>;\n}\n\nfunction parseTrailingNumber(id: string): number | null {\n  const match = id.match(/(\\d+)$/);\n  if (!match) return null;\n  const n = Number(match[1]);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction sortByIdNumber<T extends { id: string }>(items: T[]): T[] {\n  return items\n    .slice()\n    .sort((a, b) => (parseTrailingNumber(a.id) ?? Number.POSITIVE_INFINITY) - (parseTrailingNumber(b.id) ?? Number.POSITIVE_INFINITY));\n}\n\nexport function loadParagraphReadingPatterns(): Promise<ParagraphReadingPatternsFileV1 | null> {\n  return cached<ParagraphReadingPatternsFileV1>(\n    'paragraph_reading_patterns',\n    '/data/reading-techniques/paragraph_reading_patterns.json'\n  ).then((data) => {\n    if (!data) return null;\n    return { ...data, patterns: sortByIdNumber(data.patterns) };\n  });\n}\n\nexport function loadSentenceReadingPatterns(): Promise<SentenceReadingPatternsFileV1 | null> {\n  return cached<SentenceReadingPatternsFileV1>(\n    'sentence_reading_patterns',\n    '/data/reading-techniques/sentence_reading_patterns.json'\n  ).then((data) => {\n    if (!data) return null;\n    return { ...data, patterns: sortByIdNumber(data.patterns) };\n  });\n}\n\nexport function loadQuestionTypeStrategies(): Promise<QuestionTypeStrategiesFileV1 | null> {\n  return cached<QuestionTypeStrategiesFileV1>(\n    'question_type_strategies',\n    '/data/reading-techniques/question_type_strategies.json'\n  ).then((data) => {\n    if (!data) return null;\n    return { ...data, strategies: sortByIdNumber(data.strategies) };\n  });\n}\n\nexport function loadReading100Paraphrased(): Promise<Reading100ParaphrasedFileV1 | null> {\n  return cached<Reading100ParaphrasedFileV1>(\n    'reading100_paraphrased',\n    '/data/reading-techniques/reading100_paraphrased.json'\n  ).then((data) => {\n    if (!data) return null;\n    return {\n      ...data,\n      techniques: data.techniques\n        .slice()\n        .sort((a, b) => (a.originIndex ?? parseTrailingNumber(a.id) ?? 0) - (b.originIndex ?? parseTrailingNumber(b.id) ?? 0)),\n    };\n  });\n}\n","import type { DependencyToken, SVOCMComponent } from '@/types/passage';\n\nexport function mapDependencyTokensToSVOCMByStartIndex(\n  tokens: DependencyToken[]\n): Map<number, SVOCMComponent> {\n  const byId = new Map<number, DependencyToken>();\n  const childrenByHead = new Map<number, number[]>();\n  const roleById = new Map<number, SVOCMComponent>();\n\n  for (const t of tokens) {\n    byId.set(t.id, t);\n    const head = typeof t.head === 'number' ? t.head : 0;\n    const arr = childrenByHead.get(head) ?? [];\n    arr.push(t.id);\n    childrenByHead.set(head, arr);\n  }\n\n  const deprelLower = (t: DependencyToken) => (t.deprel ?? '').toLowerCase();\n  const uposUpper = (t: DependencyToken) => (t.upos ?? '').toUpperCase();\n  const isPunct = (t: DependencyToken) => uposUpper(t) === 'PUNCT' || deprelLower(t) === 'punct';\n\n  const root = tokens.find((t) => (t.head ?? 0) === 0) ?? tokens[0];\n  if (!root) return new Map();\n\n  const findChild = (headId: number, deprel: string): DependencyToken | undefined => {\n    const kids = childrenByHead.get(headId) ?? [];\n    for (const id of kids) {\n      const tok = byId.get(id);\n      if (tok && deprelLower(tok) === deprel) return tok;\n    }\n    return undefined;\n  };\n\n  const collectSubtree = (headId: number, excludeDeprels?: Set<string>): number[] => {\n    const out: number[] = [];\n    const stack = [headId];\n    while (stack.length) {\n      const cur = stack.pop()!;\n      out.push(cur);\n      const kids = childrenByHead.get(cur) ?? [];\n      for (const k of kids) {\n        const tok = byId.get(k);\n        if (!tok) continue;\n        if (excludeDeprels && excludeDeprels.has(deprelLower(tok))) continue;\n        stack.push(k);\n      }\n    }\n    return out;\n  };\n\n  const cop = findChild(root.id, 'cop');\n  const isCopular = !!cop && ['NOUN', 'PROPN', 'ADJ'].includes(uposUpper(root));\n\n  // S (主語)\n  for (const t of tokens) {\n    const rel = deprelLower(t);\n    if (rel === 'nsubj' || rel === 'nsubj:pass' || rel === 'csubj') {\n      for (const id of collectSubtree(t.id)) {\n        const tok = byId.get(id);\n        if (!tok || isPunct(tok)) continue;\n        roleById.set(id, 'S');\n      }\n    }\n  }\n\n  // O (目的語)\n  for (const t of tokens) {\n    const rel = deprelLower(t);\n    if (rel === 'obj' || rel === 'iobj') {\n      for (const id of collectSubtree(t.id)) {\n        const tok = byId.get(id);\n        if (!tok || isPunct(tok)) continue;\n        roleById.set(id, 'O');\n      }\n    }\n  }\n\n  // C (補語)\n  if (isCopular) {\n    const exclude = new Set<string>(['cop', 'punct']);\n    for (const id of collectSubtree(root.id, exclude)) {\n      const tok = byId.get(id);\n      if (!tok || isPunct(tok)) continue;\n      // 既に主語(S)や目的語(O)などが付いている場合は上書きしない\n      if (!roleById.has(id)) roleById.set(id, 'C');\n    }\n  }\n\n  // V (動詞)\n  if (isCopular && cop) {\n    roleById.set(cop.id, 'V');\n  } else {\n    if (!isPunct(root)) roleById.set(root.id, 'V');\n\n    // 句動詞の一部（compound:prt）も動詞として扱う\n    // 例: wake up, get up, put on など\n    for (const t of tokens) {\n      const rel = deprelLower(t);\n      if (rel === 'compound:prt') {\n        roleById.set(t.id, 'V');\n      }\n    }\n  }\n\n  // C (補語/補部) - B方針: 結果補語・目的語補語もCとして扱う\n  // 例: get my bag ready / make him happy / keep the door open\n  // UDでは ready/happy/open が xcomp (ADJ/NOUN 等) になりやすい\n  if (!isCopular) {\n    for (const t of tokens) {\n      const rel = deprelLower(t);\n      if (rel !== 'xcomp') continue;\n\n      const upos = uposUpper(t);\n      // 動詞のxcomp（to do等）まで広げると誤爆しやすいので、まずは形容詞/名詞系に限定\n      const looksLikeComplement = upos === 'ADJ' || upos === 'NOUN' || upos === 'PROPN';\n      if (!looksLikeComplement) continue;\n\n      for (const id of collectSubtree(t.id)) {\n        const tok = byId.get(id);\n        if (!tok || isPunct(tok)) continue;\n        // 既にS/O/V等が付いている場合は上書きしない\n        if (!roleById.has(id)) roleById.set(id, 'C');\n      }\n    }\n  }\n\n  // その他はM（句読点は除外）\n  for (const t of tokens) {\n    if (isPunct(t)) continue;\n    if (!roleById.has(t.id)) roleById.set(t.id, 'M');\n  }\n\n  const out = new Map<number, SVOCMComponent>();\n  for (const t of tokens) {\n    const role = roleById.get(t.id);\n    if (!role) continue;\n    out.set(t.start, role);\n  }\n  return out;\n}\n","/**\n * 文法解析ユーティリティ\n * 英文の単語に基本的な文法タグ（S, V, O, C, M等）を付与する\n */\n\nimport type { DependencyToken } from '@/types/passage';\nimport { mapDependencyTokensToSVOCMByStartIndex } from '@/utils/dependencySvocm';\n\nexport type GrammarTag =\n  | 'S'\n  | 'V'\n  | 'O'\n  | 'C'\n  | 'M'\n  | 'Prep'\n  | 'Conj'\n  | 'Det'\n  | 'Adj'\n  | 'Adv'\n  | 'Unknown';\n\nexport interface GrammarAnalysisResult {\n  word: string;\n  tag: GrammarTag;\n  color: string;\n  description: string;\n}\n\n// 品詞判定用の辞書\nconst VERBS = new Set([\n  'be',\n  'am',\n  'is',\n  'are',\n  'was',\n  'were',\n  'been',\n  'being',\n  'have',\n  'has',\n  'had',\n  'having',\n  'do',\n  'does',\n  'did',\n  'done',\n  'doing',\n  'can',\n  'could',\n  'will',\n  'would',\n  'shall',\n  'should',\n  'may',\n  'might',\n  'must',\n  'go',\n  'goes',\n  'went',\n  'gone',\n  'going',\n  'get',\n  'gets',\n  'got',\n  'gotten',\n  'getting',\n  'make',\n  'makes',\n  'made',\n  'making',\n  'take',\n  'takes',\n  'took',\n  'taken',\n  'taking',\n  'see',\n  'sees',\n  'saw',\n  'seen',\n  'seeing',\n  'come',\n  'comes',\n  'came',\n  'coming',\n  'want',\n  'wants',\n  'wanted',\n  'wanting',\n  'use',\n  'uses',\n  'used',\n  'using',\n  'find',\n  'finds',\n  'found',\n  'finding',\n  'give',\n  'gives',\n  'gave',\n  'given',\n  'giving',\n  'tell',\n  'tells',\n  'told',\n  'telling',\n  'work',\n  'works',\n  'worked',\n  'working',\n  'call',\n  'calls',\n  'called',\n  'calling',\n  'try',\n  'tries',\n  'tried',\n  'trying',\n  'ask',\n  'asks',\n  'asked',\n  'asking',\n  'need',\n  'needs',\n  'needed',\n  'needing',\n  'feel',\n  'feels',\n  'felt',\n  'feeling',\n  'become',\n  'becomes',\n  'became',\n  'becoming',\n  'leave',\n  'leaves',\n  'left',\n  'leaving',\n  'put',\n  'puts',\n  'putting',\n  'mean',\n  'means',\n  'meant',\n  'meaning',\n  'keep',\n  'keeps',\n  'kept',\n  'keeping',\n  'let',\n  'lets',\n  'letting',\n  'begin',\n  'begins',\n  'began',\n  'begun',\n  'beginning',\n  'seem',\n  'seems',\n  'seemed',\n  'seeming',\n  'help',\n  'helps',\n  'helped',\n  'helping',\n  'talk',\n  'talks',\n  'talked',\n  'talking',\n  'turn',\n  'turns',\n  'turned',\n  'turning',\n  'start',\n  'starts',\n  'started',\n  'starting',\n  'show',\n  'shows',\n  'showed',\n  'shown',\n  'showing',\n  'hear',\n  'hears',\n  'heard',\n  'hearing',\n  'play',\n  'plays',\n  'played',\n  'playing',\n  'run',\n  'runs',\n  'ran',\n  'running',\n  'move',\n  'moves',\n  'moved',\n  'moving',\n  'like',\n  'likes',\n  'liked',\n  'liking',\n  'live',\n  'lives',\n  'lived',\n  'living',\n  'believe',\n  'believes',\n  'believed',\n  'believing',\n  'bring',\n  'brings',\n  'brought',\n  'bringing',\n  'happen',\n  'happens',\n  'happened',\n  'happening',\n  'write',\n  'writes',\n  'wrote',\n  'written',\n  'writing',\n  'sit',\n  'sits',\n  'sat',\n  'sitting',\n  'stand',\n  'stands',\n  'stood',\n  'standing',\n  'lose',\n  'loses',\n  'lost',\n  'losing',\n  'pay',\n  'pays',\n  'paid',\n  'paying',\n  'meet',\n  'meets',\n  'met',\n  'meeting',\n  'include',\n  'includes',\n  'included',\n  'including',\n  'continue',\n  'continues',\n  'continued',\n  'continuing',\n  'set',\n  'sets',\n  'setting',\n  'learn',\n  'learns',\n  'learned',\n  'learning',\n  'change',\n  'changes',\n  'changed',\n  'changing',\n  'lead',\n  'leads',\n  'led',\n  'leading',\n  'understand',\n  'understands',\n  'understood',\n  'understanding',\n  'watch',\n  'watches',\n  'watched',\n  'watching',\n  'follow',\n  'follows',\n  'followed',\n  'following',\n  'stop',\n  'stops',\n  'stopped',\n  'stopping',\n  'create',\n  'creates',\n  'created',\n  'creating',\n  'speak',\n  'speaks',\n  'spoke',\n  'spoken',\n  'speaking',\n  'read',\n  'reads',\n  'reading',\n  'spend',\n  'spends',\n  'spent',\n  'spending',\n  'grow',\n  'grows',\n  'grew',\n  'grown',\n  'growing',\n  'open',\n  'opens',\n  'opened',\n  'opening',\n  'walk',\n  'walks',\n  'walked',\n  'walking',\n  'win',\n  'wins',\n  'won',\n  'winning',\n  'teach',\n  'teaches',\n  'taught',\n  'teaching',\n  'offer',\n  'offers',\n  'offered',\n  'offering',\n  'remember',\n  'remembers',\n  'remembered',\n  'remembering',\n  'consider',\n  'considers',\n  'considered',\n  'considering',\n  'appear',\n  'appears',\n  'appeared',\n  'appearing',\n  'buy',\n  'buys',\n  'bought',\n  'buying',\n  'serve',\n  'serves',\n  'served',\n  'serving',\n  'die',\n  'dies',\n  'died',\n  'dying',\n  'send',\n  'sends',\n  'sent',\n  'sending',\n  'build',\n  'builds',\n  'built',\n  'building',\n  'stay',\n  'stays',\n  'stayed',\n  'staying',\n  'fall',\n  'falls',\n  'fell',\n  'fallen',\n  'falling',\n  'cut',\n  'cuts',\n  'cutting',\n  'reach',\n  'reaches',\n  'reached',\n  'reaching',\n  'kill',\n  'kills',\n  'killed',\n  'killing',\n  'raise',\n  'raises',\n  'raised',\n  'raising',\n  'pass',\n  'passes',\n  'passed',\n  'passing',\n  'sell',\n  'sells',\n  'sold',\n  'selling',\n  'decide',\n  'decides',\n  'decided',\n  'deciding',\n  'return',\n  'returns',\n  'returned',\n  'returning',\n  'explain',\n  'explains',\n  'explained',\n  'explaining',\n  'hope',\n  'hopes',\n  'hoped',\n  'hoping',\n  'develop',\n  'develops',\n  'developed',\n  'developing',\n  'carry',\n  'carries',\n  'carried',\n  'carrying',\n  'break',\n  'breaks',\n  'broke',\n  'broken',\n  'breaking',\n  'receive',\n  'receives',\n  'received',\n  'receiving',\n  'agree',\n  'agrees',\n  'agreed',\n  'agreeing',\n  'support',\n  'supports',\n  'supported',\n  'supporting',\n  'hit',\n  'hits',\n  'hitting',\n  'produce',\n  'produces',\n  'produced',\n  'producing',\n  'eat',\n  'eats',\n  'ate',\n  'eaten',\n  'eating',\n  'cover',\n  'covers',\n  'covered',\n  'covering',\n  'catch',\n  'catches',\n  'caught',\n  'catching',\n  'draw',\n  'draws',\n  'drew',\n  'drawn',\n  'drawing',\n  'wake',\n  'wakes',\n  'woke',\n  'woken',\n  'waking',\n  'brush',\n  'brushes',\n  'brushed',\n  'brushing',\n  'wash',\n  'washes',\n  'washed',\n  'washing',\n  'prepare',\n  'prepares',\n  'prepared',\n  'preparing',\n  'check',\n  'checks',\n  'checked',\n  'checking',\n]);\n\nconst PREPOSITIONS = new Set([\n  'in',\n  'on',\n  'at',\n  'to',\n  'for',\n  'with',\n  'from',\n  'by',\n  'about',\n  'as',\n  'into',\n  'like',\n  'through',\n  'after',\n  'over',\n  'between',\n  'out',\n  'against',\n  'during',\n  'without',\n  'before',\n  'under',\n  'around',\n  'among',\n  'of',\n  'up',\n]);\n\nconst CONJUNCTIONS = new Set([\n  'and',\n  'but',\n  'or',\n  'so',\n  'yet',\n  'for',\n  'nor',\n  'because',\n  'although',\n  'if',\n  'when',\n  'while',\n  'since',\n  'unless',\n  'that',\n  'which',\n  'who',\n  'whom',\n  'whose',\n  'where',\n]);\n\nconst DETERMINERS = new Set([\n  'the',\n  'a',\n  'an',\n  'this',\n  'that',\n  'these',\n  'those',\n  'my',\n  'your',\n  'his',\n  'her',\n  'its',\n  'our',\n  'their',\n  'some',\n  'any',\n  'no',\n  'every',\n  'each',\n  'either',\n  'neither',\n  'much',\n  'many',\n  'more',\n  'most',\n  'few',\n  'little',\n  'several',\n]);\n\nconst PRONOUNS = new Set([\n  'i',\n  'you',\n  'he',\n  'she',\n  'it',\n  'we',\n  'they',\n  'me',\n  'him',\n  'her',\n  'us',\n  'them',\n  'myself',\n  'yourself',\n  'himself',\n  'herself',\n  'itself',\n  'ourselves',\n  'themselves',\n]);\n\nconst ADJECTIVES = new Set([\n  'good',\n  'new',\n  'first',\n  'last',\n  'long',\n  'great',\n  'little',\n  'own',\n  'other',\n  'old',\n  'right',\n  'big',\n  'high',\n  'different',\n  'small',\n  'large',\n  'next',\n  'early',\n  'young',\n  'important',\n  'few',\n  'public',\n  'bad',\n  'same',\n  'able',\n  'ready',\n  'usual',\n]);\n\nconst ADVERBS = new Set([\n  'not',\n  'so',\n  'up',\n  'out',\n  'just',\n  'now',\n  'how',\n  'then',\n  'more',\n  'also',\n  'here',\n  'well',\n  'only',\n  'very',\n  'even',\n  'back',\n  'there',\n  'down',\n  'still',\n  'in',\n  'as',\n  'too',\n  'when',\n  'never',\n  'really',\n  'usually',\n  'finally',\n  'first',\n  'after',\n  'before',\n]);\n\n/**\n * 文法タグの色を取得\n */\nfunction getTagColor(tag: GrammarTag): string {\n  const colorMap: Record<GrammarTag, string> = {\n    S: '#3b82f6', // 青 - 主語\n    V: '#ef4444', // 赤 - 動詞\n    O: '#10b981', // 緑 - 目的語\n    C: '#f59e0b', // オレンジ - 補語\n    M: '#8b5cf6', // 紫 - 修飾語\n    Prep: '#6366f1', // インディゴ - 前置詞\n    Conj: '#ec4899', // ピンク - 接続詞\n    Det: '#14b8a6', // ティール - 冠詞\n    Adj: '#f97316', // オレンジ - 形容詞\n    Adv: '#a855f7', // パープル - 副詞\n    Unknown: '#6b7280', // グレー - 不明\n  };\n  return colorMap[tag];\n}\n\n/**\n * 文法タグの説明を取得\n */\nfunction getTagDescription(tag: GrammarTag): string {\n  const descMap: Record<GrammarTag, string> = {\n    S: '主語',\n    V: '動詞',\n    O: '目的語',\n    C: '補語',\n    M: '修飾語',\n    Prep: '前置詞',\n    Conj: '接続詞',\n    Det: '冠詞・限定詞',\n    Adj: '形容詞',\n    Adv: '副詞',\n    Unknown: '不明',\n  };\n  return descMap[tag];\n}\n\n/**\n * 単語の品詞を判定（簡易版）\n */\nfunction classifyWord(word: string, index: number, words: string[]): GrammarTag {\n  const lower = word.toLowerCase();\n\n  // 句読点はスキップ\n  if (/^[.,!?;:]$/.test(word)) {\n    return 'Unknown';\n  }\n\n  // 動詞\n  if (VERBS.has(lower)) {\n    return 'V';\n  }\n\n  // 前置詞\n  if (PREPOSITIONS.has(lower)) {\n    return 'Prep';\n  }\n\n  // 接続詞\n  if (CONJUNCTIONS.has(lower)) {\n    return 'Conj';\n  }\n\n  // 冠詞・限定詞\n  if (DETERMINERS.has(lower)) {\n    return 'Det';\n  }\n\n  // 文頭の接続副詞（First, Then, Finally など）\n  if ((lower === 'first' || lower === 'then' || lower === 'finally') && index === 0) {\n    // カンマ等の句読点を飛ばして次の語を確認\n    let next = index + 1;\n    while (next < words.length && /^[.,!?;:]$/.test(words[next])) {\n      next++;\n    }\n    const nextLower = words[next]?.toLowerCase();\n\n    // \"First, I ...\" のような文頭副詞は Adv\n    if (nextLower && PRONOUNS.has(nextLower)) {\n      return 'Adv';\n    }\n  }\n\n  // 形容詞\n  if (ADJECTIVES.has(lower)) {\n    return 'Adj';\n  }\n\n  // 副詞\n  if (ADVERBS.has(lower)) {\n    return 'Adv';\n  }\n\n  // 代名詞は主語または目的語の可能性\n  if (PRONOUNS.has(lower)) {\n    // 文頭または動詞の前なら主語\n    if (index === 0 || (index > 0 && VERBS.has(words[index + 1]?.toLowerCase()))) {\n      return 'S';\n    }\n    // それ以外は目的語\n    return 'O';\n  }\n\n  return 'Unknown';\n}\n\n/**\n * 句読点の意味を取得\n */\nfunction getPunctuationMeaning(punctuation: string): string {\n  const meanings: Record<string, string> = {\n    '.': '文の終わり',\n    ',': '区切り・列挙',\n    '!': '感嘆・強調',\n    '?': '疑問',\n    ';': '関連する文の区切り',\n    ':': '説明・例示の導入',\n    '-': '補足説明・言い換え',\n    '—': '強い区切り・挿入',\n    '–': '範囲・関係',\n    '\"': '引用',\n    \"'\": '引用・所有格',\n    '(': '補足情報の開始',\n    ')': '補足情報の終了',\n  };\n  return meanings[punctuation] || '句読点';\n}\n\nfunction _tokenizeWithStartIndices(sentence: string): Array<{ token: string; start: number | null }> {\n  const tokens = sentence.match(/\\b[\\w']+\\b|[.,!?;:\\-—–\"'()]/g) || [];\n  let cursor = 0;\n  return tokens.map((t) => {\n    const idx = sentence.indexOf(t, cursor);\n    if (idx >= 0) {\n      cursor = idx + t.length;\n      return { token: t, start: idx };\n    }\n    return { token: t, start: null };\n  });\n}\n\n/**\n * 文を分析して文法タグを付与\n */\nexport function analyzeSentence(sentence: string): GrammarAnalysisResult[] {\n  // 文を単語に分割（句読点、ダッシュも含む）\n  const words = sentence.match(/\\b[\\w']+\\b|[.,!?;:\\-—–\"'()]/g) || [];\n\n  // 頻度表現: \"every + 時間名詞\" は目的語ではなく修飾語（M）として扱う\n  // 例: every morning / every day / every night / every week\n  // NOTE: \"every movie\" のような目的語はここでは対象外にする\n  const EVERY_TIME_NOUNS = new Set([\n    'morning',\n    'afternoon',\n    'evening',\n    'night',\n    'day',\n    'week',\n    'month',\n    'year',\n    'weekend',\n    'weekends',\n  ]);\n\n  const results: GrammarAnalysisResult[] = [];\n  let foundVerb = false;\n  let foundSubject = false;\n  let foundObjectOrComplement = false;\n  let lastVerbLower: string | null = null;\n\n  const BE_VERBS = new Set(['be', 'am', 'is', 'are', 'was', 'were', 'been', 'being']);\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n\n    // 句読点・記号は意味を付けて追加\n    if (/^[.,!?;:\\-—–\"'()]$/.test(word)) {\n      results.push({\n        word,\n        tag: 'Unknown',\n        color: '#6b7280',\n        description: getPunctuationMeaning(word),\n      });\n      continue;\n    }\n\n    let tag = classifyWord(word, i, words);\n\n    // より詳細な分析\n    if (tag === 'Unknown') {\n      // 文頭で大文字始まりなら主語の可能性\n      if (i === 0 && /^[A-Z]/.test(word) && !foundSubject) {\n        tag = 'S';\n        foundSubject = true;\n      }\n      // every + (morning/day/...) は頻度表現なので修飾語\n      else if (i > 0 && words[i - 1].toLowerCase() === 'every' && EVERY_TIME_NOUNS.has(word.toLowerCase())) {\n        tag = 'M';\n      }\n      // 主語+動詞が出現済みで、まだ目的語/補語がない場合は、最初の名詞っぽいUnknownを目的語/補語として扱う\n      else if (\n        foundVerb &&\n        foundSubject &&\n        !foundObjectOrComplement &&\n        !(i > 0 && PREPOSITIONS.has(words[i - 1].toLowerCase()))\n      ) {\n        tag = lastVerbLower && BE_VERBS.has(lastVerbLower) ? 'C' : 'O';\n        foundObjectOrComplement = true;\n      }\n      // 目的語/補語の並列（toast and juice など）: and/or の直後は同じ成分として扱う\n      else if (\n        foundVerb &&\n        foundSubject &&\n        foundObjectOrComplement &&\n        i > 0 &&\n        (words[i - 1].toLowerCase() === 'and' || words[i - 1].toLowerCase() === 'or')\n      ) {\n        tag = lastVerbLower && BE_VERBS.has(lastVerbLower) ? 'C' : 'O';\n      }\n      // 前置詞の後ろなら修飾語\n      else if (i > 0 && PREPOSITIONS.has(words[i - 1].toLowerCase())) {\n        tag = 'M';\n      }\n      // それ以外は修飾語として扱う\n      else {\n        tag = 'M';\n      }\n    }\n\n    if (tag === 'V') {\n      foundVerb = true;\n      lastVerbLower = word.toLowerCase();\n      // 動詞が来たら、次に来る目的語/補語を取り直す（簡易: 句読点や接続詞で区切らない）\n      foundObjectOrComplement = false;\n    }\n    if (tag === 'S') {\n      foundSubject = true;\n    }\n    if (tag === 'O' || tag === 'C') {\n      foundObjectOrComplement = true;\n    }\n\n    results.push({\n      word,\n      tag,\n      color: getTagColor(tag),\n      description: getTagDescription(tag),\n    });\n  }\n\n  return results;\n}\n/**\n * UD依存解析（DependencyToken[]）がある場合に、それを優先してSVOCMタグを付与\n * - UI側の表示は analyzeSentence() と同じ GrammarAnalysisResult[] 形式を返す\n * - 句読点は従来通り Unknown 扱い\n */\nexport function analyzeSentenceWithDependency(\n  sentence: string,\n  dependencyTokens: DependencyToken[]\n): GrammarAnalysisResult[] {\n  const roleByStart = mapDependencyTokensToSVOCMByStartIndex(dependencyTokens);\n  const tokenized = _tokenizeWithStartIndices(sentence);\n\n  const results: GrammarAnalysisResult[] = [];\n  for (const { token, start } of tokenized) {\n    if (/^[.,!?;:\\-—–\"'()]$/.test(token)) {\n      results.push({\n        word: token,\n        tag: 'Unknown',\n        color: '#6b7280',\n        description: getPunctuationMeaning(token),\n      });\n      continue;\n    }\n\n    const mapped = typeof start === 'number' ? roleByStart.get(start) : undefined;\n    const tag = (mapped ?? 'M') as GrammarTag;\n\n    results.push({\n      word: token,\n      tag,\n      color: getTagColor(tag),\n      description: getTagDescription(tag),\n    });\n  }\n  return results;\n}\n\n/**\n * 文法タグの統計を取得\n */\nexport function getGrammarStats(results: GrammarAnalysisResult[]): Record<GrammarTag, number> {\n  const stats: Record<string, number> = {};\n\n  results.forEach((result) => {\n    stats[result.tag] = (stats[result.tag] || 0) + 1;\n  });\n\n  return stats as Record<GrammarTag, number>;\n}\n\n/**\n * 熟語の定義\n * 句動詞・慣用表現・時間表現などを含む\n */\nexport interface PhrasalExpression {\n  words: string[];\n  meaning: string;\n  type: 'phrasal-verb' | 'idiom' | 'time-expression' | 'determiner-noun';\n}\n\nconst PHRASAL_EXPRESSIONS: PhrasalExpression[] = [\n  // 句動詞 (Phrasal Verbs) - 熟語として表示\n  { words: ['wake', 'up'], meaning: '起きる', type: 'phrasal-verb' },\n  { words: ['get', 'up'], meaning: '起床する', type: 'phrasal-verb' },\n  { words: ['brush', 'my', 'teeth'], meaning: '歯を磨く', type: 'phrasal-verb' },\n  { words: ['wash', 'my', 'face'], meaning: '顔を洗う', type: 'phrasal-verb' },\n  { words: ['have', 'breakfast'], meaning: '朝食を食べる', type: 'phrasal-verb' },\n  { words: ['go', 'to', 'school'], meaning: '学校に行く', type: 'phrasal-verb' },\n  { words: ['come', 'back'], meaning: '帰ってくる', type: 'phrasal-verb' },\n  { words: ['come', 'home'], meaning: '帰宅する', type: 'phrasal-verb' },\n  { words: ['do', 'homework'], meaning: '宿題をする', type: 'phrasal-verb' },\n  { words: ['go', 'to', 'bed'], meaning: '寝る', type: 'phrasal-verb' },\n\n  // 時間表現\n  { words: ['at', 'seven'], meaning: '7時に', type: 'time-expression' },\n  { words: ['in', 'the', 'morning'], meaning: '朝に', type: 'time-expression' },\n  { words: ['in', 'the', 'afternoon'], meaning: '午後に', type: 'time-expression' },\n  { words: ['in', 'the', 'evening'], meaning: '夕方に', type: 'time-expression' },\n  { words: ['at', 'night'], meaning: '夜に', type: 'time-expression' },\n\n  // 限定詞+名詞の慣用表現\n  { words: ['every', 'morning'], meaning: '毎朝', type: 'determiner-noun' },\n  { words: ['every', 'day'], meaning: '毎日', type: 'determiner-noun' },\n  { words: ['every', 'night'], meaning: '毎晩', type: 'determiner-noun' },\n  { words: ['every', 'week'], meaning: '毎週', type: 'determiner-noun' },\n];\n\n/**\n * 文から熟語を検出\n */\nexport function detectPhrasalExpressions(words: string[]): PhrasalExpression[] {\n  const detected: PhrasalExpression[] = [];\n  const lowerWords = words.map((w) => w.toLowerCase());\n\n  for (const expression of PHRASAL_EXPRESSIONS) {\n    const exprLower = expression.words.map((w) => w.toLowerCase());\n\n    // 連続する単語列を探す\n    for (let i = 0; i <= lowerWords.length - exprLower.length; i++) {\n      let match = true;\n      for (let j = 0; j < exprLower.length; j++) {\n        if (lowerWords[i + j] !== exprLower[j]) {\n          match = false;\n          break;\n        }\n      }\n\n      if (match) {\n        detected.push({\n          ...expression,\n          words: words.slice(i, i + exprLower.length), // 元の大文字小文字を保持\n        });\n      }\n    }\n  }\n\n  return detected;\n}\n\n/**\n * 構文パターンの定義\n */\nexport interface GrammarPattern {\n  name: string;\n  meaning: string;\n  pattern: RegExp;\n  explanation: string;\n}\n\nconst GRAMMAR_PATTERNS: GrammarPattern[] = [\n  {\n    name: 'too ~ to ...',\n    meaning: '〜すぎて...できない',\n    pattern: /\\btoo\\s+\\w+\\s+to\\s+\\w+/i,\n    explanation: '「too + 形容詞/副詞 + to + 動詞」の形で、「〜すぎて...できない」という意味',\n  },\n  {\n    name: 'so ~ that ...',\n    meaning: 'とても〜なので...',\n    pattern: /\\bso\\s+\\w+\\s+that\\b/i,\n    explanation: '「so + 形容詞/副詞 + that ~」の形で、「とても〜なので...」という意味',\n  },\n  {\n    name: 'so that ...',\n    meaning: '〜するために',\n    pattern: /\\bso\\s+that\\b/i,\n    explanation: '「so that ~」の形で、「〜するために」という目的を表す',\n  },\n  {\n    name: 'It is ~ for ... to',\n    meaning: '...が〜するのは',\n    pattern: /\\bit\\s+is\\s+\\w+\\s+for\\s+\\w+\\s+to\\b/i,\n    explanation:\n      '「It is + 形容詞 + for + 人 + to + 動詞」の形で、「(人)が〜するのは...だ」という意味',\n  },\n  {\n    name: 'It is ~ to ...',\n    meaning: '〜することは...だ',\n    pattern: /\\bit\\s+is\\s+\\w+\\s+to\\s+\\w+/i,\n    explanation: '「It is + 形容詞 + to + 動詞」の形で、「〜することは...だ」という意味',\n  },\n  {\n    name: 'It is ~ that ...',\n    meaning: '...なのは〜だ (強調)',\n    pattern: /\\bit\\s+is\\s+\\w+\\s+that\\b/i,\n    explanation: '強調構文。「It is ~ that ...」の形で、特定の部分を強調する',\n  },\n  {\n    name: 'not only ~ but also ...',\n    meaning: '〜だけでなく...も',\n    pattern: /\\bnot\\s+only\\s+.+\\s+but\\s+also\\b/i,\n    explanation: '「not only A but also B」の形で、「AだけでなくBも」という意味',\n  },\n  {\n    name: 'either ~ or ...',\n    meaning: '〜か...かどちらか',\n    pattern: /\\beither\\s+.+\\s+or\\b/i,\n    explanation: '「either A or B」の形で、「AかBかどちらか」という選択を表す',\n  },\n  {\n    name: 'neither ~ nor ...',\n    meaning: '〜も...もない',\n    pattern: /\\bneither\\s+.+\\s+nor\\b/i,\n    explanation: '「neither A nor B」の形で、「AもBもない」という否定を表す',\n  },\n  {\n    name: 'both ~ and ...',\n    meaning: '〜も...も両方',\n    pattern: /\\bboth\\s+.+\\s+and\\b/i,\n    explanation: '「both A and B」の形で、「AもBも両方」という意味',\n  },\n  {\n    name: 'as ~ as ...',\n    meaning: '...と同じくらい〜',\n    pattern: /\\bas\\s+\\w+\\s+as\\b/i,\n    explanation: '「as + 形容詞/副詞 + as ...」の形で、「...と同じくらい〜」という同等比較',\n  },\n  {\n    name: 'not as ~ as ...',\n    meaning: '...ほど〜ない',\n    pattern: /\\bnot\\s+as\\s+\\w+\\s+as\\b/i,\n    explanation: '「not as + 形容詞/副詞 + as ...」の形で、「...ほど〜ない」という意味',\n  },\n  {\n    name: 'one of the ~est',\n    meaning: '最も〜なものの1つ',\n    pattern: /\\bone\\s+of\\s+the\\s+\\w+est\\b/i,\n    explanation: '「one of the + 最上級 + 複数名詞」の形で、「最も〜なものの1つ」という意味',\n  },\n  {\n    name: 'make/let/have + 人 + 動詞',\n    meaning: '人に〜させる',\n    pattern: /\\b(make|let|have|help)\\s+\\w+\\s+\\w+/i,\n    explanation: '使役動詞の構文。「make/let/have + 人 + 動詞の原形」で「人に〜させる」',\n  },\n  {\n    name: 'be used to ~ing',\n    meaning: '〜することに慣れている',\n    pattern: /\\b(am|is|are|was|were)\\s+used\\s+to\\s+\\w+ing\\b/i,\n    explanation: '「be used to + 動名詞」の形で、「〜することに慣れている」という意味',\n  },\n  {\n    name: 'used to + 動詞',\n    meaning: '昔は〜したものだ',\n    pattern: /\\bused\\s+to\\s+\\w+/i,\n    explanation: '「used to + 動詞の原形」の形で、「昔は〜したものだ」という過去の習慣を表す',\n  },\n];\n\n/**\n * 文から構文パターンを検出\n */\nexport function detectGrammarPatterns(sentence: string): GrammarPattern[] {\n  const detected: GrammarPattern[] = [];\n\n  for (const pattern of GRAMMAR_PATTERNS) {\n    if (pattern.pattern.test(sentence)) {\n      detected.push(pattern);\n    }\n  }\n\n  return detected;\n}\n","import { useState, useEffect, useMemo, useCallback } from 'react';\nimport { ReadingPassage, Question, ReadingSegment } from '../types';\nimport type { CustomWord, CustomQuestionSet } from '../types/customQuestions';\nimport { twoWordPhrases, commonPhrases } from '../utils/phrases';\nimport {\n  speakEnglish,\n  isSpeechSynthesisSupported,\n  stopSpeaking,\n  pauseSpeaking,\n  resumeSpeaking,\n  isSpeaking,\n  isPaused,\n} from '@/features/speech/speechSynthesis';\nimport { loadAllPassagesAsReadingFormat } from '../utils/passageAdapter';\nimport { logger } from '@/utils/logger';\nimport { loadSentenceReadingPatterns, loadParagraphReadingPatterns } from '@/utils/readingTechniquesLoader';\nimport type { SentenceReadingPattern, ParagraphReadingPattern } from '@/types/readingTechniques';\nimport {\n  analyzeSentence,\n  analyzeSentenceWithDependency,\n  GrammarAnalysisResult,\n  GrammarTag,\n  detectPhrasalExpressions,\n  PhrasalExpression,\n  detectGrammarPatterns,\n  GrammarPattern,\n} from '../utils/grammarAnalyzer';\nimport type { DependencyParsedPassage } from '@/types/passage';\nimport {\n  findDependencySentenceByText,\n  loadDependencyParsedPassage,\n} from '@/utils/dependencyParseLoader';\nimport AddToCustomButton from './AddToCustomButton';\n\ntype DifficultyFilter = 'all' | '初級' | '中級' | '上級';\n\ninterface ComprehensiveReadingViewProps {\n  onSaveUnknownWords?: (words: Question[]) => void | Promise<void>;\n  customQuestionSets?: CustomQuestionSet[];\n  onAddWordToCustomSet?: (setId: string, word: CustomWord) => void;\n  onRemoveWordFromCustomSet?: (setId: string, word: CustomWord) => void;\n  onOpenCustomSetManagement?: () => void;\n}\n\ninterface WordPopup {\n  word: string;\n  meaning: string;\n  reading: string;\n  etymology: string;\n  relatedWords: string;\n  x: number;\n  y: number;\n}\n\n// 難易度を日本語に変換\nfunction _getLevelLabel(level: string): string {\n  const levelMap: Record<string, string> = {\n    beginner: '初級',\n    intermediate: '中級',\n    advanced: '上級',\n    Advanced: '上級',\n    初級: '初級',\n    中級: '中級',\n    上級: '上級',\n  };\n  return levelMap[level] || level;\n}\n\n// 文法タグから品詞を取得\nfunction _getPartOfSpeech(tag: string): string {\n  const posMap: Record<string, string> = {\n    S: '名詞',\n    V: '動詞',\n    O: '名詞',\n    C: '名詞',\n    M: '副詞',\n    Prep: '前置詞',\n    Conj: '接続詞',\n    Det: '冠詞',\n    Adj: '形容詞',\n    Adv: '副詞',\n    Unknown: '',\n  };\n  return posMap[tag] || '';\n}\n\nfunction getGrammarTagLabel(tag: string): string {\n  const labelMap: Record<string, string> = {\n    S: '主語',\n    V: '動詞',\n    O: '目的語',\n    C: '補語',\n    M: '修飾語',\n    Prep: '前置詞',\n    Conj: '接続詞',\n    Det: '限定詞',\n    Adj: '形容詞',\n    Adv: '副詞',\n    Unknown: '',\n  };\n  return labelMap[tag] || '';\n}\n\nfunction normalizeSentenceKey(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[\\s.,?!]+/g, ' ')\n    .trim();\n}\n\nfunction _getPhraseRoleLabel(expr: PhrasalExpression): string {\n  switch (expr.type) {\n    case 'phrasal-verb':\n      return '動詞句';\n    case 'time-expression':\n      return '副詞句';\n    case 'determiner-noun':\n      return '名詞句';\n    case 'idiom':\n      return '慣用句';\n    default:\n      return '';\n  }\n}\n\nfunction isPunctuationToken(word: string): boolean {\n  return /^[.,!?;:\\-—–\"'()]$/.test(word);\n}\n\ntype _RoleColor = 'subject' | 'verb' | 'other';\n\ntype SentenceComponent = 'S' | 'V' | 'O' | 'C' | 'M';\n\nfunction getComponentTextAndUnderlineClasses(component: SentenceComponent): {\n  text: string;\n  underline: string;\n} {\n  switch (component) {\n    case 'S':\n      return { text: 'text-red-600', underline: 'border-red-500' };\n    case 'V':\n      return { text: 'text-blue-600', underline: 'border-blue-500' };\n    case 'O':\n      return { text: 'text-yellow-600', underline: 'border-yellow-500' };\n    case 'C':\n      return { text: 'text-green-600', underline: 'border-green-500' };\n    case 'M':\n    default:\n      return { text: 'text-gray-400', underline: 'border-gray-300' };\n  }\n}\n\nfunction componentFromCuratedLabel(label?: string): SentenceComponent {\n  if (!label) return 'M';\n  if (label.includes('主語')) return 'S';\n  if (label.includes('動詞')) return 'V';\n  if (label.includes('目的語')) return 'O';\n  if (label.includes('補語')) return 'C';\n  return 'M';\n}\n\nfunction mapGrammarTagToComponent(tag: GrammarTag): SentenceComponent {\n  if (tag === 'S' || tag === 'V' || tag === 'O' || tag === 'C' || tag === 'M') return tag;\n  return 'M';\n}\n\ntype ReadingDebugSnapshot = {\n  context: {\n    passageId?: string;\n    passageTitle?: string;\n    sentenceIndex: number | null;\n    showMeanings: boolean;\n    readingSubTab?: string;\n    dictionarySizes?: { main: number; reading: number };\n  };\n  sentenceText: string;\n  sentenceKey: string;\n  grammarAnalysisRaw: Array<{\n    index: number;\n    word: string;\n    tag: string;\n    label: string;\n    description?: string;\n    isPunctuation: boolean;\n  }>;\n  meaningResolutionByToken: Array<{\n    word: string;\n    lemma: string;\n    lemmaTrace: {\n      normalized: string;\n      selected: string;\n      appliedRule:\n        | 'exact'\n        | '-es'\n        | '-s'\n        | '-ed'\n        | '-ed+e'\n        | '-ed+dedupe'\n        | '-ing'\n        | '-ing+e'\n        | '-ing+dedupe'\n        | '-ly'\n        | '-er'\n        | '-est'\n        | 'fallback';\n      attempts: Array<{\n        rule: string;\n        candidate: string;\n        mainHit: boolean;\n        readingHit: boolean;\n      }>;\n    };\n    isRelativePronounSpecialCase: boolean;\n    mainDictionaryHit: boolean;\n    readingDictionaryHit: boolean;\n    mainMeaning?: string;\n    readingMeaning?: string;\n    finalMeaning: string;\n    finalSource: 'specialCase' | 'mainDictionary' | 'readingDictionary' | 'none';\n  }>;\n  grammarTokens: Array<{ word: string; tag: string; label: string }>;\n  wordsNoPunct: string[];\n  detectedPhrasals: Array<{ words: string[]; type: string; meaning: string }>;\n  groupingValidation: {\n    sameSequence: boolean;\n    words: string[];\n    grouped: string[];\n    lengthWords: number;\n    lengthGrouped: number;\n    firstMismatchIndex: number | null;\n    diffs: Array<{ index: number; expected: string | null; actual: string | null }>;\n    appliedSpans: Array<{\n      kind: 'phrasal' | 'prepPhrase' | 'everyPhrase' | 'phrase';\n      startIndex: number;\n      length: number;\n      english: string;\n      words: string[];\n    }>;\n    spanOverlaps: Array<{\n      a: { kind: string; startIndex: number; length: number; english: string };\n      b: { kind: string; startIndex: number; length: number; english: string };\n      overlapRange: { start: number; end: number };\n    }>;\n  };\n  meaningAndTranslation: {\n    normalizedSentenceKey: string;\n    groups: Array<{\n      words: string[];\n      english: string;\n      meaning: string;\n      meaningSource: 'phrasalExact' | 'dictionary' | 'specialCase' | 'composedFromWords' | 'empty';\n      perWordMeanings?: Array<{ word: string; meaning: string }>;\n      dictionaryKeyTried?: string;\n      dictionaryHit?: boolean;\n      dictionarySource?: 'mainDictionary' | 'readingDictionary' | 'none';\n      dictionaryMeaning?: string;\n    }>;\n    naturalTranslation: {\n      text: string;\n      source: 'curated' | 'composedFromGroups' | 'empty';\n      canComposeFromGroups: boolean;\n    };\n  };\n  vocabularyItems: {\n    items: Array<{\n      english: string;\n      meaning: string;\n      isPhrase: boolean;\n      meaningSource: 'phrasalExact' | 'specialCase' | 'composedFromWords' | 'empty';\n      perWordMeanings?: Array<{ word: string; meaning: string }>;\n    }>;\n  };\n  grammarPatterns: Array<{ name: string; meaning: string; explanation: string }>;\n  curatedStructureApplied: boolean;\n  curatedTranslationApplied: boolean;\n};\n\nfunction buildGroupingValidationDebug(\n  filteredAnalysis: GrammarAnalysisResult[]\n): ReadingDebugSnapshot['groupingValidation'] {\n  const words = filteredAnalysis.map((a) => a.word);\n  const phrasalExpressions = detectPhrasalExpressions(words);\n  const { phrasalMap, phrasalWordIndices } = tryBuildPhrasalMap(words, phrasalExpressions);\n\n  const phraseMap = new Map<number, number>();\n  const phraseWordIndices = new Set<number>();\n\n  filteredAnalysis.forEach((analysis, idx) => {\n    if (phrasalWordIndices.has(idx)) return;\n    if (analysis.tag === 'Prep' && idx + 1 < filteredAnalysis.length) {\n      if (\n        idx + 2 < filteredAnalysis.length &&\n        filteredAnalysis[idx + 1].tag === 'Det' &&\n        !isPunctuationToken(filteredAnalysis[idx + 2].word)\n      ) {\n        phraseMap.set(idx, 3);\n        phraseWordIndices.add(idx);\n        phraseWordIndices.add(idx + 1);\n        phraseWordIndices.add(idx + 2);\n      } else {\n        phraseMap.set(idx, 2);\n        phraseWordIndices.add(idx);\n        phraseWordIndices.add(idx + 1);\n      }\n    }\n    if (\n      analysis.tag === 'Det' &&\n      analysis.word.toLowerCase() === 'every' &&\n      idx + 1 < filteredAnalysis.length\n    ) {\n      phraseMap.set(idx, 2);\n      phraseWordIndices.add(idx);\n      phraseWordIndices.add(idx + 1);\n    }\n  });\n\n  const appliedSpans: ReadingDebugSnapshot['groupingValidation']['appliedSpans'] = [];\n  Array.from(phrasalMap.entries())\n    .sort((a, b) => a[0] - b[0])\n    .forEach(([startIndex, pe]) => {\n      appliedSpans.push({\n        kind: 'phrasal',\n        startIndex,\n        length: pe.words.length,\n        english: pe.words.join(' '),\n        words: pe.words,\n      });\n    });\n\n  Array.from(phraseMap.entries())\n    .sort((a, b) => a[0] - b[0])\n    .forEach(([startIndex, length]) => {\n      const slice = filteredAnalysis.slice(startIndex, startIndex + length).map((a) => a.word);\n      const head = filteredAnalysis[startIndex];\n      const kind: ReadingDebugSnapshot['groupingValidation']['appliedSpans'][number]['kind'] =\n        head?.tag === 'Prep'\n          ? 'prepPhrase'\n          : head?.tag === 'Det' && head.word.toLowerCase() === 'every'\n            ? 'everyPhrase'\n            : 'phrase';\n      appliedSpans.push({\n        kind,\n        startIndex,\n        length,\n        english: slice.join(' '),\n        words: slice,\n      });\n    });\n\n  const spanOverlaps: ReadingDebugSnapshot['groupingValidation']['spanOverlaps'] = [];\n  const spansSorted = [...appliedSpans].sort((a, b) => a.startIndex - b.startIndex);\n  for (let i = 0; i < spansSorted.length; i++) {\n    const a = spansSorted[i];\n    const aStart = a.startIndex;\n    const aEnd = a.startIndex + a.length - 1;\n    for (let j = i + 1; j < spansSorted.length; j++) {\n      const b = spansSorted[j];\n      const bStart = b.startIndex;\n      const bEnd = b.startIndex + b.length - 1;\n      if (bStart > aEnd) break;\n      const start = Math.max(aStart, bStart);\n      const end = Math.min(aEnd, bEnd);\n      if (start <= end) {\n        spanOverlaps.push({\n          a: { kind: a.kind, startIndex: a.startIndex, length: a.length, english: a.english },\n          b: { kind: b.kind, startIndex: b.startIndex, length: b.length, english: b.english },\n          overlapRange: { start, end },\n        });\n        if (spanOverlaps.length >= 20) break;\n      }\n    }\n    if (spanOverlaps.length >= 20) break;\n  }\n\n  const flattenGroupedWords = (): string[] => {\n    const out: string[] = [];\n    for (let i = 0; i < filteredAnalysis.length; i++) {\n      if (phrasalWordIndices.has(i) && !phrasalMap.has(i)) continue;\n      if (phraseWordIndices.has(i) && !phraseMap.has(i)) continue;\n      const pe = phrasalMap.get(i);\n      if (pe) {\n        out.push(...pe.words);\n        i += pe.words.length - 1;\n        continue;\n      }\n      const span = phraseMap.get(i);\n      if (span) {\n        out.push(...filteredAnalysis.slice(i, i + span).map((a) => a.word));\n        i += span - 1;\n        continue;\n      }\n      out.push(filteredAnalysis[i].word);\n    }\n    return out;\n  };\n\n  const grouped = flattenGroupedWords();\n  const sameSequence =\n    grouped.length === words.length &&\n    grouped.every((w, i) => w.toLowerCase() === words[i]?.toLowerCase());\n\n  const maxLen = Math.max(words.length, grouped.length);\n  const diffs: Array<{ index: number; expected: string | null; actual: string | null }> = [];\n  let firstMismatchIndex: number | null = null;\n\n  for (let i = 0; i < maxLen; i++) {\n    const expected = words[i] ?? null;\n    const actual = grouped[i] ?? null;\n    const expectedLower = expected?.toLowerCase() ?? null;\n    const actualLower = actual?.toLowerCase() ?? null;\n    if (expectedLower !== actualLower) {\n      if (firstMismatchIndex === null) firstMismatchIndex = i;\n      diffs.push({ index: i, expected, actual });\n      if (diffs.length >= 20) break;\n    }\n  }\n\n  return {\n    sameSequence,\n    words,\n    grouped,\n    lengthWords: words.length,\n    lengthGrouped: grouped.length,\n    firstMismatchIndex,\n    diffs,\n    appliedSpans,\n    spanOverlaps,\n  };\n}\n\nfunction buildLemmaTrace(\n  word: string,\n  deps: {\n    wordDictionary: Map<string, Question>;\n    readingDictionary: Map<string, Record<string, string>>;\n  }\n): {\n  normalized: string;\n  selected: string;\n  appliedRule:\n    | 'exact'\n    | '-es'\n    | '-s'\n    | '-ed'\n    | '-ed+e'\n    | '-ed+dedupe'\n    | '-ing'\n    | '-ing+e'\n    | '-ing+dedupe'\n    | '-ly'\n    | '-er'\n    | '-est'\n    | 'fallback';\n  attempts: Array<{ rule: string; candidate: string; mainHit: boolean; readingHit: boolean }>;\n} {\n  const normalized = word\n    .toLowerCase()\n    .replace(/[.,!?;:\"']/g, '')\n    .trim();\n\n  const has = (candidate: string) => {\n    const mainHit = deps.wordDictionary.has(candidate);\n    const readingHit = deps.readingDictionary.has(candidate);\n    return { mainHit, readingHit, hit: mainHit || readingHit };\n  };\n\n  const attempts: Array<{\n    rule: string;\n    candidate: string;\n    mainHit: boolean;\n    readingHit: boolean;\n  }> = [];\n\n  const pushAttempt = (rule: string, candidate: string) => {\n    const h = has(candidate);\n    attempts.push({ rule, candidate, mainHit: h.mainHit, readingHit: h.readingHit });\n    return h.hit;\n  };\n\n  if (pushAttempt('exact', normalized)) {\n    return { normalized, selected: normalized, appliedRule: 'exact', attempts };\n  }\n\n  if (normalized.endsWith('es')) {\n    const base = normalized.slice(0, -2);\n    if (pushAttempt('-es', base)) {\n      return { normalized, selected: base, appliedRule: '-es', attempts };\n    }\n  }\n\n  if (normalized.endsWith('s')) {\n    const base = normalized.slice(0, -1);\n    if (pushAttempt('-s', base)) {\n      return { normalized, selected: base, appliedRule: '-s', attempts };\n    }\n  }\n\n  if (normalized.endsWith('ed')) {\n    const base = normalized.slice(0, -2);\n    if (pushAttempt('-ed', base)) {\n      return { normalized, selected: base, appliedRule: '-ed', attempts };\n    }\n    if (pushAttempt('-ed+e', base + 'e')) {\n      return { normalized, selected: base + 'e', appliedRule: '-ed+e', attempts };\n    }\n    if (base.length > 2 && base[base.length - 1] === base[base.length - 2]) {\n      const deduped = base.slice(0, -1);\n      if (pushAttempt('-ed+dedupe', deduped)) {\n        return { normalized, selected: deduped, appliedRule: '-ed+dedupe', attempts };\n      }\n    }\n  }\n\n  if (normalized.endsWith('ing')) {\n    const base = normalized.slice(0, -3);\n    if (pushAttempt('-ing', base)) {\n      return { normalized, selected: base, appliedRule: '-ing', attempts };\n    }\n    if (pushAttempt('-ing+e', base + 'e')) {\n      return { normalized, selected: base + 'e', appliedRule: '-ing+e', attempts };\n    }\n    if (base.length > 2 && base[base.length - 1] === base[base.length - 2]) {\n      const deduped = base.slice(0, -1);\n      if (pushAttempt('-ing+dedupe', deduped)) {\n        return { normalized, selected: deduped, appliedRule: '-ing+dedupe', attempts };\n      }\n    }\n  }\n\n  if (normalized.endsWith('ly')) {\n    const base = normalized.slice(0, -2);\n    if (pushAttempt('-ly', base)) {\n      return { normalized, selected: base, appliedRule: '-ly', attempts };\n    }\n  }\n\n  if (normalized.endsWith('er')) {\n    const base = normalized.slice(0, -2);\n    if (pushAttempt('-er', base)) {\n      return { normalized, selected: base, appliedRule: '-er', attempts };\n    }\n  }\n\n  if (normalized.endsWith('est')) {\n    const base = normalized.slice(0, -3);\n    if (pushAttempt('-est', base)) {\n      return { normalized, selected: base, appliedRule: '-est', attempts };\n    }\n  }\n\n  // fallback\n  pushAttempt('fallback', normalized);\n  return { normalized, selected: normalized, appliedRule: 'fallback', attempts };\n}\n\nfunction buildMeaningAndTranslationDebug(\n  sentenceText: string,\n  filteredAnalysisNoPunct: GrammarAnalysisResult[],\n  deps: {\n    getMeaning: (word: string, existingMeaning?: string | Record<string, unknown>) => string;\n    wordDictionary: Map<string, Question>;\n    readingDictionary: Map<string, Record<string, string>>;\n  }\n): ReadingDebugSnapshot['meaningAndTranslation'] {\n  const numberWordToDigit: Record<string, string> = {\n    one: '1',\n    two: '2',\n    three: '3',\n    four: '4',\n    five: '5',\n    six: '6',\n    seven: '7',\n    eight: '8',\n    nine: '9',\n    ten: '10',\n    eleven: '11',\n    twelve: '12',\n  };\n\n  const getLiteralMeaningWithSource = (groupWords: string[]) => {\n    const lower = groupWords.join(' ').toLowerCase();\n\n    const detected = detectPhrasalExpressions(groupWords);\n    const exact = detected.find(\n      (d) =>\n        d.words.length === groupWords.length &&\n        d.words.every((w, i) => w.toLowerCase() === groupWords[i]?.toLowerCase())\n    );\n    if (exact?.meaning) {\n      return {\n        meaning: exact.meaning,\n        meaningSource: 'phrasalExact' as const,\n        perWordMeanings: undefined,\n      };\n    }\n\n    if (lower === 'i') return { meaning: '私は', meaningSource: 'specialCase' as const };\n    if (lower === 'wake up') return { meaning: '起きる', meaningSource: 'specialCase' as const };\n    if (lower === 'first') return { meaning: '最初に', meaningSource: 'specialCase' as const };\n    if (lower === 'then') return { meaning: 'それから', meaningSource: 'specialCase' as const };\n    if (lower === 'finally') return { meaning: '最後に', meaningSource: 'specialCase' as const };\n\n    if (groupWords.length === 2 && groupWords[0].toLowerCase() === 'at') {\n      const w = groupWords[1].toLowerCase();\n      const digit = numberWordToDigit[w] || (w.match(/^\\d+$/) ? w : '');\n      if (digit) return { meaning: `${digit}時に`, meaningSource: 'specialCase' as const };\n    }\n\n    if (\n      groupWords.length === 2 &&\n      groupWords[0].toLowerCase() === 'every' &&\n      groupWords[1].toLowerCase() === 'morning'\n    ) {\n      return { meaning: '毎朝', meaningSource: 'specialCase' as const };\n    }\n\n    const perWordMeanings = groupWords\n      .map((w) => ({ word: w, meaning: deps.getMeaning(w, undefined) }))\n      .filter((m) => m.meaning && m.meaning !== '-');\n    const meaning = perWordMeanings.map((m) => m.meaning).join(' ');\n    return {\n      meaning,\n      meaningSource: meaning ? ('composedFromWords' as const) : ('empty' as const),\n      perWordMeanings,\n    };\n  };\n\n  const words = filteredAnalysisNoPunct.map((a) => a.word);\n  const phrasalExpressions = detectPhrasalExpressions(words);\n  const phrasalMap = new Map<number, PhrasalExpression>();\n  const phrasalWordIndices = new Set<number>();\n\n  // NOTE: UIの「直訳と日本語訳」と同じ動作（熟語候補ごとに最初の1箇所だけ採用）\n  phrasalExpressions.forEach((expr) => {\n    let startIdx = 0;\n    while (startIdx < words.length) {\n      const found = words\n        .slice(startIdx)\n        .findIndex((w, i) =>\n          expr.words.every((ew, ei) => words[startIdx + i + ei]?.toLowerCase() === ew.toLowerCase())\n        );\n      if (found !== -1) {\n        const actualIdx = startIdx + found;\n        phrasalMap.set(actualIdx, expr);\n        expr.words.forEach((_, i) => phrasalWordIndices.add(actualIdx + i));\n        break;\n      }\n      startIdx++;\n    }\n  });\n\n  const groups: ReadingDebugSnapshot['meaningAndTranslation']['groups'] = [];\n  for (let i = 0; i < filteredAnalysisNoPunct.length; i++) {\n    if (phrasalWordIndices.has(i) && !phrasalMap.has(i)) continue;\n    const phrasalExpr = phrasalMap.get(i);\n    if (phrasalExpr) {\n      const key = phrasalExpr.words.join(' ').toLowerCase();\n      const main = deps.wordDictionary.get(key);\n      const reading = deps.readingDictionary.get(key);\n      const fallback = getLiteralMeaningWithSource(phrasalExpr.words);\n      const meaning = main?.meaning || reading?.meaning || fallback.meaning;\n      groups.push({\n        words: phrasalExpr.words,\n        english: phrasalExpr.words.join(' '),\n        meaning,\n        meaningSource:\n          main?.meaning || reading?.meaning ? ('dictionary' as const) : fallback.meaningSource,\n        perWordMeanings: fallback.perWordMeanings,\n        dictionaryKeyTried: key,\n        dictionaryHit: Boolean(main?.meaning || reading?.meaning),\n        dictionarySource: main?.meaning\n          ? 'mainDictionary'\n          : reading?.meaning\n            ? 'readingDictionary'\n            : 'none',\n        dictionaryMeaning: main?.meaning || reading?.meaning,\n      });\n      i += phrasalExpr.words.length - 1;\n      continue;\n    }\n\n    const tag = filteredAnalysisNoPunct[i].tag;\n    const w0 = filteredAnalysisNoPunct[i].word.toLowerCase();\n    if (tag === 'Prep' && i + 1 < filteredAnalysisNoPunct.length) {\n      const groupWords =\n        i + 2 < filteredAnalysisNoPunct.length &&\n        filteredAnalysisNoPunct[i + 1].tag === 'Det' &&\n        !isPunctuationToken(filteredAnalysisNoPunct[i + 2].word)\n          ? [\n              filteredAnalysisNoPunct[i].word,\n              filteredAnalysisNoPunct[i + 1].word,\n              filteredAnalysisNoPunct[i + 2].word,\n            ]\n          : [filteredAnalysisNoPunct[i].word, filteredAnalysisNoPunct[i + 1].word];\n      const v = getLiteralMeaningWithSource(groupWords);\n      groups.push({\n        words: groupWords,\n        english: groupWords.join(' '),\n        meaning: v.meaning,\n        meaningSource: v.meaningSource,\n        perWordMeanings: v.perWordMeanings,\n      });\n      i += groupWords.length - 1;\n      continue;\n    }\n    if (tag === 'Det' && w0 === 'every' && i + 1 < filteredAnalysisNoPunct.length) {\n      const groupWords = [filteredAnalysisNoPunct[i].word, filteredAnalysisNoPunct[i + 1].word];\n      const v = getLiteralMeaningWithSource(groupWords);\n      groups.push({\n        words: groupWords,\n        english: groupWords.join(' '),\n        meaning: v.meaning,\n        meaningSource: v.meaningSource,\n        perWordMeanings: v.perWordMeanings,\n      });\n      i += 1;\n      continue;\n    }\n\n    const v = getLiteralMeaningWithSource([filteredAnalysisNoPunct[i].word]);\n    groups.push({\n      words: [filteredAnalysisNoPunct[i].word],\n      english: filteredAnalysisNoPunct[i].word,\n      meaning: v.meaning,\n      meaningSource: v.meaningSource,\n      perWordMeanings: v.perWordMeanings,\n    });\n  }\n\n  const normalizedSentenceKey = sentenceText ? normalizeSentenceKey(sentenceText) : '';\n  const curated = CURATED_READING_TRANSLATIONS[normalizedSentenceKey];\n  const canComposeFromGroups = groups.every((g) => g.meaning && g.meaning !== '-');\n  const composed = canComposeFromGroups ? groups.map((g) => g.meaning).join(' ') : '';\n\n  return {\n    normalizedSentenceKey,\n    groups,\n    naturalTranslation: {\n      text: curated || composed,\n      source: curated ? 'curated' : composed ? 'composedFromGroups' : 'empty',\n      canComposeFromGroups,\n    },\n  };\n}\n\nfunction buildVocabularyItemsDebug(\n  filteredAnalysisNoPunct: GrammarAnalysisResult[],\n  deps: {\n    getMeaning: (word: string, existingMeaning?: string | Record<string, unknown>) => string;\n  }\n): ReadingDebugSnapshot['vocabularyItems'] {\n  const numberWordToDigit: Record<string, string> = {\n    one: '1',\n    two: '2',\n    three: '3',\n    four: '4',\n    five: '5',\n    six: '6',\n    seven: '7',\n    eight: '8',\n    nine: '9',\n    ten: '10',\n    eleven: '11',\n    twelve: '12',\n  };\n\n  const getGroupMeaningWithSource = (groupWords: string[]) => {\n    const lower = groupWords.join(' ').toLowerCase();\n    const detected = detectPhrasalExpressions(groupWords);\n    const exact = detected.find(\n      (d) =>\n        d.words.length === groupWords.length &&\n        d.words.every((w, i) => w.toLowerCase() === groupWords[i]?.toLowerCase())\n    );\n    if (exact?.meaning) return { meaning: exact.meaning, meaningSource: 'phrasalExact' as const };\n\n    if (lower === 'i') return { meaning: '私は', meaningSource: 'specialCase' as const };\n    if (lower === 'wake up') return { meaning: '起きる', meaningSource: 'specialCase' as const };\n    if (lower === 'first') return { meaning: '最初に', meaningSource: 'specialCase' as const };\n    if (lower === 'then') return { meaning: 'それから', meaningSource: 'specialCase' as const };\n    if (lower === 'finally') return { meaning: '最後に', meaningSource: 'specialCase' as const };\n\n    if (groupWords.length === 2 && groupWords[0].toLowerCase() === 'at') {\n      const w = groupWords[1].toLowerCase();\n      const digit = numberWordToDigit[w] || (w.match(/^\\d+$/) ? w : '');\n      if (digit) return { meaning: `${digit}時に`, meaningSource: 'specialCase' as const };\n    }\n\n    if (\n      groupWords.length === 2 &&\n      groupWords[0].toLowerCase() === 'every' &&\n      groupWords[1].toLowerCase() === 'morning'\n    ) {\n      return { meaning: '毎朝', meaningSource: 'specialCase' as const };\n    }\n\n    const perWordMeanings = groupWords\n      .map((w) => ({ word: w, meaning: deps.getMeaning(w, undefined) }))\n      .filter((m) => m.meaning && m.meaning !== '-');\n    const meaning = perWordMeanings.map((m) => m.meaning).join(' ');\n    return {\n      meaning,\n      meaningSource: meaning ? ('composedFromWords' as const) : ('empty' as const),\n      perWordMeanings,\n    };\n  };\n\n  const words = filteredAnalysisNoPunct.map((a) => a.word);\n  const phrasalExpressions = detectPhrasalExpressions(words);\n  const { phrasalMap, phrasalWordIndices } = tryBuildPhrasalMap(words, phrasalExpressions);\n\n  const items: ReadingDebugSnapshot['vocabularyItems']['items'] = [];\n  for (let idx = 0; idx < filteredAnalysisNoPunct.length; idx++) {\n    const analysis = filteredAnalysisNoPunct[idx];\n    if (phrasalWordIndices.has(idx) && !phrasalMap.has(idx)) continue;\n\n    const phrasalExpr = phrasalMap.get(idx);\n    if (phrasalExpr) {\n      const v = getGroupMeaningWithSource(phrasalExpr.words);\n      items.push({\n        english: phrasalExpr.words.join(' '),\n        meaning: phrasalExpr.meaning || v.meaning,\n        isPhrase: true,\n        meaningSource: phrasalExpr.meaning ? ('phrasalExact' as const) : v.meaningSource,\n        perWordMeanings: v.perWordMeanings,\n      });\n      idx += phrasalExpr.words.length - 1;\n      continue;\n    }\n\n    if (analysis.tag === 'Prep' && idx + 1 < filteredAnalysisNoPunct.length) {\n      const groupWords =\n        idx + 2 < filteredAnalysisNoPunct.length &&\n        filteredAnalysisNoPunct[idx + 1].tag === 'Det' &&\n        !isPunctuationToken(filteredAnalysisNoPunct[idx + 2].word)\n          ? [\n              analysis.word,\n              filteredAnalysisNoPunct[idx + 1].word,\n              filteredAnalysisNoPunct[idx + 2].word,\n            ]\n          : [analysis.word, filteredAnalysisNoPunct[idx + 1].word];\n      const v = getGroupMeaningWithSource(groupWords);\n      items.push({\n        english: groupWords.join(' '),\n        meaning: v.meaning,\n        isPhrase: true,\n        meaningSource: v.meaningSource,\n        perWordMeanings: v.perWordMeanings,\n      });\n      idx += groupWords.length - 1;\n      continue;\n    }\n\n    if (\n      analysis.tag === 'Det' &&\n      analysis.word.toLowerCase() === 'every' &&\n      idx + 1 < filteredAnalysisNoPunct.length\n    ) {\n      const groupWords = [analysis.word, filteredAnalysisNoPunct[idx + 1].word];\n      const v = getGroupMeaningWithSource(groupWords);\n      items.push({\n        english: groupWords.join(' '),\n        meaning: v.meaning,\n        isPhrase: true,\n        meaningSource: v.meaningSource,\n        perWordMeanings: v.perWordMeanings,\n      });\n      idx += 1;\n      continue;\n    }\n\n    const v = getGroupMeaningWithSource([analysis.word]);\n    items.push({\n      english: analysis.word,\n      meaning: v.meaning,\n      isPhrase: false,\n      meaningSource: v.meaningSource,\n      perWordMeanings: v.perWordMeanings,\n    });\n  }\n\n  return { items };\n}\n\nfunction ReadingDebugPanel({\n  snapshot,\n  onClose,\n}: {\n  snapshot: ReadingDebugSnapshot;\n  onClose: () => void;\n}) {\n  const json = useMemo(() => JSON.stringify(snapshot, null, 2), [snapshot]);\n\n  const copy = async () => {\n    try {\n      await navigator.clipboard.writeText(json);\n      alert('デバッグJSONをコピーしました');\n    } catch {\n      // clipboard不可の環境\n      try {\n        const ta = document.createElement('textarea');\n        ta.value = json;\n        document.body.appendChild(ta);\n        ta.select();\n        document.execCommand('copy');\n        document.body.removeChild(ta);\n        alert('デバッグJSONをコピーしました');\n      } catch {\n        alert('コピーに失敗しました');\n      }\n    }\n  };\n\n  return (\n    <div className=\"mt-3 bg-white rounded-lg border border-gray-300 p-3\">\n      <div className=\"flex items-center justify-between gap-2\">\n        <div className=\"font-semibold text-sm text-gray-800\">🐛 読解デバッグ（開発用）</div>\n        <div className=\"flex gap-2\">\n          <button\n            onClick={copy}\n            className=\"px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded hover:bg-blue-200\"\n          >\n            JSONコピー\n          </button>\n          <button\n            onClick={onClose}\n            className=\"px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200\"\n          >\n            閉じる\n          </button>\n        </div>\n      </div>\n\n      <div className=\"mt-2 text-xs text-gray-700\">\n        <div>\n          <span className=\"font-semibold\">key:</span> {snapshot.sentenceKey}\n        </div>\n        <div className=\"mt-1\">\n          <span className=\"font-semibold\">sentence:</span> {snapshot.sentenceText}\n        </div>\n        <div className=\"mt-1\">\n          <span className=\"font-semibold\">passage:</span>{' '}\n          {snapshot.context.passageTitle || '(unknown)'}\n        </div>\n        {snapshot.context.dictionarySizes && (\n          <div className=\"mt-1\">\n            <span className=\"font-semibold\">dict:</span> main=\n            {snapshot.context.dictionarySizes.main}, reading=\n            {snapshot.context.dictionarySizes.reading}\n          </div>\n        )}\n      </div>\n\n      <div className=\"mt-3 grid grid-cols-1 md:grid-cols-2 gap-3\">\n        <div className=\"bg-gray-50 rounded border border-gray-200 p-2\">\n          <div className=\"font-semibold text-xs text-gray-800\">🧩 Tokens</div>\n          <div className=\"mt-2 flex flex-wrap gap-2\">\n            {snapshot.grammarTokens.map((t, idx) => (\n              <span key={idx} className=\"inline-flex flex-col items-center\">\n                <span className=\"text-sm border-b-2 border-gray-600\">{t.word}</span>\n                <span className=\"text-[10px] text-gray-700\">{t.label}</span>\n              </span>\n            ))}\n          </div>\n        </div>\n\n        <div className=\"bg-gray-50 rounded border border-gray-200 p-2\">\n          <div className=\"font-semibold text-xs text-gray-800\">🔎 熟語検出</div>\n          <div className=\"mt-2 space-y-1 text-xs text-gray-700\">\n            {snapshot.detectedPhrasals.length === 0 ? (\n              <div>（なし）</div>\n            ) : (\n              snapshot.detectedPhrasals.map((p, idx) => (\n                <div key={idx} className=\"flex gap-2\">\n                  <span className=\"font-semibold\">{p.words.join(' ')}</span>\n                  <span className=\"text-gray-500\">[{p.type}]</span>\n                  <span>→ {p.meaning}</span>\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      </div>\n\n      <div className=\"mt-3 bg-gray-50 rounded border border-gray-200 p-2\">\n        <div className=\"font-semibold text-xs text-gray-800\">🧠 意味解決（トークン）</div>\n        <div className=\"mt-2 overflow-auto\">\n          <table className=\"w-full text-[10px] text-gray-800\">\n            <thead>\n              <tr className=\"text-gray-600\">\n                <th className=\"text-left font-semibold pr-2\">word</th>\n                <th className=\"text-left font-semibold pr-2\">lemma</th>\n                <th className=\"text-left font-semibold pr-2\">rule</th>\n                <th className=\"text-left font-semibold pr-2\">hit</th>\n                <th className=\"text-left font-semibold\">meaning</th>\n              </tr>\n            </thead>\n            <tbody>\n              {snapshot.meaningResolutionByToken.map((t, idx) => (\n                <tr key={idx} className=\"border-t border-gray-200\">\n                  <td className=\"py-1 pr-2 whitespace-nowrap\">{t.word}</td>\n                  <td className=\"py-1 pr-2 whitespace-nowrap\">{t.lemma}</td>\n                  <td className=\"py-1 pr-2 whitespace-nowrap\">{t.lemmaTrace.appliedRule}</td>\n                  <td className=\"py-1 pr-2 whitespace-nowrap\">\n                    {t.finalSource}\n                    {t.mainDictionaryHit ? ' M' : ''}\n                    {t.readingDictionaryHit ? ' R' : ''}\n                  </td>\n                  <td className=\"py-1\">{t.finalMeaning || '（空）'}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n\n      <div className=\"mt-3 bg-gray-50 rounded border border-gray-200 p-2\">\n        <div className=\"font-semibold text-xs text-gray-800\">🧪 判定</div>\n        <div className=\"mt-1 text-xs text-gray-700\">\n          <div>curatedStructureApplied: {snapshot.curatedStructureApplied ? 'true' : 'false'}</div>\n          <div>\n            curatedTranslationApplied: {snapshot.curatedTranslationApplied ? 'true' : 'false'}\n          </div>\n          <div>\n            naturalTranslationSource: {snapshot.meaningAndTranslation.naturalTranslation.source}\n          </div>\n        </div>\n      </div>\n\n      <div className=\"mt-3 bg-gray-50 rounded border border-gray-200 p-2\">\n        <div className=\"font-semibold text-xs text-gray-800\">🧷 グルーピング検証</div>\n        <div className=\"mt-1 text-xs text-gray-700\">\n          <div>sameSequence: {snapshot.groupingValidation.sameSequence ? 'true' : 'false'}</div>\n          <div>\n            length: words={snapshot.groupingValidation.lengthWords}, grouped=\n            {snapshot.groupingValidation.lengthGrouped}\n          </div>\n          <div>\n            firstMismatchIndex:{' '}\n            {snapshot.groupingValidation.firstMismatchIndex === null\n              ? 'null'\n              : snapshot.groupingValidation.firstMismatchIndex}\n          </div>\n          <div>appliedSpans: {snapshot.groupingValidation.appliedSpans.length}</div>\n        </div>\n\n        {snapshot.groupingValidation.appliedSpans.length > 0 && (\n          <div className=\"mt-2 text-xs text-gray-700\">\n            <div className=\"font-semibold\">適用span（先頭10件まで）</div>\n            <div className=\"mt-1 space-y-1\">\n              {snapshot.groupingValidation.appliedSpans.slice(0, 10).map((s, idx) => (\n                <div key={idx} className=\"flex gap-2\">\n                  <span className=\"text-gray-500\">@{s.startIndex}</span>\n                  <span className=\"text-gray-500\">len={s.length}</span>\n                  <span className=\"text-gray-500\">[{s.kind}]</span>\n                  <span className=\"font-semibold\">{s.english}</span>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {snapshot.groupingValidation.spanOverlaps.length > 0 && (\n          <div className=\"mt-2 text-xs text-red-700\">\n            <div className=\"font-semibold\">⚠️ span重なり（先頭10件まで）</div>\n            <div className=\"mt-1 space-y-1\">\n              {snapshot.groupingValidation.spanOverlaps.slice(0, 10).map((o, idx) => (\n                <div key={idx} className=\"flex gap-2\">\n                  <span className=\"text-red-600\">\n                    [{o.overlapRange.start}-{o.overlapRange.end}]\n                  </span>\n                  <span className=\"text-gray-600\">A:</span>\n                  <span className=\"font-semibold\">{o.a.english}</span>\n                  <span className=\"text-gray-600\">B:</span>\n                  <span className=\"font-semibold\">{o.b.english}</span>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {!snapshot.groupingValidation.sameSequence &&\n          snapshot.groupingValidation.diffs.length > 0 && (\n            <div className=\"mt-2 text-xs text-gray-700\">\n              <div className=\"font-semibold\">diffs（先頭20件まで）</div>\n              <div className=\"mt-1 space-y-1\">\n                {snapshot.groupingValidation.diffs.map((d) => (\n                  <div key={d.index} className=\"flex gap-2\">\n                    <span className=\"text-gray-500\">#{d.index}</span>\n                    <span className=\"font-semibold\">expected:</span>\n                    <span>{d.expected ?? '(none)'}</span>\n                    <span className=\"font-semibold\">actual:</span>\n                    <span>{d.actual ?? '(none)'}</span>\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n      </div>\n\n      <div className=\"mt-3 bg-gray-50 rounded border border-gray-200 p-2\">\n        <div className=\"font-semibold text-xs text-gray-800\">📝 自然な日本語訳（採用結果）</div>\n        <div className=\"mt-1 text-xs text-gray-700\">\n          {snapshot.meaningAndTranslation.naturalTranslation.text || '（空）'}\n        </div>\n      </div>\n\n      <div className=\"mt-3 bg-gray-50 rounded border border-gray-200 p-2\">\n        <div className=\"font-semibold text-xs text-gray-800\">📐 構文パターン</div>\n        <div className=\"mt-1 text-xs text-gray-700\">\n          {snapshot.grammarPatterns.length === 0\n            ? '（なし）'\n            : snapshot.grammarPatterns.map((p) => p.name).join(', ')}\n        </div>\n      </div>\n\n      <pre\n        className=\"mt-3 bg-white rounded border border-gray-200 p-2 text-[10px] whitespace-pre-wrap break-words cursor-pointer\"\n        onClick={copy}\n        title=\"クリックでJSONコピー\"\n      >\n        {json}\n      </pre>\n    </div>\n  );\n}\n\nconst CURATED_READING_STRUCTURES: Record<\n  string,\n  Array<{ text: string; label: string; underline: 'word' | 'phrase' }>\n> = {\n  'first i brush my teeth and wash my face': [\n    { text: 'First', label: '副詞', underline: 'word' },\n    { text: 'I', label: '主語', underline: 'word' },\n    { text: 'brush my teeth', label: '動詞句', underline: 'phrase' },\n    { text: 'and', label: '接続詞', underline: 'word' },\n    { text: 'wash my face', label: '動詞句', underline: 'phrase' },\n  ],\n};\n\nconst CURATED_READING_TRANSLATIONS: Record<string, string> = {\n  'i wake up at seven every morning': '私は毎朝7時に起きます。',\n  'first i brush my teeth and wash my face': 'まず、歯を磨いて顔を洗います。',\n  'i check homework and put books inside': '私は宿題を確認して、本をかばんの中に入れます。',\n};\n\nfunction tryBuildPhrasalMap(\n  words: string[],\n  phrasals: PhrasalExpression[]\n): {\n  phrasalMap: Map<number, PhrasalExpression>;\n  phrasalWordIndices: Set<number>;\n} {\n  const phrasalMap = new Map<number, PhrasalExpression>();\n  const phrasalWordIndices = new Set<number>();\n\n  const usedStarts = new Set<number>();\n  phrasals.forEach((expr) => {\n    const span = expr.words.length;\n    if (span <= 1) return;\n\n    for (let start = 0; start <= words.length - span; start++) {\n      if (usedStarts.has(start)) continue;\n      let match = true;\n      for (let j = 0; j < span; j++) {\n        if (words[start + j]?.toLowerCase() !== expr.words[j]?.toLowerCase()) {\n          match = false;\n          break;\n        }\n      }\n      if (!match) continue;\n\n      phrasalMap.set(start, expr);\n      for (let j = 0; j < span; j++) {\n        phrasalWordIndices.add(start + j);\n      }\n      usedStarts.add(start);\n      break;\n    }\n  });\n\n  return { phrasalMap, phrasalWordIndices };\n}\n\nfunction ComprehensiveReadingView({\n  onSaveUnknownWords,\n  customQuestionSets = [],\n  onAddWordToCustomSet,\n  onRemoveWordFromCustomSet,\n  onOpenCustomSetManagement,\n}: ComprehensiveReadingViewProps) {\n  const [passages, setPassages] = useState<ReadingPassage[]>([]);\n  const [selectedPassageId, setSelectedPassageId] = useState<string | null>(null);\n  const [phraseTranslations, setPhraseTranslations] = useState<boolean[]>([]);\n  const [wordMeaningsVisible, setWordMeaningsVisible] = useState<boolean[]>([]);\n  const [difficultyFilter, setDifficultyFilter] = useState<DifficultyFilter>('all');\n  const [error, setError] = useState<string | null>(null);\n  const [wordDictionary, setWordDictionary] = useState<Map<string, Question>>(new Map());\n  const [readingDictionary, setReadingDictionary] = useState<Map<string, Record<string, string>>>(\n    new Map()\n  );\n  const [wordPopup, setWordPopup] = useState<WordPopup | null>(null);\n  const [showSettings, setShowSettings] = useState(false);\n  const [readingStarted, _setReadingStarted] = useState(true);\n  const [readingSubTab, setReadingSubTab] = useState<'reading' | 'fullText' | 'fullTranslation'>(\n    'reading'\n  );\n  const [_currentPhraseIndex, _setCurrentPhraseIndex] = useState(0);\n  const [isFullTextSpeaking, setIsFullTextSpeaking] = useState(false);\n  const [isFullTextPaused, setIsFullTextPaused] = useState(false);\n  const [selectedSentenceIndex, setSelectedSentenceIndex] = useState<number | null>(null);\n  const [selectedSentenceDetails, setSelectedSentenceDetails] = useState<{\n    text: string;\n    grammarAnalysis: GrammarAnalysisResult[];\n    showMeanings: boolean;\n  } | null>(null);\n  const [dependencyParsedPassage, setDependencyParsedPassage] = useState<DependencyParsedPassage | null>(\n    null\n  );\n  const [showReadingDebugPanel, setShowReadingDebugPanel] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [sentencePatterns, setSentencePatterns] = useState<SentenceReadingPattern[]>([]);\n  const [paragraphPatterns, setParagraphPatterns] = useState<ParagraphReadingPattern[]>([]);\n\n  // 文・段落パターンデータを初期化時に読み込み\n  useEffect(() => {\n    Promise.all([\n      loadSentenceReadingPatterns(),\n      loadParagraphReadingPatterns(),\n    ]).then(([sentenceData, paragraphData]) => {\n      if (sentenceData?.patterns) {\n        setSentencePatterns(sentenceData.patterns);\n      }\n      if (paragraphData?.patterns) {\n        setParagraphPatterns(paragraphData.patterns);\n      }\n    });\n  }, []);\n\n  useEffect(() => {\n    let cancelled = false;\n    if (!selectedPassageId) {\n      setDependencyParsedPassage(null);\n      return;\n    }\n\n    void loadDependencyParsedPassage(selectedPassageId).then((parsed) => {\n      if (cancelled) return;\n      setDependencyParsedPassage(parsed);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [selectedPassageId]);\n\n  // 分からない単語のマーク状態のみをLocalStorageに保存（軽量）\n  useEffect(() => {\n    if (passages.length > 0) {\n      const readingProgressKey = 'reading-unknown-words-state';\n      try {\n        // 軽量化: isUnknownフラグだけを保存\n        const progressData = passages.map((passage) => ({\n          id: passage.id,\n          unknownWords: passage.phrases.flatMap((phrase, pIdx) =>\n            phrase.segments\n              .map((seg, sIdx) => (seg.isUnknown ? `${pIdx}-${sIdx}` : null))\n              .filter(Boolean)\n          ),\n        }));\n        localStorage.setItem(readingProgressKey, JSON.stringify(progressData));\n      } catch (error) {\n        logger.warn('分からない単語の状態保存に失敗:', error);\n      }\n    }\n  }, [passages]);\n\n  // フレーズグループ化の型定義\n  type PhraseGroup = {\n    type: 'phrase' | 'word';\n    words: string[];\n    segments: ReadingSegment[];\n    isUnknown: boolean;\n  };\n\n  // セグメントをフレーズグループに変換する関数\n  const _groupSegmentsByPhrases = (segments: ReadingSegment[]): PhraseGroup[] => {\n    const groups: PhraseGroup[] = [];\n    let i = 0;\n\n    while (i < segments.length) {\n      // 略語パターンをチェック（A.M., P.M., Ms., Mr., Dr. など）\n      // パターン: 文字 + . + 文字 + . または 文字 + 文字 + .\n      if (i + 3 < segments.length) {\n        // A.M. または P.M. のパターン (4セグメント: a, ., m, .)\n        const seg1 = segments[i].word.toLowerCase();\n        const seg2 = segments[i + 1].word;\n        const seg3 = segments[i + 2].word.toLowerCase();\n        const seg4 = segments[i + 3].word;\n\n        if ((seg1 === 'a' || seg1 === 'p') && seg2 === '.' && seg3 === 'm' && seg4 === '.') {\n          const abbreviation = seg1 === 'a' ? 'A.M.' : 'P.M.';\n          groups.push({\n            type: 'word',\n            words: [abbreviation],\n            segments: [{ ...segments[i], word: abbreviation }],\n            isUnknown:\n              segments[i].isUnknown ||\n              segments[i + 1].isUnknown ||\n              segments[i + 2].isUnknown ||\n              segments[i + 3].isUnknown,\n          });\n          i += 4;\n          continue;\n        }\n      }\n\n      // Ms., Mr., Dr. などのパターン (3セグメント: ms/mr/dr, ., 次の単語)\n      if (i + 2 < segments.length) {\n        const seg1 = segments[i].word.toLowerCase();\n        const seg2 = segments[i + 1].word;\n        const titles = ['ms', 'mr', 'mrs', 'dr', 'prof', 'st'];\n\n        if (titles.includes(seg1) && seg2 === '.') {\n          const abbreviation = seg1.charAt(0).toUpperCase() + seg1.slice(1) + '.';\n          groups.push({\n            type: 'word',\n            words: [abbreviation],\n            segments: [{ ...segments[i], word: abbreviation }],\n            isUnknown: segments[i].isUnknown || segments[i + 1].isUnknown,\n          });\n          i += 2;\n          continue;\n        }\n      }\n\n      // 3単語フレーズをチェック\n      if (i + 2 < segments.length) {\n        const threeWords = [\n          segments[i].word.toLowerCase(),\n          segments[i + 1].word.toLowerCase(),\n          segments[i + 2].word.toLowerCase(),\n        ].join(' ');\n\n        if (commonPhrases.includes(threeWords)) {\n          groups.push({\n            type: 'phrase',\n            words: [segments[i].word, segments[i + 1].word, segments[i + 2].word],\n            segments: [segments[i], segments[i + 1], segments[i + 2]],\n            isUnknown:\n              segments[i].isUnknown || segments[i + 1].isUnknown || segments[i + 2].isUnknown,\n          });\n          i += 3;\n          continue;\n        }\n      }\n\n      // 2単語フレーズをチェック\n      if (i + 1 < segments.length) {\n        const twoWords = [segments[i].word.toLowerCase(), segments[i + 1].word.toLowerCase()].join(\n          ' '\n        );\n\n        if (twoWordPhrases.includes(twoWords)) {\n          groups.push({\n            type: 'phrase',\n            words: [segments[i].word, segments[i + 1].word],\n            segments: [segments[i], segments[i + 1]],\n            isUnknown: segments[i].isUnknown || segments[i + 1].isUnknown,\n          });\n          i += 2;\n          continue;\n        }\n      }\n\n      // 単一単語\n      groups.push({\n        type: 'word',\n        words: [segments[i].word],\n        segments: [segments[i]],\n        isUnknown: segments[i].isUnknown,\n      });\n      i += 1;\n    }\n\n    return groups;\n  };\n\n  // 単語集データの読み込み\n  useEffect(() => {\n    logger.log('[長文] 辞書の読み込みを開始...');\n    // メイン辞書（CSV）の読み込み\n    fetch('/data/vocabulary/high-school-entrance-words.csv')\n      .then((res) => {\n        if (!res.ok) {\n          throw new Error(`CSV読み込み失敗: ${res.status}`);\n        }\n        return res.text();\n      })\n      .then((csvText) => {\n        const lines = csvText.split('\\n');\n        const dictionary = new Map<string, Question>();\n\n        // ヘッダー行をスキップして処理\n        lines.slice(1).forEach((line) => {\n          if (!line.trim()) return;\n\n          // CSVをパース（簡易版）\n          const row = line.split(',').map((cell) => cell.trim());\n\n          if (row.length >= 7) {\n            const word = row[0].toLowerCase().trim();\n            dictionary.set(word, {\n              word: row[0],\n              reading: row[1],\n              meaning: row[2],\n              etymology: row[3],\n              relatedWords: row[4],\n              relatedFields: row[5],\n              difficulty: row[6],\n            });\n          }\n        });\n\n        logger.log(`[長文] メイン辞書: ${dictionary.size}単語を読み込みました`);\n        setWordDictionary(dictionary);\n      })\n      .catch((_err) => {\n        // 辞書の読み込みエラーは致命的ではないので、静かに無視\n        // 長文読解は辞書なしでも続行可能\n      });\n\n    // 長文読解専用辞書（JSON）の読み込み\n    fetch('/data/dictionaries/reading-passages-dictionary.json')\n      .then((res) => {\n        if (!res.ok) {\n          throw new Error(`JSON読み込み失敗: ${res.status}`);\n        }\n        return res.json();\n      })\n      .then((dictData: Record<string, Record<string, string>>) => {\n        const readingDict = new Map<string, Record<string, string>>();\n\n        Object.entries(dictData).forEach(([word, info]) => {\n          readingDict.set(word.toLowerCase(), info);\n        });\n\n        setReadingDictionary(readingDict);\n        logger.log(`[長文] 長文読解辞書: ${readingDict.size}単語を読み込みました`);\n      })\n      .catch((err) => {\n        logger.error('[長文] Error loading reading dictionary:', err);\n        // 長文辞書はオプショナルなのでエラー表示しない\n      });\n  }, []);\n\n  // 原形変換をメモ化（辞書が変わらない限りキャッシュ）\n  // NOTE: データ読み込みuseEffect内で使用されるため、先に定義する必要がある\n  const getLemma = useCallback(\n    (word: string): string => {\n      const normalized = word\n        .toLowerCase()\n        .replace(/[.,!?;:\"']/g, '')\n        .trim();\n\n      // まず元の形で検索（両方の辞書）\n      if (wordDictionary.has(normalized) || readingDictionary.has(normalized)) return normalized;\n\n      // -s, -es の除去（三単現、複数形）\n      if (normalized.endsWith('es')) {\n        const base = normalized.slice(0, -2);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n      }\n      if (normalized.endsWith('s')) {\n        const base = normalized.slice(0, -1);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n      }\n\n      // -ed の除去（過去形、過去分詞）\n      if (normalized.endsWith('ed')) {\n        const base = normalized.slice(0, -2);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n        if (wordDictionary.has(base + 'e') || readingDictionary.has(base + 'e')) return base + 'e';\n        if (base.length > 2 && base[base.length - 1] === base[base.length - 2]) {\n          const deduped = base.slice(0, -1);\n          if (wordDictionary.has(deduped) || readingDictionary.has(deduped)) return deduped;\n        }\n      }\n\n      // -ing の除去（現在分詞、動名詞）\n      if (normalized.endsWith('ing')) {\n        const base = normalized.slice(0, -3);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n        if (wordDictionary.has(base + 'e') || readingDictionary.has(base + 'e')) return base + 'e';\n        if (base.length > 2 && base[base.length - 1] === base[base.length - 2]) {\n          const deduped = base.slice(0, -1);\n          if (wordDictionary.has(deduped) || readingDictionary.has(deduped)) return deduped;\n        }\n      }\n\n      // -ly の除去（副詞）\n      if (normalized.endsWith('ly')) {\n        const base = normalized.slice(0, -2);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n      }\n\n      // -er, -est の除去（比較級、最上級）\n      if (normalized.endsWith('er')) {\n        const base = normalized.slice(0, -2);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n      }\n      if (normalized.endsWith('est')) {\n        const base = normalized.slice(0, -3);\n        if (wordDictionary.has(base) || readingDictionary.has(base)) return base;\n      }\n\n      return normalized;\n    },\n    [wordDictionary, readingDictionary]\n  );\n\n  // 単語の意味を辞書から取得（メモ化）\n  const getMeaning = useCallback(\n    (word: string, existingMeaning?: string | Record<string, unknown>): string => {\n      // existingMeaningがあり、'-'でない場合はそれを使用\n      if (\n        existingMeaning &&\n        typeof existingMeaning === 'string' &&\n        existingMeaning.trim() &&\n        existingMeaning !== '-'\n      ) {\n        return existingMeaning;\n      }\n\n      // existingMeaningがオブジェクトの場合、meaningプロパティを取得\n      if (\n        existingMeaning &&\n        typeof existingMeaning === 'object' &&\n        'meaning' in existingMeaning &&\n        typeof existingMeaning.meaning === 'string'\n      ) {\n        return existingMeaning.meaning;\n      }\n\n      // 関係代名詞の特別処理\n      const lowerWord = word.toLowerCase();\n      if (lowerWord === 'who') {\n        return '(関係代名詞)その人は';\n      }\n      if (lowerWord === 'whom') {\n        return '(関係代名詞)その人を';\n      }\n      if (lowerWord === 'which') {\n        return '(関係代名詞)その物等は・を';\n      }\n      if (lowerWord === 'that') {\n        return '(関係代名詞)その人・物等は・を';\n      }\n\n      // 辞書から取得\n      const lemma = getLemma(word);\n      const wordData = wordDictionary.get(lemma);\n      const readingWord = readingDictionary.get(lemma);\n\n      return wordData?.meaning || readingWord?.meaning || '';\n    },\n    [getLemma, wordDictionary, readingDictionary]\n  );\n\n  // 発音状態の監視\n  useEffect(() => {\n    const checkSpeechStatus = setInterval(() => {\n      if (isFullTextSpeaking && !isSpeaking() && !isPaused()) {\n        // 発音が終了した\n        setIsFullTextSpeaking(false);\n        setIsFullTextPaused(false);\n      }\n    }, 500); // 0.5秒ごとにチェック\n\n    return () => clearInterval(checkSpeechStatus);\n  }, [isFullTextSpeaking]);\n\n  // データ読み込み（辞書が読み込まれた後に実行）\n  useEffect(() => {\n    // 辞書がまだ読み込まれていない場合は待機\n    if (wordDictionary.size === 0) {\n      logger.log('[長文] 辞書の読み込みを待機中...');\n      return;\n    }\n\n    logger.log(`[長文] パッセージデータの読み込みを開始... (辞書: ${wordDictionary.size}単語)`);\n\n    // 古いLocalStorageデータをクリア（容量節約）\n    try {\n      localStorage.removeItem('reading-passages-data');\n    } catch {\n      // エラーは無視\n    }\n\n    // 保存済みの「分からない単語」状態を読み込む\n    const readingProgressKey = 'reading-unknown-words-state';\n    let savedProgress: Array<{ id: string; unknownWords?: string[] }> = [];\n    try {\n      const stored = localStorage.getItem(readingProgressKey);\n      if (stored) {\n        savedProgress = JSON.parse(stored);\n      }\n    } catch (e) {\n      logger.warn('[長文] 保存済み進捗の読み込みに失敗:', e);\n    }\n\n    // フレーズ学習用JSONから直接読み込む\n    setIsLoading(true);\n    loadAllPassagesAsReadingFormat(wordDictionary)\n      .then((loadedPassages) => {\n        if (loadedPassages && loadedPassages.length > 0) {\n          logger.log(`[長文] ${loadedPassages.length}件のパッセージを読み込みました`);\n\n          // 保存済みの「分からない単語」状態を復元\n          const restoredPassages = loadedPassages.map((passage) => {\n            const saved = savedProgress.find((p) => p.id === passage.id);\n            if (saved?.unknownWords && saved.unknownWords.length > 0) {\n              return {\n                ...passage,\n                phrases: passage.phrases.map((phrase, pIdx) => ({\n                  ...phrase,\n                  segments: phrase.segments.map((seg, sIdx) => ({\n                    ...seg,\n                    isUnknown: saved.unknownWords?.includes(`${pIdx}-${sIdx}`) ?? false,\n                  })),\n                })),\n              };\n            }\n            return passage;\n          });\n\n          // 難易度・語数順にソート（難易度: 初級→中級→上級、同一難易度内: 語数少ない順）\n          const levelOrder: Record<string, number> = {\n            初級: 1,\n            beginner: 1,\n            中級: 2,\n            intermediate: 2,\n            上級: 3,\n            advanced: 3,\n            Advanced: 3,\n          };\n          const sortedData = restoredPassages.sort((a, b) => {\n            const levelA = levelOrder[a.level || ''] || 999;\n            const levelB = levelOrder[b.level || ''] || 999;\n            if (levelA !== levelB) return levelA - levelB;\n\n            const wordCountA = a.actualWordCount || 0;\n            const wordCountB = b.actualWordCount || 0;\n            return wordCountA - wordCountB;\n          });\n\n          setPassages(sortedData);\n          logger.log(`[長文] パッセージを設定完了: ${sortedData.length}件`);\n          if (sortedData.length > 0) {\n            setSelectedPassageId(sortedData[0].id);\n            setPhraseTranslations(new Array(sortedData[0].phrases?.length || 0).fill(false));\n            setWordMeaningsVisible(new Array(sortedData[0].phrases?.length || 0).fill(false));\n            logger.log(`[長文] 初期パッセージを選択: ${sortedData[0].id}`);\n          }\n          setIsLoading(false);\n        } else {\n          logger.error('[長文] loadAllPassagesAsReadingFormatが空の配列を返しました');\n          setError('パッセージデータの読み込みに失敗しました（データが空です）');\n          setIsLoading(false);\n        }\n      })\n      .catch((err) => {\n        logger.error('[長文] Error loading passages:', err);\n        setError('パッセージの読み込みに失敗しました: ' + err.message);\n        setIsLoading(false);\n      });\n  }, [wordDictionary]); // 辞書が読み込まれたら再実行\n\n  // 現在のパッセージをメモ化\n  const currentPassage = useMemo(\n    () => passages.find((p) => p.id === selectedPassageId),\n    [passages, selectedPassageId]\n  );\n\n  // フィルタリングされたパッセージをメモ化\n  const filteredPassages = useMemo(() => {\n    const filtered =\n      difficultyFilter === 'all' ? passages : passages.filter((p) => p.level === difficultyFilter);\n\n    // 難易度順（初級→中級→上級）、語数順（少ない→多い）でソート\n    const levelOrder: Record<string, number> = {\n      初級: 1,\n      beginner: 1,\n      中級: 2,\n      intermediate: 2,\n      上級: 3,\n      advanced: 3,\n      Advanced: 3,\n    };\n    return filtered.sort((a, b) => {\n      // まず難易度で比較\n      const levelA = levelOrder[a.level || ''] || 999;\n      const levelB = levelOrder[b.level || ''] || 999;\n      if (levelA !== levelB) return levelA - levelB;\n\n      // 難易度が同じ場合は語数の少ない順（昇順）にする\n      const wordCountA = a.actualWordCount || 0;\n      const wordCountB = b.actualWordCount || 0;\n      return wordCountA - wordCountB;\n    });\n  }, [passages, difficultyFilter]);\n\n  // パッセージ選択（メモ化）\n  const handleSelectPassage = useCallback(\n    (passageId: string) => {\n      setSelectedPassageId(passageId);\n      const passage = passages.find((p) => p.id === passageId);\n      if (passage) {\n        setPhraseTranslations(new Array(passage.phrases?.length || 0).fill(false));\n        setWordMeaningsVisible(new Array(passage.phrases?.length || 0).fill(false));\n        _setCurrentPhraseIndex(0); // フレーズインデックスをリセット\n      }\n    },\n    [passages]\n  );\n\n  // フレーズナビゲーション\n  const _handlePreviousPhrase = () => {\n    _setCurrentPhraseIndex((prev: number) => Math.max(0, prev - 1));\n  };\n\n  const _handleNextPhrase = () => {\n    if (currentPassage && currentPassage.phrases) {\n      _setCurrentPhraseIndex((prev: number) =>\n        Math.min(currentPassage.phrases.length - 1, prev + 1)\n      );\n    }\n  };\n\n  // フレーズ全体を発音する（メモ化）\n  const _handlePhraseSpeak = useCallback(\n    (phraseIdx: number, event: React.MouseEvent) => {\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (!currentPassage || !isSpeechSynthesisSupported()) return;\n\n      const phrase = currentPassage.phrases[phraseIdx];\n      const phraseText = phrase.segments\n        .filter((seg) => seg.word && seg.word.trim() !== '')\n        .map((seg) => seg.word)\n        .join(' ');\n\n      speakEnglish(phraseText, { rate: 0.85 });\n\n      // ビジュアルフィードバック\n      const element = event.currentTarget as HTMLElement;\n      element.classList.add('speaking');\n      setTimeout(() => {\n        element.classList.remove('speaking');\n      }, 600);\n    },\n    [currentPassage]\n  );\n\n  // 単語をクリックして辞書から意味を表示\n  const _handleWordDoubleClick = (word: string, event: React.MouseEvent<HTMLElement>) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    // 発音は削除（フレーズ全体の発音のみ）\n\n    // 既存のポップアップを閉じる\n    if (wordPopup && wordPopup.word === word) {\n      setWordPopup(null);\n      return;\n    }\n\n    // 単語を正規化（小文字、記号除去）\n    const normalizedWord = word\n      .toLowerCase()\n      .replace(/[.,!?;:\"']/g, '')\n      .trim();\n\n    // 原形変換を試みる\n    const tryLemmatization = (word: string): string | null => {\n      // まず元の形で検索\n      if (wordDictionary.has(word)) return word;\n\n      // -s, -es の除去（三単現、複数形）\n      if (word.endsWith('es') && wordDictionary.has(word.slice(0, -2))) {\n        return word.slice(0, -2);\n      }\n      if (word.endsWith('s') && wordDictionary.has(word.slice(0, -1))) {\n        return word.slice(0, -1);\n      }\n\n      // -ed の除去（過去形、過去分詞）\n      if (word.endsWith('ed')) {\n        const base = word.slice(0, -2);\n        if (wordDictionary.has(base)) return base;\n        if (wordDictionary.has(base + 'e')) return base + 'e'; // loved -> love\n        if (base.length > 2 && base[base.length - 1] === base[base.length - 2]) {\n          const deduped = base.slice(0, -1);\n          if (wordDictionary.has(deduped)) return deduped; // stopped -> stop\n        }\n      }\n\n      // -ing の除去（現在分詞、動名詞）\n      if (word.endsWith('ing')) {\n        const base = word.slice(0, -3);\n        if (wordDictionary.has(base)) return base;\n        if (wordDictionary.has(base + 'e')) return base + 'e'; // making -> make\n        if (base.length > 2 && base[base.length - 1] === base[base.length - 2]) {\n          const deduped = base.slice(0, -1);\n          if (wordDictionary.has(deduped)) return deduped; // running -> run\n        }\n      }\n\n      // -ly の除去（副詞）\n      if (word.endsWith('ly') && wordDictionary.has(word.slice(0, -2))) {\n        return word.slice(0, -2);\n      }\n\n      // -er, -est の除去（比較級、最上級）\n      if (word.endsWith('er') && wordDictionary.has(word.slice(0, -2))) {\n        return word.slice(0, -2);\n      }\n      if (word.endsWith('est') && wordDictionary.has(word.slice(0, -3))) {\n        return word.slice(0, -3);\n      }\n\n      return null;\n    };\n\n    const baseForm = tryLemmatization(normalizedWord);\n    const wordInfo = baseForm ? wordDictionary.get(baseForm) : null;\n\n    if (wordInfo) {\n      const rect = event.currentTarget.getBoundingClientRect();\n      setWordPopup({\n        word: wordInfo.word,\n        meaning: wordInfo.meaning,\n        reading: wordInfo.reading,\n        etymology: wordInfo.etymology,\n        relatedWords: wordInfo.relatedWords,\n        x: rect.left + window.scrollX,\n        y: rect.bottom + window.scrollY + 5,\n      });\n    } else {\n      // 長文読解辞書もチェック\n      const readingWord = readingDictionary.get(baseForm || normalizedWord);\n      if (readingWord) {\n        const rect = event.currentTarget.getBoundingClientRect();\n        setWordPopup({\n          word: readingWord.word,\n          meaning: readingWord.meaning,\n          reading: readingWord.reading || '',\n          etymology: readingWord.etymology || '',\n          relatedWords: readingWord.relatedWords || '',\n          x: rect.left + window.scrollX,\n          y: rect.bottom + window.scrollY + 5,\n        });\n      } else {\n        // 辞書にない場合でもポップアップは表示しない\n        logger.warn(`Word not found in dictionary: ${normalizedWord}`);\n      }\n    }\n  };\n\n  // 単語を「分からない」としてマーク\n  const _handleMarkUnknown = (\n    phraseIndex: number,\n    segmentIndex: number,\n    event: React.MouseEvent\n  ) => {\n    event.preventDefault();\n    event.stopPropagation(); // ポップアップ表示を防ぐ\n    if (!currentPassage) return;\n\n    setPassages((prev) =>\n      prev.map((passage) =>\n        passage.id === currentPassage.id\n          ? {\n              ...passage,\n              phrases: passage.phrases.map((phrase, pIdx) =>\n                pIdx === phraseIndex\n                  ? {\n                      ...phrase,\n                      segments: phrase.segments.map((seg, sIdx) =>\n                        sIdx === segmentIndex ? { ...seg, isUnknown: !seg.isUnknown } : seg\n                      ),\n                    }\n                  : phrase\n              ),\n            }\n          : passage\n      )\n    );\n  };\n\n  // 個別フレーズの訳を表示（4段階トグル）\n  const _handleShowPhraseTranslation = (\n    phraseIndex: number,\n    direction: 'forward' | 'backward' = 'forward'\n  ) => {\n    // 4段階の双方向トグル\n    // 状態1: すべて非表示\n    // 状態2: 単語の意味を表示\n    // 状態3: フレーズの意味を表示\n    // 状態4: フレーズの意味を非表示（単語の意味は表示中）\n\n    const wordVisible = wordMeaningsVisible[phraseIndex];\n    const phraseVisible = phraseTranslations[phraseIndex];\n\n    if (direction === 'forward') {\n      // 順方向トグル\n      if (!wordVisible && !phraseVisible) {\n        // 状態1 → 状態2: 単語の意味を表示\n        setWordMeaningsVisible((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = true;\n          return newState;\n        });\n      } else if (wordVisible && !phraseVisible) {\n        // 状態2 → 状態3: フレーズの意味を表示\n        setPhraseTranslations((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = true;\n          return newState;\n        });\n      } else if (wordVisible && phraseVisible) {\n        // 状態3 → 状態4: フレーズの意味を非表示（単語の意味は表示のまま）\n        setPhraseTranslations((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = false;\n          return newState;\n        });\n      } else {\n        // 状態4 → 状態1: 単語の意味を非表示\n        setWordMeaningsVisible((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = false;\n          return newState;\n        });\n      }\n    } else {\n      // 逆方向トグル\n      if (!wordVisible && !phraseVisible) {\n        // 状態1 → 状態4: 単語の意味を表示（フレーズは非表示状態へ）\n        setWordMeaningsVisible((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = true;\n          return newState;\n        });\n      } else if (wordVisible && !phraseVisible) {\n        // 状態2または4 → 状態1: 単語の意味を非表示\n        setWordMeaningsVisible((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = false;\n          return newState;\n        });\n      } else if (wordVisible && phraseVisible) {\n        // 状態3 → 状態2: フレーズの意味を非表示\n        setPhraseTranslations((prev) => {\n          const newState = [...prev];\n          newState[phraseIndex] = false;\n          return newState;\n        });\n      }\n    }\n  };\n\n  // 分からない単語を保存\n  const handleSaveUnknownWords = () => {\n    if (!currentPassage) return;\n\n    const unknownWords: Question[] = [];\n    currentPassage.phrases.forEach((phrase) => {\n      phrase.segments.forEach((segment) => {\n        if (segment.isUnknown && segment.word.trim() !== '') {\n          // 重複を避ける\n          if (!unknownWords.some((w) => w.word.toLowerCase() === segment.word.toLowerCase())) {\n            unknownWords.push({\n              word: segment.word,\n              meaning: segment.meaning,\n              reading: segment.reading || '',\n              etymology: segment.etymology || '',\n              relatedWords: segment.relatedWords || '',\n              relatedFields: segment.relatedFields || '',\n              difficulty: segment.difficulty || 'intermediate',\n            });\n          }\n        }\n      });\n    });\n\n    if (unknownWords.length === 0) {\n      alert('分からない単語が選択されていません。\\n単語をタップしてマークしてください。');\n      return;\n    }\n\n    if (onSaveUnknownWords) {\n      onSaveUnknownWords(unknownWords);\n    }\n\n    // 保存後、マークをクリア\n    setPassages((prev) =>\n      prev.map((passage) =>\n        passage.id === currentPassage.id\n          ? {\n              ...passage,\n              phrases: passage.phrases.map((phrase) => ({\n                ...phrase,\n                segments: phrase.segments.map((seg) => ({ ...seg, isUnknown: false })),\n              })),\n            }\n          : passage\n      )\n    );\n\n    alert(`${unknownWords.length}個の単語を「${currentPassage.title}」から保存しました！`);\n  };\n\n  // リセット\n  const handleReset = () => {\n    if (!currentPassage) return;\n\n    setPassages((prev) =>\n      prev.map((passage) =>\n        passage.id === currentPassage.id\n          ? {\n              ...passage,\n              phrases: passage.phrases.map((phrase) => ({\n                ...phrase,\n                segments: phrase.segments.map((seg) => ({ ...seg, isUnknown: false })),\n              })),\n            }\n          : passage\n      )\n    );\n    setPhraseTranslations(new Array(currentPassage.phrases.length).fill(false));\n    setWordMeaningsVisible(new Array(currentPassage.phrases.length).fill(false));\n  };\n\n  if (error) {\n    return <div className=\"error-message\">{error}</div>;\n  }\n\n  if (isLoading) {\n    return <div className=\"empty-container\">読み込み中...</div>;\n  }\n\n  if (passages.length === 0) {\n    return <div className=\"empty-container\">パッセージが見つかりません</div>;\n  }\n\n  // フィルターされた結果が空の場合\n  if (filteredPassages.length === 0) {\n    return (\n      <div className=\"comprehensive-reading-view\">\n        <div className=\"reading-header\">\n          <div className=\"filter-controls\">\n            <label htmlFor=\"difficulty-filter\">難易度: </label>\n            <select\n              id=\"difficulty-filter\"\n              value={difficultyFilter}\n              onChange={(e) => setDifficultyFilter(e.target.value as DifficultyFilter)}\n              title=\"難易度を選択\"\n            >\n              <option value=\"all\">全て</option>\n              <option value=\"初級\">初級</option>\n              <option value=\"中級\">中級</option>\n              <option value=\"上級\">上級</option>\n            </select>\n          </div>\n        </div>\n        <div className=\"empty-container\">\n          選択した難易度のパッセージが見つかりません。別の難易度を選択してください。\n        </div>\n      </div>\n    );\n  }\n\n  const unknownCount =\n    currentPassage?.phrases?.reduce(\n      (count, phrase) => count + phrase.segments.filter((s) => s.isUnknown).length,\n      0\n    ) || 0;\n\n  return (\n    <div className=\"comprehensive-reading-view\">\n      {/* 学習設定パネル - 読解開始前のみ表示 */}\n      {!readingStarted && showSettings && (\n        <div className=\"study-settings-panel\">\n          <div className=\"settings-header\">\n            <h3>📊 学習設定</h3>\n            <button\n              onClick={() => setShowSettings(false)}\n              className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors duration-200 text-sm shadow-sm:bg-gray-600\"\n            >\n              ✕ 閉じる\n            </button>\n          </div>\n\n          <div className=\"filter-group\">\n            <label htmlFor=\"difficulty-filter\">⭐ 難易度:</label>\n            <select\n              id=\"difficulty-filter\"\n              value={difficultyFilter}\n              onChange={(e) => setDifficultyFilter(e.target.value as DifficultyFilter)}\n              className=\"select-input\"\n            >\n              <option value=\"all\">全て</option>\n              <option value=\"初級\">初級</option>\n              <option value=\"中級\">中級</option>\n              <option value=\"上級\">上級</option>\n            </select>\n          </div>\n\n          <div className=\"filter-group\">\n            <label htmlFor=\"passage-select\">📖 パッセージ:</label>\n            <select\n              id=\"passage-select\"\n              value={selectedPassageId || ''}\n              onChange={(e) => handleSelectPassage(e.target.value)}\n              className=\"select-input\"\n            >\n              {filteredPassages.map((passage) => (\n                <option key={passage.id} value={passage.id}>\n                  {_getLevelLabel(passage.level || 'beginner')}_{passage.actualWordCount}語_\n                  {passage.title}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n      )}\n\n      {/* 6タブ構造（読解開始後に表示） */}\n      {readingStarted && (\n        <div className=\"reading-sub-tabs grid grid-cols-6 gap-1 sm:gap-2\">\n          <button\n            className={`px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-base font-medium transition-all duration-200 rounded-t-lg border-b-2 ${\n              readingSubTab === 'reading'\n                ? 'bg-primary text-white border-primary'\n                : 'bg-gray-200 text-gray-700 border-transparent hover:bg-gray-300'\n            }`}\n            onClick={() => setReadingSubTab('reading')}\n          >\n            📖 読解\n          </button>\n          <button\n            className={`px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-base font-medium transition-all duration-200 rounded-t-lg border-b-2 ${\n              readingSubTab === 'fullText'\n                ? 'bg-primary text-white border-primary'\n                : 'bg-gray-200 text-gray-700 border-transparent hover:bg-gray-300'\n            }`}\n            onClick={() => setReadingSubTab('fullText')}\n          >\n            📄 全文\n          </button>\n          <button\n            className={`px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-base font-medium transition-all duration-200 rounded-t-lg border-b-2 ${\n              readingSubTab === 'fullTranslation'\n                ? 'bg-primary text-white border-primary'\n                : 'bg-gray-200 text-gray-700 border-transparent hover:bg-gray-300'\n            }`}\n            onClick={() => setReadingSubTab('fullTranslation')}\n          >\n            📝 全訳\n          </button>\n          <button\n            onClick={handleSaveUnknownWords}\n            className=\"px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-base font-medium bg-success text-white rounded-t-lg border-b-2 border-success transition-all duration-200 hover:bg-success-hover disabled:opacity-50 disabled:cursor-not-allowed:bg-success-hover\"\n            disabled={unknownCount === 0}\n            title=\"未知語を保存\"\n          >\n            💾 保存 ({unknownCount})\n          </button>\n          <button\n            onClick={handleReset}\n            className=\"px-4 py-2 text-sm font-medium bg-warning text-warning-dark border-2 border-warning rounded-lg transition-all duration-200 hover:bg-warning-hover hover:shadow-md:bg-warning-hover\"\n            title=\"リセット\"\n          >\n            🔄 リセット\n          </button>\n          <button\n            className=\"px-4 py-2 text-sm font-medium bg-gray-200 text-gray-700 border-2 border-transparent rounded-lg transition-all duration-200 hover:bg-gray-300:bg-gray-600\"\n            onClick={() => setShowSettings(!showSettings)}\n            title=\"学習設定を開く\"\n          >\n            ⚙️ 学習設定\n          </button>\n        </div>\n      )}\n\n      {/* 学習設定パネル - 6タブの下に表示 */}\n      {readingStarted && showSettings && (\n        <div className=\"study-settings-panel\">\n          <div className=\"settings-header\">\n            <h3>📊 学習設定</h3>\n            <button\n              onClick={() => setShowSettings(false)}\n              className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors duration-200 text-sm shadow-sm:bg-gray-600\"\n            >\n              ✕ 閉じる\n            </button>\n          </div>\n\n          <div className=\"filter-group\">\n            <label htmlFor=\"difficulty-filter-reading\">⭐ 難易度:</label>\n            <select\n              id=\"difficulty-filter-reading\"\n              value={difficultyFilter}\n              onChange={(e) => setDifficultyFilter(e.target.value as DifficultyFilter)}\n              className=\"select-input\"\n            >\n              <option value=\"all\">全て</option>\n              <option value=\"初級\">初級</option>\n              <option value=\"中級\">中級</option>\n              <option value=\"上級\">上級</option>\n            </select>\n          </div>\n\n          <div className=\"filter-group\">\n            <label htmlFor=\"passage-select-reading\">📖 パッセージ:</label>\n            <select\n              id=\"passage-select-reading\"\n              value={selectedPassageId || ''}\n              onChange={(e) => handleSelectPassage(e.target.value)}\n              className=\"select-input\"\n            >\n              {filteredPassages.map((passage) => (\n                <option key={passage.id} value={passage.id}>\n                  {_getLevelLabel(passage.level || 'beginner')}_{passage.actualWordCount}語_\n                  {passage.title}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n      )}\n\n      {/* 単語ポップアップ */}\n      {wordPopup && (\n        <>\n          <div className=\"word-popup-overlay\" onClick={() => setWordPopup(null)} />\n          <div className=\"word-popup\" data-popup-x={wordPopup.x} data-popup-y={wordPopup.y}>\n            <button className=\"popup-close\" onClick={() => setWordPopup(null)} title=\"閉じる\">\n              ✕\n            </button>\n            <div className=\"popup-word\">{wordPopup.word}</div>\n            {wordPopup.reading && <div className=\"popup-reading\">{wordPopup.reading}</div>}\n            <div className=\"popup-meaning\">{wordPopup.meaning}</div>\n            {wordPopup.etymology && (\n              <div className=\"popup-etymology\">\n                <strong>語源:</strong> {wordPopup.etymology}\n              </div>\n            )}\n            {wordPopup.relatedWords && (\n              <div className=\"popup-related\">\n                <strong>関連語:</strong> {wordPopup.relatedWords}\n              </div>\n            )}\n          </div>\n        </>\n      )}\n\n      {/* パッセージ本文 */}\n      {readingStarted &&\n        currentPassage &&\n        currentPassage.phrases &&\n        currentPassage.phrases.length > 0 && (\n          <div className=\"passage-content\">\n            <h3 className=\"passage-title\">{currentPassage.title}</h3>\n\n            {/* 読解タブ: 全文表示 + 選択文の読解エリア */}\n            {readingSubTab === 'reading' && (\n              <>\n                {/* 全文表示エリア */}\n                <div className=\"reading-full-text-area\">\n                  <h4 className=\"text-lg font-semibold mb-3\">📖 全文</h4>\n                  <div className=\"full-text-content\">\n                    {(() => {\n                      // originalTextが存在する場合はそれを使用\n                      if (currentPassage.originalText) {\n                        // 文に分割\n                        const sentences = currentPassage.originalText\n                          .split(/([.!?])\\s+/)\n                          .filter((s) => s.trim());\n                        const reconstructedSentences: string[] = [];\n                        for (let i = 0; i < sentences.length; i += 2) {\n                          const sentence = sentences[i];\n                          const punctuation = sentences[i + 1] || '';\n                          reconstructedSentences.push((sentence + punctuation).trim());\n                        }\n\n                        return (\n                          <div className=\"sentences-container\">\n                            {reconstructedSentences.map((sentence, idx) => (\n                              <span\n                                key={idx}\n                                className={`sentence-clickable ${selectedSentenceIndex === idx ? 'selected-reading' : ''}`}\n                                onClick={() => {\n                                  setSelectedSentenceIndex(idx);\n                                  const depSentence = dependencyParsedPassage\n                                    ? findDependencySentenceByText(dependencyParsedPassage, sentence)\n                                    : null;\n                                  const grammarAnalysis = depSentence\n                                    ? analyzeSentenceWithDependency(sentence, depSentence.tokens)\n                                    : analyzeSentence(sentence);\n                                  setSelectedSentenceDetails({\n                                    text: sentence,\n                                    grammarAnalysis,\n                                    showMeanings: false,\n                                  });\n                                }}\n                              >\n                                {sentence}{' '}\n                              </span>\n                            ))}\n                          </div>\n                        );\n                      }\n\n                      // originalTextがない場合、フレーズから文章を構築\n                      const isConversation = currentPassage.title\n                        .toLowerCase()\n                        .includes('conversation');\n\n                      if (isConversation) {\n                        // 会話形式: フレーズ単位で処理\n                        const lines: string[] = [];\n\n                        currentPassage.phrases.forEach((phrase) => {\n                          let lineText = phrase.segments\n                            .map((s) => s.word)\n                            .join(' ')\n                            .trim();\n                          if (!lineText || lineText === '-') return;\n                          lineText = lineText.replace(/\\s+([.,!?;:\"])/g, '$1');\n                          lines.push(lineText);\n                        });\n\n                        return (\n                          <div className=\"sentences-container\">\n                            {lines.map((line, idx) => (\n                              <span\n                                key={idx}\n                                className={`sentence-clickable ${selectedSentenceIndex === idx ? 'selected-reading' : ''}`}\n                                onClick={() => {\n                                  setSelectedSentenceIndex(idx);\n                                  const depSentence = dependencyParsedPassage\n                                    ? findDependencySentenceByText(dependencyParsedPassage, line)\n                                    : null;\n                                  const grammarAnalysis = depSentence\n                                    ? analyzeSentenceWithDependency(line, depSentence.tokens)\n                                    : analyzeSentence(line);\n                                  setSelectedSentenceDetails({\n                                    text: line,\n                                    grammarAnalysis,\n                                    showMeanings: false,\n                                  });\n                                }}\n                              >\n                                {line}{' '}\n                              </span>\n                            ))}\n                          </div>\n                        );\n                      } else {\n                        // 通常の長文形式\n                        let fullText = '';\n                        let lastWasPeriod = true;\n\n                        currentPassage.phrases.forEach((phrase) => {\n                          phrase.segments.forEach((seg) => {\n                            let word = seg.word.trim();\n                            if (word && word !== '-') {\n                              if (/^[.,!?;:]$/.test(word)) {\n                                fullText += word;\n                                lastWasPeriod = /^[.!?]$/.test(word);\n                              } else if (word === '\"' || word === \"'\") {\n                                fullText += word;\n                              } else {\n                                if (lastWasPeriod && word.length > 0) {\n                                  word = word.charAt(0).toUpperCase() + word.slice(1);\n                                  lastWasPeriod = false;\n                                }\n                                if (\n                                  fullText.length > 0 &&\n                                  !fullText.endsWith(' ') &&\n                                  !fullText.endsWith('\"') &&\n                                  !fullText.endsWith(\"'\")\n                                ) {\n                                  fullText += ' ';\n                                }\n                                fullText += word;\n                              }\n                            }\n                          });\n                        });\n\n                        fullText = fullText.replace(/\\s+\"/g, '\"').replace(/\\s+'/g, \"'\");\n\n                        const sentences = fullText.split(/([.!?])\\s+/).filter((s) => s.trim());\n                        const reconstructedSentences: string[] = [];\n                        for (let i = 0; i < sentences.length; i += 2) {\n                          const sentence = sentences[i];\n                          const punctuation = sentences[i + 1] || '';\n                          reconstructedSentences.push((sentence + punctuation).trim());\n                        }\n\n                        return (\n                          <div className=\"sentences-container\">\n                            {reconstructedSentences.map((sentence, idx) => (\n                              <span\n                                key={idx}\n                                className={`sentence-clickable ${selectedSentenceIndex === idx ? 'selected-reading' : ''}`}\n                                onClick={() => {\n                                  setSelectedSentenceIndex(idx);\n                                  const depSentence = dependencyParsedPassage\n                                    ? findDependencySentenceByText(dependencyParsedPassage, sentence)\n                                    : null;\n                                  const grammarAnalysis = depSentence\n                                    ? analyzeSentenceWithDependency(sentence, depSentence.tokens)\n                                    : analyzeSentence(sentence);\n                                  setSelectedSentenceDetails({\n                                    text: sentence,\n                                    grammarAnalysis,\n                                    showMeanings: false,\n                                  });\n                                }}\n                              >\n                                {sentence}{' '}\n                              </span>\n                            ))}\n                          </div>\n                        );\n                      }\n                    })()}\n                  </div>\n                </div>\n\n                {/* 選択された文の読解エリア */}\n                {selectedSentenceIndex !== null && selectedSentenceDetails && (\n                  <div className=\"selected-sentence-analysis mt-4 p-4 bg-blue-50 rounded-lg border border-blue-200\">\n                    <div className=\"flex justify-between items-center mb-2\">\n                      <h4 className=\"m-0 text-base font-semibold text-blue-700\">📜 文の読解</h4>\n                      <div className=\"flex gap-1\">\n                        <button\n                          className=\"px-2 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700\"\n                          onClick={() => speakEnglish(selectedSentenceDetails.text)}\n                          title=\"発音\"\n                        >\n                          🔊\n                        </button>\n                        {import.meta.env.DEV && (\n                          <button\n                            className=\"px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700\"\n                            onClick={() => setShowReadingDebugPanel((v) => !v)}\n                            title=\"読解デバッグ\"\n                          >\n                            🐛\n                          </button>\n                        )}\n                        <button\n                          className=\"px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700\"\n                          onClick={() =>\n                            setSelectedSentenceDetails({\n                              ...selectedSentenceDetails,\n                              showMeanings: !selectedSentenceDetails.showMeanings,\n                            })\n                          }\n                        >\n                          {selectedSentenceDetails.showMeanings ? '意味を隠す' : '意味を表示'}\n                        </button>\n                      </div>\n                    </div>\n\n                    {/* 文法構造の表示 */}\n                    <div className=\"grammar-structure mb-2\">\n                      <h5 className=\"text-xs font-semibold mb-1 text-gray-700\">🔤 文法構造</h5>\n\n                      <div className=\"flex flex-wrap gap-1.5 text-sm\">\n                        {(() => {\n                          const sentenceKey = normalizeSentenceKey(selectedSentenceDetails.text);\n                          const curated = CURATED_READING_STRUCTURES[sentenceKey];\n                          if (curated) {\n                            return curated.map((u, idx) => (\n                              <div key={idx} className=\"inline-flex flex-col items-center\">\n                                {(() => {\n                                  const component = componentFromCuratedLabel(u.label);\n                                  const c = getComponentTextAndUnderlineClasses(component);\n                                  return (\n                                    <>\n                                      <span\n                                        className={`font-medium text-base text-gray-900 border-b-2 ${c.underline}`}\n                                      >\n                                        {u.text}\n                                      </span>\n                                      <span\n                                        className={`text-xs font-semibold mt-0.5 ${c.text}`}\n                                        title={u.label}\n                                      >\n                                        {component}\n                                      </span>\n                                    </>\n                                  );\n                                })()}\n                              </div>\n                            ));\n                          }\n\n                          const tokens = selectedSentenceDetails.grammarAnalysis;\n                          const hasPeriod = tokens.some((a) => a.word === '.');\n                          const filtered = tokens.filter((a) => !isPunctuationToken(a.word));\n\n                          // S/V/O/C/M へ必ずマッピングする（表示用）\n                          const components: SentenceComponent[] = filtered.map((a) =>\n                            mapGrammarTagToComponent(a.tag)\n                          );\n\n                          // and/or が同種成分をつなぐときは、接続詞自体も同じ成分に吸着させて下線を連結する\n                          for (let i = 1; i + 1 < filtered.length; i++) {\n                            if (filtered[i].tag !== 'Conj') continue;\n                            const prev = components[i - 1];\n                            const next = components[i + 1];\n                            if (prev === next) components[i] = prev;\n                          }\n\n                          // Det/Adj をS/O/C に吸着させる（最低限の名詞句サポート）\n                          const firstS = filtered.findIndex((a) => a.tag === 'S');\n                          if (firstS > 0) {\n                            for (let j = firstS - 1; j >= 0; j--) {\n                              const t = filtered[j].tag;\n                              if (t === 'Det' || t === 'Adj') components[j] = 'S';\n                              else break;\n                            }\n                          }\n                          const firstV = filtered.findIndex((a) => a.tag === 'V');\n                          if (firstV >= 0) {\n                            const firstOC = filtered.findIndex(\n                              (a, idx) => idx > firstV && (a.tag === 'O' || a.tag === 'C')\n                            );\n                            if (firstOC > firstV + 1) {\n                              const target: SentenceComponent =\n                                filtered[firstOC].tag === 'C' ? 'C' : 'O';\n                              for (let j = firstOC - 1; j > firstV; j--) {\n                                const t = filtered[j].tag;\n                                if (t === 'Det' || t === 'Adj') components[j] = target;\n                                else break;\n                              }\n                            }\n                          }\n\n                          // 連続する同一成分を2語以上で結合（下線連結のため）\n                          const result: JSX.Element[] = [];\n                          for (let i = 0; i < filtered.length; i++) {\n                            const comp = components[i];\n                            const start = i;\n                            const words: string[] = [filtered[i].word];\n\n                            while (i + 1 < filtered.length && components[i + 1] === comp) {\n                              words.push(filtered[i + 1].word);\n                              i++;\n                            }\n\n                            const c = getComponentTextAndUnderlineClasses(comp);\n                            const display = words.join(' ');\n\n                            result.push(\n                              <div\n                                key={`${start}-${i}-${comp}`}\n                                className=\"inline-flex flex-col items-center\"\n                                title={\n                                  comp === 'S'\n                                    ? '主語'\n                                    : comp === 'V'\n                                      ? '動詞'\n                                      : comp === 'O'\n                                        ? '目的語'\n                                        : comp === 'C'\n                                          ? '補語'\n                                          : '修飾語'\n                                }\n                              >\n                                <span\n                                  className={`font-medium text-base text-gray-900 border-b-2 ${c.underline}`}\n                                >\n                                  {display}\n                                </span>\n                                <span className={`text-xs font-semibold mt-0.5 ${c.text}`}>\n                                  {comp}\n                                </span>\n                              </div>\n                            );\n                          }\n\n                          if (hasPeriod) {\n                            const c = getComponentTextAndUnderlineClasses('M');\n                            result.push(\n                              <div\n                                key=\"__period__\"\n                                className=\"inline-flex flex-col items-center\"\n                                title=\"ピリオド\"\n                              >\n                                <span\n                                  className={`font-medium text-base text-gray-900 border-b-2 ${c.underline}`}\n                                >\n                                  .\n                                </span>\n                                <span className={`text-xs font-semibold mt-0.5 ${c.text}`}>\n                                  &nbsp;\n                                </span>\n                              </div>\n                            );\n                          }\n\n                          return result;\n                        })()}\n                      </div>\n\n                      {/* 記号は非表示（冗長なため） */}\n                    </div>\n\n                    {/* 直訳と日本語訳（意味を表示のときのみ） */}\n                    {selectedSentenceDetails.showMeanings &&\n                      (() => {\n                        const filteredAnalysis = selectedSentenceDetails.grammarAnalysis.filter(\n                          (a) => !/^[.,!?;:\\-—–\"'()]$/.test(a.word)\n                        );\n\n                        const numberWordToDigit: Record<string, string> = {\n                          one: '1',\n                          two: '2',\n                          three: '3',\n                          four: '4',\n                          five: '5',\n                          six: '6',\n                          seven: '7',\n                          eight: '8',\n                          nine: '9',\n                          ten: '10',\n                          eleven: '11',\n                          twelve: '12',\n                        };\n\n                        const getLiteralMeaning = (groupWords: string[]): string => {\n                          const lower = groupWords.join(' ').toLowerCase();\n                          // 熟語/句動詞などの定義がある場合は、それを最優先\n                          const detected = detectPhrasalExpressions(groupWords);\n                          const exact = detected.find(\n                            (d) =>\n                              d.words.length === groupWords.length &&\n                              d.words.every(\n                                (w, i) => w.toLowerCase() === groupWords[i]?.toLowerCase()\n                              )\n                          );\n                          if (exact?.meaning) return exact.meaning;\n\n                          if (lower === 'i') return '私は';\n                          if (lower === 'wake up') return '起きる';\n                          if (lower === 'first') return '最初に';\n                          if (lower === 'then') return 'それから';\n                          if (lower === 'finally') return '最後に';\n\n                          if (groupWords.length === 2 && groupWords[0].toLowerCase() === 'at') {\n                            const w = groupWords[1].toLowerCase();\n                            const digit = numberWordToDigit[w] || (w.match(/^\\d+$/) ? w : '');\n                            if (digit) return `${digit}時に`;\n                          }\n\n                          if (\n                            groupWords.length === 2 &&\n                            groupWords[0].toLowerCase() === 'every' &&\n                            groupWords[1].toLowerCase() === 'morning'\n                          ) {\n                            return '毎朝';\n                          }\n\n                          return groupWords\n                            .map((w) => getMeaning(w, undefined))\n                            .filter((m) => m && m !== '-')\n                            .join(' ');\n                        };\n\n                        // グループ化（熟語 / 句 / 単語）\n                        const words = filteredAnalysis.map((a) => a.word);\n                        const phrasalExpressions = detectPhrasalExpressions(words);\n                        const phrasalMap = new Map<number, PhrasalExpression>();\n                        const phrasalWordIndices = new Set<number>();\n\n                        phrasalExpressions.forEach((expr) => {\n                          let startIdx = 0;\n                          while (startIdx < words.length) {\n                            const found = words\n                              .slice(startIdx)\n                              .findIndex((w, i) =>\n                                expr.words.every(\n                                  (ew, ei) =>\n                                    words[startIdx + i + ei]?.toLowerCase() === ew.toLowerCase()\n                                )\n                              );\n                            if (found !== -1) {\n                              const actualIdx = startIdx + found;\n                              phrasalMap.set(actualIdx, expr);\n                              expr.words.forEach((_, i) => phrasalWordIndices.add(actualIdx + i));\n                              break;\n                            }\n                            startIdx++;\n                          }\n                        });\n\n                        const groups: { words: string[]; meaning: string }[] = [];\n                        for (let i = 0; i < filteredAnalysis.length; i++) {\n                          if (phrasalWordIndices.has(i) && !phrasalMap.has(i)) continue;\n                          const phrasalExpr = phrasalMap.get(i);\n                          if (phrasalExpr) {\n                            groups.push({\n                              words: phrasalExpr.words,\n                              meaning:\n                                wordDictionary.get(phrasalExpr.words.join(' ').toLowerCase())\n                                  ?.meaning || getLiteralMeaning(phrasalExpr.words),\n                            });\n                            i += phrasalExpr.words.length - 1;\n                            continue;\n                          }\n\n                          const tag = filteredAnalysis[i].tag;\n                          const w0 = filteredAnalysis[i].word.toLowerCase();\n                          if (tag === 'Prep' && i + 1 < filteredAnalysis.length) {\n                            const groupWords =\n                              i + 2 < filteredAnalysis.length &&\n                              filteredAnalysis[i + 1].tag === 'Det' &&\n                              !isPunctuationToken(filteredAnalysis[i + 2].word)\n                                ? [\n                                    filteredAnalysis[i].word,\n                                    filteredAnalysis[i + 1].word,\n                                    filteredAnalysis[i + 2].word,\n                                  ]\n                                : [filteredAnalysis[i].word, filteredAnalysis[i + 1].word];\n                            groups.push({\n                              words: groupWords,\n                              meaning: getLiteralMeaning(groupWords),\n                            });\n                            i += groupWords.length - 1;\n                            continue;\n                          }\n                          if (tag === 'Det' && w0 === 'every' && i + 1 < filteredAnalysis.length) {\n                            const groupWords = [\n                              filteredAnalysis[i].word,\n                              filteredAnalysis[i + 1].word,\n                            ];\n                            groups.push({\n                              words: groupWords,\n                              meaning: getLiteralMeaning(groupWords),\n                            });\n                            i += 1;\n                            continue;\n                          }\n\n                          groups.push({\n                            words: [filteredAnalysis[i].word],\n                            meaning: getLiteralMeaning([filteredAnalysis[i].word]),\n                          });\n                        }\n\n                        const normalized = selectedSentenceDetails.text\n                          ? normalizeSentenceKey(selectedSentenceDetails.text)\n                          : '';\n\n                        const sentenceTranslationMap: Record<string, string> = {\n                          ...CURATED_READING_TRANSLATIONS,\n                        };\n\n                        const naturalLine =\n                          sentenceTranslationMap[normalized] ||\n                          // フォールバック（誤訳リスクを下げるため、熟語訳が揃っている場合のみ組み立て）\n                          (groups.every((g) => g.meaning && g.meaning !== '-')\n                            ? groups.map((g) => g.meaning).join(' ')\n                            : '');\n\n                        const translationQualityNote =\n                          '訳の品質: 直訳は語順対応を優先して意味の骨格を掴めるようにし、日本語訳は英語のニュアンス（自然な流れ・含意）をできるだけ正確に保った自然な日本語を優先しています。';\n\n                        return (\n                          <div className=\"mt-2\">\n                            <h5 className=\"text-xs font-semibold mb-1 text-gray-700\">\n                              📝 直訳と日本語訳\n                            </h5>\n                            <div className=\"flex items-start gap-2\">\n                              <span\n                                data-testid=\"literal-translation-badge\"\n                                className=\"inline-flex items-center rounded bg-gray-200 text-gray-800 px-2 py-0.5 text-[10px] font-semibold whitespace-nowrap\"\n                              >\n                                直訳\n                              </span>\n                              <div className=\"flex flex-wrap gap-2 text-sm text-gray-800\">\n                                {groups.map((g, idx) => (\n                                  <div key={idx} className=\"inline-flex flex-col items-center\">\n                                    <span className=\"font-medium border-b-2 border-gray-600\">\n                                      {g.words.join(' ')}\n                                    </span>\n                                    {g.meaning && g.meaning !== '-' && (\n                                      <span className=\"text-xs text-gray-700 mt-0.5\">\n                                        {g.meaning}\n                                      </span>\n                                    )}\n                                  </div>\n                                ))}\n                              </div>\n                            </div>\n\n                            <div className=\"mt-2 flex items-start gap-2\">\n                              <span\n                                data-testid=\"japanese-translation-badge\"\n                                className=\"inline-flex items-center rounded bg-gray-200 text-gray-800 px-2 py-0.5 text-[10px] font-semibold whitespace-nowrap\"\n                              >\n                                日本語訳\n                              </span>\n                              <div className=\"text-sm text-gray-800\">{naturalLine}</div>\n                            </div>\n\n                            <div className=\"mt-2 text-xs text-gray-600\">\n                              {translationQualityNote}\n                            </div>\n                          </div>\n                        );\n                      })()}\n\n                    {/* 単語と熟語の意味（意味を表示のときのみ） */}\n                    {selectedSentenceDetails.showMeanings &&\n                      (() => {\n                        const filteredAnalysis = selectedSentenceDetails.grammarAnalysis.filter(\n                          (a) => !isPunctuationToken(a.word)\n                        );\n\n                        const words = filteredAnalysis.map((a) => a.word);\n                        const phrasalExpressions = detectPhrasalExpressions(words);\n                        const { phrasalMap, phrasalWordIndices } = tryBuildPhrasalMap(\n                          words,\n                          phrasalExpressions\n                        );\n\n                        const numberWordToDigit: Record<string, string> = {\n                          one: '1',\n                          two: '2',\n                          three: '3',\n                          four: '4',\n                          five: '5',\n                          six: '6',\n                          seven: '7',\n                          eight: '8',\n                          nine: '9',\n                          ten: '10',\n                          eleven: '11',\n                          twelve: '12',\n                        };\n\n                        const getGroupMeaning = (groupWords: string[]): string => {\n                          const lower = groupWords.join(' ').toLowerCase();\n                          // 熟語/句動詞などの定義がある場合は、それを最優先\n                          const detected = detectPhrasalExpressions(groupWords);\n                          const exact = detected.find(\n                            (d) =>\n                              d.words.length === groupWords.length &&\n                              d.words.every(\n                                (w, i) => w.toLowerCase() === groupWords[i]?.toLowerCase()\n                              )\n                          );\n                          if (exact?.meaning) return exact.meaning;\n\n                          if (lower === 'i') return '私は';\n                          if (lower === 'wake up') return '起きる';\n                          if (lower === 'first') return '最初に';\n                          if (lower === 'then') return 'それから';\n                          if (lower === 'finally') return '最後に';\n                          if (groupWords.length === 2 && groupWords[0].toLowerCase() === 'at') {\n                            const w = groupWords[1].toLowerCase();\n                            const digit = numberWordToDigit[w] || (w.match(/^\\d+$/) ? w : '');\n                            if (digit) return `${digit}時に`;\n                          }\n                          if (\n                            groupWords.length === 2 &&\n                            groupWords[0].toLowerCase() === 'every' &&\n                            groupWords[1].toLowerCase() === 'morning'\n                          ) {\n                            return '毎朝';\n                          }\n                          return groupWords\n                            .map((w) => getMeaning(w, undefined))\n                            .filter((m) => m && m !== '-')\n                            .join(' ');\n                        };\n\n                        const items: Array<{\n                          english: string;\n                          meaning: string;\n                          isPhrase: boolean;\n                        }> = [];\n\n                        for (let idx = 0; idx < filteredAnalysis.length; idx++) {\n                          const analysis = filteredAnalysis[idx];\n\n                          // 熟語の一部ならスキップ\n                          if (phrasalWordIndices.has(idx) && !phrasalMap.has(idx)) {\n                            continue;\n                          }\n\n                          // 熟語の開始位置かチェック\n                          const phrasalExpr = phrasalMap.get(idx);\n\n                          if (phrasalExpr) {\n                            const dictMeaning =\n                              phrasalExpr.meaning || getGroupMeaning(phrasalExpr.words);\n\n                            items.push({\n                              english: phrasalExpr.words.join(' '),\n                              meaning: dictMeaning,\n                              isPhrase: true,\n                            });\n\n                            idx += phrasalExpr.words.length - 1;\n                            continue;\n                          }\n\n                          // 句のまとまり（最小対応）\n                          if (analysis.tag === 'Prep' && idx + 1 < filteredAnalysis.length) {\n                            const groupWords =\n                              idx + 2 < filteredAnalysis.length &&\n                              filteredAnalysis[idx + 1].tag === 'Det' &&\n                              !isPunctuationToken(filteredAnalysis[idx + 2].word)\n                                ? [\n                                    analysis.word,\n                                    filteredAnalysis[idx + 1].word,\n                                    filteredAnalysis[idx + 2].word,\n                                  ]\n                                : [analysis.word, filteredAnalysis[idx + 1].word];\n                            items.push({\n                              english: groupWords.join(' '),\n                              meaning: getGroupMeaning(groupWords),\n                              isPhrase: true,\n                            });\n                            idx += groupWords.length - 1;\n                            continue;\n                          }\n\n                          if (\n                            analysis.tag === 'Det' &&\n                            analysis.word.toLowerCase() === 'every' &&\n                            idx + 1 < filteredAnalysis.length\n                          ) {\n                            const groupWords = [analysis.word, filteredAnalysis[idx + 1].word];\n                            items.push({\n                              english: groupWords.join(' '),\n                              meaning: getGroupMeaning(groupWords),\n                              isPhrase: true,\n                            });\n                            idx += 1;\n                            continue;\n                          }\n\n                          // 通常の単語\n                          const meaning = getGroupMeaning([analysis.word]);\n                          items.push({ english: analysis.word, meaning, isPhrase: false });\n                        }\n\n                        const simpleItems = items.map((i, idx) => (\n                          <span\n                            key={idx}\n                            className=\"inline-flex items-baseline gap-2 whitespace-nowrap\"\n                          >\n                            {onAddWordToCustomSet &&\n                            onRemoveWordFromCustomSet &&\n                            onOpenCustomSetManagement ? (\n                              <AddToCustomButton\n                                word={{\n                                  word: i.english,\n                                  meaning: i.meaning,\n                                  source: 'reading',\n                                  sourceDetail: currentPassage?.title,\n                                }}\n                                sets={customQuestionSets}\n                                onAddWord={onAddWordToCustomSet}\n                                onRemoveWord={onRemoveWordFromCustomSet}\n                                onOpenManagement={onOpenCustomSetManagement}\n                                size=\"small\"\n                                variant=\"icon\"\n                              />\n                            ) : (\n                              <span\n                                className=\"inline-flex items-center justify-center w-7 h-7 bg-blue-500 text-white rounded-md text-base leading-none\"\n                                aria-hidden=\"true\"\n                                title=\"カスタムセット機能が未接続です\"\n                              >\n                                +\n                              </span>\n                            )}\n                            <span className=\"font-medium text-gray-900\">{i.english}</span>\n                            <span className=\"text-gray-800\">{i.meaning}</span>\n                          </span>\n                        ));\n\n                        return (\n                          <div className=\"mt-2\">\n                            <h5 className=\"text-xs font-semibold mb-1 text-gray-700\">\n                              📚 単語と熟語\n                            </h5>\n                            <div className=\"flex flex-wrap gap-x-3 gap-y-1 text-sm\">\n                              {simpleItems}\n                            </div>\n                          </div>\n                        );\n                      })()}\n\n                    {/* 構文パターン */}\n                    {(() => {\n                      const patterns = detectGrammarPatterns(selectedSentenceDetails.text);\n\n                      if (patterns.length === 0) return null;\n\n                      return (\n                        <div className=\"mt-2\">\n                          <h5 className=\"text-xs font-semibold mb-1 text-gray-700\">📐 重要構文</h5>\n                          <div className=\"space-y-1\">\n                            {patterns.map((pattern: GrammarPattern, idx: number) => (\n                              <div\n                                key={idx}\n                                className=\"bg-green-50 p-2 rounded border border-green-200\"\n                              >\n                                <div className=\"flex items-center justify-between text-sm\">\n                                  <span className=\"font-semibold text-green-700\">\n                                    {pattern.name}\n                                  </span>\n                                  <span className=\"text-xs text-gray-600\">{pattern.meaning}</span>\n                                </div>\n                                <div className=\"text-xs text-gray-600 mt-1\">\n                                  💡 {pattern.explanation}\n                                </div>\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      );\n                    })()}\n\n                    {/* 読解のヒント（文パターン） */}\n                    {(() => {\n                      if (sentencePatterns.length === 0) return null;\n\n                      const text = selectedSentenceDetails.text.toLowerCase();\n\n                      // キーワードベースで関連パターンを検出（最大2つまで）\n                      const keywords: Record<string, string[]> = {\n                        'but|however|although|though|yet|nevertheless': ['S1', 'S4', 'S5', 'S18', 'S81'],\n                        'because|since|as|so that': ['S8', 'S19', 'S83'],\n                        'if|unless|provided|as long as': ['S10', 'S96', 'S99'],\n                        'which|who|whom|that.*?who|that.*?which': ['S11', 'S12', 'S13'],\n                        'not only.*?but also|both.*?and': ['S16', 'S95'],\n                        'compare|than|more.*?than|less.*?than': ['S17', 'S73', 'S74', 'S90'],\n                        'it is|it was.*?that': ['S71'],\n                        'never|rarely|seldom|hardly': ['S72'],\n                        'to be|in order to|so that': ['S76', 'S83'],\n                        'may|might|could|would|should': ['S82', 'S89', 'S91', 'S99'],\n                        'while|whereas|on the other hand': ['S18', 'S84'],\n                        'for example|such as|like': ['S91'],\n                        'overall|in short|in sum': ['S80'],\n                        'far from|by no means': ['S95', 'S98'],\n                      };\n\n                      const matched: SentenceReadingPattern[] = [];\n                      for (const [pattern, ids] of Object.entries(keywords)) {\n                        if (new RegExp(pattern, 'i').test(text)) {\n                          for (const id of ids) {\n                            const p = sentencePatterns.find((sp) => sp.id === id);\n                            if (p && !matched.some((m) => m.id === p.id)) {\n                              matched.push(p);\n                              if (matched.length >= 2) break;\n                            }\n                          }\n                        }\n                        if (matched.length >= 2) break;\n                      }\n\n                      if (matched.length === 0) return null;\n\n                      return (\n                        <div className=\"mt-2\">\n                          <h5 className=\"text-xs font-semibold mb-1 text-gray-700\">💡 読解のヒント</h5>\n                          <div className=\"space-y-2\">\n                            {matched.map((pattern) => (\n                              <div\n                                key={pattern.id}\n                                className=\"bg-yellow-50 p-2 rounded border border-yellow-200\"\n                              >\n                                <div className=\"text-sm font-semibold text-yellow-800 mb-1\">\n                                  {pattern.title}\n                                </div>\n                                <div className=\"text-xs text-gray-700 mb-1\">\n                                  {pattern.gist}\n                                </div>\n                                {pattern.steps.length > 0 && (\n                                  <div className=\"text-xs text-gray-600\">\n                                    <div className=\"font-semibold mb-0.5\">手順:</div>\n                                    <ul className=\"list-disc list-inside space-y-0.5\">\n                                      {pattern.steps.map((step, idx) => (\n                                        <li key={idx}>{step}</li>\n                                      ))}\n                                    </ul>\n                                  </div>\n                                )}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      );\n                    })()}\n\n                    {/* 段落構造のヒント */}\n                    {(() => {\n                      if (paragraphPatterns.length === 0) return null;\n\n                      const text = selectedSentenceDetails.text.toLowerCase();\n                      const isFirstSentence = selectedSentenceIndex === 0;\n\n                      // 段落の役割を示すキーワードで検出（最大1つ）\n                      const paragraphKeywords: Record<string, string[]> = {\n                        '^(first|to begin|firstly|initially)': ['P1', 'P2'],\n                        '(however|but|yet|nevertheless|on the other hand)': ['P3', 'P10', 'P11', 'P71'],\n                        '(for example|for instance|such as)': ['P4', 'P70'],\n                        '(therefore|thus|consequently|as a result|in conclusion)': ['P5', 'P50', 'P51'],\n                        '(moreover|furthermore|in addition|additionally)': ['P6', 'P75'],\n                        '(in contrast|while|whereas)': ['P7', 'P8'],\n                        '(because|since|due to|owing to)': ['P9'],\n                        '(although|though|even though|despite)': ['P10'],\n                        '(first.*second.*third|firstly.*secondly)': ['P15'],\n                        '(overall|in short|in sum|to sum up)': ['P16', 'P17', 'P79'],\n                        '(the main point|the key|most important)': ['P18', 'P73'],\n                        '(this suggests|this means|this indicates)': ['P19', 'P84'],\n                        '(some argue|critics say|opponents claim)': ['P71'],\n                        '(one way|another approach|a solution)': ['P20'],\n                      };\n\n                      const matched: ParagraphReadingPattern[] = [];\n\n                      // 導入文の場合\n                      if (isFirstSentence && !matched.length) {\n                        const p = paragraphPatterns.find((pp) => pp.id === 'P1');\n                        if (p) matched.push(p);\n                      }\n\n                      // キーワードマッチ\n                      if (!matched.length) {\n                        for (const [pattern, ids] of Object.entries(paragraphKeywords)) {\n                          if (new RegExp(pattern, 'i').test(text)) {\n                            for (const id of ids) {\n                              const p = paragraphPatterns.find((pp) => pp.id === id);\n                              if (p && !matched.some((m) => m.id === p.id)) {\n                                matched.push(p);\n                                break;\n                              }\n                            }\n                            if (matched.length >= 1) break;\n                          }\n                        }\n                      }\n\n                      if (matched.length === 0) return null;\n\n                      return (\n                        <div className=\"mt-2\">\n                          <h5 className=\"text-xs font-semibold mb-1 text-gray-700\">📚 段落構造のヒント</h5>\n                          <div className=\"space-y-2\">\n                            {matched.map((pattern) => (\n                              <div\n                                key={pattern.id}\n                                className=\"bg-blue-50 p-2 rounded border border-blue-200\"\n                              >\n                                <div className=\"text-sm font-semibold text-blue-800 mb-1\">\n                                  {pattern.title}\n                                </div>\n                                <div className=\"text-xs text-gray-700 mb-1\">\n                                  {pattern.gist}\n                                </div>\n                                {pattern.steps.length > 0 && (\n                                  <div className=\"text-xs text-gray-600\">\n                                    <div className=\"font-semibold mb-0.5\">手順:</div>\n                                    <ul className=\"list-disc list-inside space-y-0.5\">\n                                      {pattern.steps.map((step, idx) => (\n                                        <li key={idx}>{step}</li>\n                                      ))}\n                                    </ul>\n                                  </div>\n                                )}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      );\n                    })()}\n\n                    {import.meta.env.DEV &&\n                      showReadingDebugPanel &&\n                      (() => {\n                        const sentenceKey = normalizeSentenceKey(selectedSentenceDetails.text);\n                        const raw = selectedSentenceDetails.grammarAnalysis;\n                        const rawDebug = raw.map((a, index) => ({\n                          index,\n                          word: a.word,\n                          tag: a.tag,\n                          label: getGrammarTagLabel(a.tag),\n                          description: a.description,\n                          isPunctuation: isPunctuationToken(a.word),\n                        }));\n                        const filtered = selectedSentenceDetails.grammarAnalysis.filter(\n                          (a) => !isPunctuationToken(a.word)\n                        );\n                        const wordsNoPunct = filtered.map((a) => a.word);\n                        const phrasals = detectPhrasalExpressions(wordsNoPunct);\n                        const groupingValidation = buildGroupingValidationDebug(filtered);\n                        const meaningAndTranslation = buildMeaningAndTranslationDebug(\n                          selectedSentenceDetails.text,\n                          filtered,\n                          { getMeaning, wordDictionary, readingDictionary }\n                        );\n                        const vocabularyItems = buildVocabularyItemsDebug(filtered, { getMeaning });\n                        const patterns = detectGrammarPatterns(selectedSentenceDetails.text);\n                        const curatedStructureApplied = Boolean(\n                          CURATED_READING_STRUCTURES[sentenceKey]\n                        );\n                        const curatedTranslationApplied = Boolean(\n                          CURATED_READING_TRANSLATIONS[sentenceKey]\n                        );\n\n                        const meaningResolutionByToken = filtered.map((a) => {\n                          const lower = a.word.toLowerCase();\n                          const isRel =\n                            lower === 'who' ||\n                            lower === 'whom' ||\n                            lower === 'which' ||\n                            lower === 'that';\n\n                          const lemmaTrace = buildLemmaTrace(a.word, {\n                            wordDictionary,\n                            readingDictionary,\n                          });\n\n                          if (lower === 'who') {\n                            return {\n                              word: a.word,\n                              lemma: lemmaTrace.selected,\n                              lemmaTrace,\n                              isRelativePronounSpecialCase: true,\n                              mainDictionaryHit: false,\n                              readingDictionaryHit: false,\n                              mainMeaning: undefined,\n                              readingMeaning: undefined,\n                              finalMeaning: '(関係代名詞)その人は',\n                              finalSource: 'specialCase' as const,\n                            };\n                          }\n                          if (lower === 'whom') {\n                            return {\n                              word: a.word,\n                              lemma: lemmaTrace.selected,\n                              lemmaTrace,\n                              isRelativePronounSpecialCase: true,\n                              mainDictionaryHit: false,\n                              readingDictionaryHit: false,\n                              mainMeaning: undefined,\n                              readingMeaning: undefined,\n                              finalMeaning: '(関係代名詞)その人を',\n                              finalSource: 'specialCase' as const,\n                            };\n                          }\n                          if (lower === 'which') {\n                            return {\n                              word: a.word,\n                              lemma: lemmaTrace.selected,\n                              lemmaTrace,\n                              isRelativePronounSpecialCase: true,\n                              mainDictionaryHit: false,\n                              readingDictionaryHit: false,\n                              mainMeaning: undefined,\n                              readingMeaning: undefined,\n                              finalMeaning: '(関係代名詞)その物等は・を',\n                              finalSource: 'specialCase' as const,\n                            };\n                          }\n                          if (lower === 'that') {\n                            return {\n                              word: a.word,\n                              lemma: lemmaTrace.selected,\n                              lemmaTrace,\n                              isRelativePronounSpecialCase: true,\n                              mainDictionaryHit: false,\n                              readingDictionaryHit: false,\n                              mainMeaning: undefined,\n                              readingMeaning: undefined,\n                              finalMeaning: '(関係代名詞)その人・物等は・を',\n                              finalSource: 'specialCase' as const,\n                            };\n                          }\n\n                          const lemma = lemmaTrace.selected;\n                          const main = wordDictionary.get(lemma)?.meaning;\n                          const reading = readingDictionary.get(lemma)?.meaning;\n                          const finalMeaning = getMeaning(a.word, undefined) || '';\n                          const finalSource = main\n                            ? ('mainDictionary' as const)\n                            : reading\n                              ? ('readingDictionary' as const)\n                              : isRel\n                                ? ('specialCase' as const)\n                                : finalMeaning\n                                  ? ('none' as const)\n                                  : ('none' as const);\n\n                          return {\n                            word: a.word,\n                            lemma,\n                            lemmaTrace,\n                            isRelativePronounSpecialCase: isRel,\n                            mainDictionaryHit: Boolean(main),\n                            readingDictionaryHit: Boolean(reading),\n                            mainMeaning: main,\n                            readingMeaning: reading,\n                            finalMeaning,\n                            finalSource,\n                          };\n                        });\n\n                        const snapshot: ReadingDebugSnapshot = {\n                          context: {\n                            passageId: (currentPassage as any)?.id,\n                            passageTitle: currentPassage?.title,\n                            sentenceIndex: selectedSentenceIndex,\n                            showMeanings: selectedSentenceDetails.showMeanings,\n                            readingSubTab: (readingSubTab as any) ?? undefined,\n                            dictionarySizes: {\n                              main: wordDictionary.size,\n                              reading: readingDictionary.size,\n                            },\n                          },\n                          sentenceText: selectedSentenceDetails.text,\n                          sentenceKey,\n                          grammarAnalysisRaw: rawDebug,\n                          meaningResolutionByToken,\n                          grammarTokens: filtered.map((a) => ({\n                            word: a.word,\n                            tag: a.tag,\n                            label: getGrammarTagLabel(a.tag),\n                          })),\n                          wordsNoPunct,\n                          detectedPhrasals: phrasals.map((p) => ({\n                            words: p.words,\n                            type: p.type,\n                            meaning: p.meaning,\n                          })),\n                          groupingValidation,\n                          meaningAndTranslation,\n                          vocabularyItems,\n                          grammarPatterns: patterns.map((p) => ({\n                            name: p.name,\n                            meaning: p.meaning,\n                            explanation: p.explanation,\n                          })),\n                          curatedStructureApplied,\n                          curatedTranslationApplied,\n                        };\n\n                        return (\n                          <ReadingDebugPanel\n                            snapshot={snapshot}\n                            onClose={() => setShowReadingDebugPanel(false)}\n                          />\n                        );\n                      })()}\n                  </div>\n                )}\n              </>\n            )}\n\n            {/* 全文タブ: 英文のみを段落形式で表示 */}\n            {readingSubTab === 'fullText' && (\n              <div className=\"full-text-display\">\n                <h3>📄 全文</h3>\n                <div className=\"full-text-controls\">\n                  <button\n                    className=\"px-6 py-3 text-base font-medium bg-primary text-white border-2 border-primary rounded-lg transition-all duration-200 hover:bg-primary-hover hover:shadow-md disabled:opacity-50 disabled:cursor-not-allowed:bg-primary-hover\"\n                    onClick={() => {\n                      // 話者部分（Student 1:, Mom:, etc.）と引用符を除外して発音\n                      const fullText = currentPassage.phrases\n                        .map((phrase) => {\n                          const text = phrase.segments.map((s) => s.word).join(' ');\n                          // 話者パターンを削除（Student 1:, Mom:, Teacher:, etc.）\n                          return text.replace(/^[A-Z][a-z]*(?:\\s+\\d+)?:\\s*/, '').replace(/\"/g, ''); // 引用符を削除\n                        })\n                        .join(' ')\n                        .replace(/\\s+([.,!?;:])/g, '$1');\n\n                      speakEnglish(fullText);\n                      setIsFullTextSpeaking(true);\n                      setIsFullTextPaused(false);\n                    }}\n                    disabled={isFullTextSpeaking && !isFullTextPaused}\n                    title=\"全文を発音\"\n                  >\n                    🔊 発音\n                  </button>\n                  <button\n                    className=\"px-6 py-3 text-base font-medium bg-warning text-warning-dark border-2 border-warning rounded-lg transition-all duration-200 hover:bg-warning-hover hover:shadow-md disabled:opacity-50 disabled:cursor-not-allowed:bg-warning-hover\"\n                    onClick={() => {\n                      if (isFullTextPaused) {\n                        resumeSpeaking();\n                        setIsFullTextPaused(false);\n                      } else {\n                        pauseSpeaking();\n                        setIsFullTextPaused(true);\n                      }\n                    }}\n                    disabled={!isFullTextSpeaking}\n                    title={isFullTextPaused ? '発音を再開' : '発音を一時停止'}\n                  >\n                    {isFullTextPaused ? '▶️ 再開' : '⏸️ 一時停止'}\n                  </button>\n                  <button\n                    className=\"px-6 py-3 text-base font-medium bg-error text-white border-2 border-error rounded-lg transition-all duration-200 hover:bg-error-hover hover:shadow-md disabled:opacity-50 disabled:cursor-not-allowed:bg-error-hover\"\n                    onClick={() => {\n                      stopSpeaking();\n                      setIsFullTextSpeaking(false);\n                      setIsFullTextPaused(false);\n                    }}\n                    disabled={!isFullTextSpeaking}\n                    title=\"発音を停止\"\n                  >\n                    ⏹️ 停止\n                  </button>\n                </div>\n                <div className=\"full-text-content\">\n                  {(() => {\n                    // originalTextが存在する場合はそれを使用\n                    if (currentPassage.originalText) {\n                      return <div className=\"paragraph-en\">{currentPassage.originalText}</div>;\n                    }\n\n                    // パッセージのタイトルで判別: \"Daily Conversation\"を含む場合は会話形式として処理\n                    const isConversation = currentPassage.title\n                      .toLowerCase()\n                      .includes('conversation');\n\n                    if (isConversation) {\n                      // 会話形式: フレーズ単位で処理（各フレーズが話者の発言単位）\n                      const lines: string[] = [];\n\n                      currentPassage.phrases.forEach((phrase) => {\n                        let lineText = phrase.segments\n                          .map((s) => s.word)\n                          .join(' ')\n                          .trim();\n                        if (!lineText || lineText === '-') return;\n                        lineText = lineText.replace(/\\s+([.,!?;:\"])/g, '$1');\n                        lines.push(lineText);\n                      });\n\n                      return (\n                        <div>\n                          {lines.map((line, idx) => (\n                            <p key={idx} className=\"paragraph-en conversation-line\">\n                              {line}\n                            </p>\n                          ))}\n                        </div>\n                      );\n                    } else {\n                      // 通常の長文形式: フレーズから文章を構築\n                      // 最初のフレーズが見出しかチェック（句読点で終わらない短いフレーズ）\n                      const firstPhrase = currentPassage.phrases[0];\n                      const firstPhraseText = firstPhrase.segments\n                        .map((s) => s.word)\n                        .join(' ')\n                        .trim();\n                      const isFirstPhraseTitle =\n                        firstPhraseText.length < 100 && !/[.!?]$/.test(firstPhraseText);\n\n                      let fullText = '';\n                      let lastWasPeriod = true;\n\n                      currentPassage.phrases.forEach((phrase, phraseIdx) => {\n                        // 見出しの場合はスキップ（後で独立して表示）\n                        if (phraseIdx === 0 && isFirstPhraseTitle) {\n                          return;\n                        }\n\n                        phrase.segments.forEach((seg) => {\n                          let word = seg.word.trim();\n                          if (word && word !== '-') {\n                            if (/^[.,!?;:]$/.test(word)) {\n                              fullText += word;\n                              lastWasPeriod = /^[.!?]$/.test(word);\n                            } else if (word === '\"' || word === \"'\") {\n                              // 引用符はスペースなしで追加\n                              fullText += word;\n                            } else {\n                              if (lastWasPeriod && word.length > 0) {\n                                word = word.charAt(0).toUpperCase() + word.slice(1);\n                                lastWasPeriod = false;\n                              }\n                              // 引用符の後ろにはスペースを入れない\n                              if (\n                                fullText.length > 0 &&\n                                !fullText.endsWith(' ') &&\n                                !fullText.endsWith('\"') &&\n                                !fullText.endsWith(\"'\")\n                              ) {\n                                fullText += ' ';\n                              }\n                              fullText += word;\n                            }\n                          }\n                        });\n                      });\n\n                      // 引用符の前のスペースを削除\n                      fullText = fullText.replace(/\\s+\"/g, '\"').replace(/\\s+'/g, \"'\");\n\n                      // 文を分割\n                      const sentences = fullText.split(/([.!?])\\s+/).filter((s) => s.trim());\n                      const reconstructedSentences: string[] = [];\n                      for (let i = 0; i < sentences.length; i += 2) {\n                        const sentence = sentences[i];\n                        const punctuation = sentences[i + 1] || '';\n                        reconstructedSentences.push((sentence + punctuation).trim());\n                      }\n\n                      // 語数ベースで段落分け\n                      const paragraphs: string[] = [];\n                      let currentParagraph: string[] = [];\n                      let wordCount = 0;\n                      const targetWordsPerParagraph = 60;\n\n                      reconstructedSentences.forEach((sentence, idx) => {\n                        const sentenceWordCount = sentence.split(/\\s+/).length;\n                        currentParagraph.push(sentence);\n                        wordCount += sentenceWordCount;\n\n                        if (\n                          wordCount >= targetWordsPerParagraph ||\n                          idx === reconstructedSentences.length - 1\n                        ) {\n                          paragraphs.push(currentParagraph.join(' '));\n                          currentParagraph = [];\n                          wordCount = 0;\n                        }\n                      });\n\n                      if (currentParagraph.length > 0) {\n                        paragraphs.push(currentParagraph.join(' '));\n                      }\n\n                      // 文ごとにクリック可能にする\n                      const allSentences = reconstructedSentences;\n\n                      // 文をクリックしたときの処理\n                      const handleSentenceClick = (idx: number) => {\n                        setSelectedSentenceIndex(idx);\n                        const sentence = allSentences[idx];\n                        const depSentence = dependencyParsedPassage\n                          ? findDependencySentenceByText(dependencyParsedPassage, sentence)\n                          : null;\n                        const grammarAnalysis = depSentence\n                          ? analyzeSentenceWithDependency(sentence, depSentence.tokens)\n                          : analyzeSentence(sentence);\n                        setSelectedSentenceDetails({\n                          text: sentence,\n                          grammarAnalysis,\n                          showMeanings: false,\n                        });\n                      };\n\n                      return (\n                        <div>\n                          <div className=\"sentences-container\">\n                            {allSentences.map((sentence, idx) => (\n                              <span\n                                key={idx}\n                                className={`sentence-clickable ${selectedSentenceIndex === idx ? 'selected' : ''}`}\n                                onClick={() => handleSentenceClick(idx)}\n                              >\n                                {sentence}{' '}\n                              </span>\n                            ))}\n                          </div>\n\n                          {/* 選択された文の読解エリア */}\n                          {selectedSentenceIndex !== null && selectedSentenceDetails && (\n                            <div className=\"selected-sentence-analysis\">\n                              <div className=\"flex justify-between items-center mb-4\">\n                                <h4 className=\"m-0\">📖 選択した文の読解</h4>\n                                <div className=\"flex gap-2\">\n                                  <button\n                                    className=\"px-3 py-1 text-sm bg-primary text-white rounded hover:bg-primary-hover\"\n                                    onClick={() => speakEnglish(selectedSentenceDetails.text)}\n                                    title=\"この文を発音\"\n                                  >\n                                    🔊 発音\n                                  </button>\n                                  <button\n                                    className=\"px-3 py-1 text-sm bg-info text-white rounded hover:bg-info-hover\"\n                                    onClick={() =>\n                                      setSelectedSentenceDetails({\n                                        ...selectedSentenceDetails,\n                                        showMeanings: !selectedSentenceDetails.showMeanings,\n                                      })\n                                    }\n                                  >\n                                    {selectedSentenceDetails.showMeanings\n                                      ? '意味を隠す'\n                                      : '意味を表示'}\n                                  </button>\n                                </div>\n                              </div>\n\n                              <div className=\"selected-sentence-text text-gray-900\">\n                                {selectedSentenceDetails.text}\n                              </div>\n\n                              {/* 文法構造の表示 */}\n                              <div className=\"grammar-structure mt-4\">\n                                <h5 className=\"text-sm font-semibold mb-2\">🔤 文法構造:</h5>\n                                <div className=\"flex flex-wrap gap-2\">\n                                  {(() => {\n                                    const sentenceKey = normalizeSentenceKey(\n                                      selectedSentenceDetails.text\n                                    );\n                                    const curated = CURATED_READING_STRUCTURES[sentenceKey];\n                                    if (curated) {\n                                      return curated.map((u, idx) => (\n                                        <div\n                                          key={idx}\n                                          className=\"inline-flex flex-col items-center\"\n                                        >\n                                          {(() => {\n                                            const component = componentFromCuratedLabel(u.label);\n                                            const c =\n                                              getComponentTextAndUnderlineClasses(component);\n                                            return (\n                                              <>\n                                                <span\n                                                  className={`font-medium text-base text-gray-900 border-b-2 ${c.underline}`}\n                                                >\n                                                  {u.text}\n                                                </span>\n                                                <span\n                                                  className={`text-xs font-semibold mt-0.5 ${c.text}`}\n                                                  title={u.label}\n                                                >\n                                                  {component}\n                                                </span>\n                                              </>\n                                            );\n                                          })()}\n                                        </div>\n                                      ));\n                                    }\n\n                                    const tokens = selectedSentenceDetails.grammarAnalysis;\n                                    const hasPeriod = tokens.some((a) => a.word === '.');\n                                    const filtered = tokens.filter(\n                                      (a) => !isPunctuationToken(a.word)\n                                    );\n\n                                    const components: SentenceComponent[] = filtered.map((a) =>\n                                      mapGrammarTagToComponent(a.tag)\n                                    );\n\n                                    for (let i = 1; i + 1 < filtered.length; i++) {\n                                      if (filtered[i].tag !== 'Conj') continue;\n                                      const prev = components[i - 1];\n                                      const next = components[i + 1];\n                                      if (prev === next) components[i] = prev;\n                                    }\n\n                                    const firstS = filtered.findIndex((a) => a.tag === 'S');\n                                    if (firstS > 0) {\n                                      for (let j = firstS - 1; j >= 0; j--) {\n                                        const t = filtered[j].tag;\n                                        if (t === 'Det' || t === 'Adj') components[j] = 'S';\n                                        else break;\n                                      }\n                                    }\n\n                                    const firstV = filtered.findIndex((a) => a.tag === 'V');\n                                    if (firstV >= 0) {\n                                      const firstOC = filtered.findIndex(\n                                        (a, idx) => idx > firstV && (a.tag === 'O' || a.tag === 'C')\n                                      );\n                                      if (firstOC > firstV + 1) {\n                                        const target: SentenceComponent =\n                                          filtered[firstOC].tag === 'C' ? 'C' : 'O';\n                                        for (let j = firstOC - 1; j > firstV; j--) {\n                                          const t = filtered[j].tag;\n                                          if (t === 'Det' || t === 'Adj') components[j] = target;\n                                          else break;\n                                        }\n                                      }\n                                    }\n\n                                    const result: JSX.Element[] = [];\n                                    for (let i = 0; i < filtered.length; i++) {\n                                      const comp = components[i];\n                                      const start = i;\n                                      const words: string[] = [filtered[i].word];\n\n                                      while (\n                                        i + 1 < filtered.length &&\n                                        components[i + 1] === comp\n                                      ) {\n                                        words.push(filtered[i + 1].word);\n                                        i++;\n                                      }\n\n                                      const c = getComponentTextAndUnderlineClasses(comp);\n                                      const display = words.join(' ');\n\n                                      result.push(\n                                        <div\n                                          key={`${start}-${i}-${comp}`}\n                                          className=\"inline-flex flex-col items-center\"\n                                          title={\n                                            comp === 'S'\n                                              ? '主語'\n                                              : comp === 'V'\n                                                ? '動詞'\n                                                : comp === 'O'\n                                                  ? '目的語'\n                                                  : comp === 'C'\n                                                    ? '補語'\n                                                    : '修飾語'\n                                          }\n                                        >\n                                          <span\n                                            className={`font-medium text-base text-gray-900 border-b-2 ${c.underline}`}\n                                          >\n                                            {display}\n                                          </span>\n                                          <span\n                                            className={`text-xs font-semibold mt-0.5 ${c.text}`}\n                                          >\n                                            {comp}\n                                          </span>\n                                        </div>\n                                      );\n                                    }\n\n                                    if (hasPeriod) {\n                                      const c = getComponentTextAndUnderlineClasses('M');\n                                      result.push(\n                                        <div\n                                          key=\"__period__\"\n                                          className=\"inline-flex flex-col items-center\"\n                                          title=\"ピリオド\"\n                                        >\n                                          <span\n                                            className={`font-medium text-base text-gray-900 border-b-2 ${c.underline}`}\n                                          >\n                                            .\n                                          </span>\n                                          <span\n                                            className={`text-xs font-semibold mt-0.5 ${c.text}`}\n                                          >\n                                            &nbsp;\n                                          </span>\n                                        </div>\n                                      );\n                                    }\n\n                                    return result;\n                                  })()}\n                                </div>\n                              </div>\n                            </div>\n                          )}\n                        </div>\n                      );\n                    }\n                  })()}\n                </div>\n              </div>\n            )}\n\n            {/* 全訳タブ: 全訳ファイルの内容を表示 */}\n            {readingSubTab === 'fullTranslation' && (\n              <div className=\"full-translation-display\">\n                <div className=\"full-translation-content\">\n                  {(() => {\n                    // デバッグログ\n                    console.log('[全訳タブ] currentPassage.id:', currentPassage.id);\n                    console.log(\n                      '[全訳タブ] currentPassage.translation exists:',\n                      !!currentPassage.translation\n                    );\n                    console.log(\n                      '[全訳タブ] currentPassage.translation length:',\n                      currentPassage.translation?.length || 0\n                    );\n\n                    if (currentPassage.translation) {\n                      // 全訳ファイルが存在する場合、段落ごとに分割して表示\n                      const paragraphs = currentPassage.translation\n                        .split(/\\n+/)\n                        .map((p) => p.trim())\n                        .filter((p) => p.length > 0);\n\n                      return (\n                        <div className=\"full-translation-text\">\n                          {paragraphs.map((para, idx) => (\n                            <p key={idx} className=\"paragraph-ja\">\n                              {para}\n                            </p>\n                          ))}\n                        </div>\n                      );\n                    }\n\n                    // 全訳ファイルがない場合はフレーズ訳を繋げる（フォールバック）\n                    // パッセージのタイトルで判別: \"Conversation\"を含む場合は会話形式として処理\n                    const isConversation = currentPassage.title\n                      .toLowerCase()\n                      .includes('conversation');\n\n                    if (isConversation) {\n                      // 会話形式: フレーズ単位で処理（各フレーズが話者の発言単位）\n                      const lines: string[] = [];\n\n                      currentPassage.phrases.forEach((phrase) => {\n                        let meaning = phrase.phraseMeaning || '';\n\n                        // [要修正]を削除\n                        meaning = meaning.replace(/\\[要修正\\]/g, '').trim();\n\n                        // 空の場合はスキップ\n                        if (!meaning || meaning === '-') return;\n\n                        lines.push(meaning);\n                      });\n\n                      return lines.map((line, idx) => (\n                        <p key={idx} className=\"paragraph-ja conversation-line\">\n                          {line}\n                        </p>\n                      ));\n                    } else {\n                      // 通常の長文形式: フレーズごとに訳を収集\n                      const translatedSentences: string[] = [];\n                      let currentSentence = '';\n\n                      currentPassage.phrases.forEach((phrase) => {\n                        let meaning = phrase.phraseMeaning || '';\n                        if (meaning) {\n                          meaning = meaning.replace(/\\[要修正\\]/g, '').trim();\n                          if (!meaning) return;\n\n                          const phraseWords = phrase.segments\n                            .map((s) => s.word)\n                            .join(' ')\n                            .trim();\n                          const isEndOfSentence = /[.!?]$/.test(phraseWords);\n\n                          if (!/[。！？]$/.test(meaning)) {\n                            if (isEndOfSentence) {\n                              currentSentence += meaning + '。';\n                              translatedSentences.push(currentSentence.trim());\n                              currentSentence = '';\n                            } else {\n                              currentSentence += meaning + '、';\n                            }\n                          } else {\n                            currentSentence += meaning;\n                            if (isEndOfSentence) {\n                              translatedSentences.push(currentSentence.trim());\n                              currentSentence = '';\n                            }\n                          }\n                        }\n                      });\n\n                      if (currentSentence.trim()) {\n                        translatedSentences.push(currentSentence.trim() + '。');\n                      }\n\n                      // 4文ごとに段落分け\n                      const paragraphs: string[] = [];\n                      const sentencesPerParagraph = 4;\n\n                      for (let i = 0; i < translatedSentences.length; i += sentencesPerParagraph) {\n                        const paragraphSentences = translatedSentences.slice(\n                          i,\n                          i + sentencesPerParagraph\n                        );\n                        paragraphs.push(paragraphSentences.join(''));\n                      }\n\n                      return paragraphs.map((para, idx) => (\n                        <p key={idx} className=\"paragraph-ja\">\n                          {para}\n                        </p>\n                      ));\n                    }\n                  })()}\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n\n      <style>{`\n        .comprehensive-reading-view {\n          max-width: 1200px;\n          margin: 0 auto;\n          padding: 20px;\n          width: 100%;\n        }\n\n        @media (max-width: 768px) {\n          .comprehensive-reading-view {\n            max-width: 100%;\n            margin: 0;\n            padding: 8px;\n          }\n        }\n\n        .reading-header {\n          background: white;\n          padding: 20px;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          margin-bottom: 20px;\n        }\n\n        .dark-mode .reading-header {\n          background: var(--gray-800);\n        }\n\n        .reading-header h2 {\n          margin: 0 0 20px 0;\n        }\n\n        .filter-controls, .passage-selector {\n          margin-bottom: 15px;\n        }\n\n        .filter-controls label, .passage-selector label {\n          font-weight: bold;\n          margin-right: 10px;\n          color: #333;\n        }\n\n        .dark-mode .filter-controls label,\n        .dark-mode .passage-selector label {\n          color: var(--gray-200);\n        }\n\n        .filter-controls select, .passage-selector select {\n          padding: 8px 12px;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          font-size: 14px;\n          background: white;\n          color: #333;\n        }\n\n        .dark-mode .filter-controls select,\n        .dark-mode .passage-selector select {\n          background: var(--gray-700);\n          border-color: var(--gray-600);\n          color: var(--gray-200);\n        }\n\n        .passage-stats {\n          display: flex;\n          gap: 10px;\n          margin: 15px 0;\n          flex-wrap: wrap;\n        }\n\n        .stat-badge {\n          display: inline-block;\n          padding: 6px 12px;\n          background: #f0f0f0;\n          border-radius: 4px;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .dark-mode .stat-badge {\n          background: var(--gray-700);\n          color: var(--gray-200);\n        }\n\n        .stat-badge.unknown-count {\n          background: #fff3cd;\n          color: #856404;\n          font-weight: bold;\n        }\n\n        .dark-mode .stat-badge.unknown-count {\n          background: var(--yellow-500);\n          color: var(--black);\n        }\n\n        .action-buttons {\n          display: flex;\n          gap: 10px;\n          margin-top: 15px;\n        }\n\n        .action-buttons button {\n          padding: 10px 20px;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n          font-weight: bold;\n          transition: all 0.3s;\n        }\n\n        .btn-primary {\n          background: #007bff;\n          color: white;\n        }\n\n        .btn-primary:hover {\n          background: #0056b3;\n        }\n\n        .btn-info {\n          background: #17a2b8;\n          color: white;\n        }\n\n        .btn-info:hover {\n          background: #138496;\n        }\n\n        .btn-success {\n          background: #28a745;\n          color: white;\n        }\n\n        .btn-success:hover {\n          background: #218838;\n        }\n\n        .btn-success:disabled {\n          background: #ccc;\n          cursor: not-allowed;\n        }\n\n        .btn-secondary {\n          background: #6c757d;\n          color: white;\n        }\n\n        .btn-secondary:hover {\n          background: #545b62;\n        }\n\n        .passage-content {\n          background: white;\n          padding: 30px;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .dark-mode .passage-content {\n          background: var(--gray-800);\n          color: var(--gray-100);\n        }\n\n        .passage-title {\n          text-align: center;\n          color: #333;\n          margin-bottom: 30px;\n          font-size: 24px;\n          font-family: 'Times New Roman', Georgia, serif;\n        }\n\n        .dark-mode .passage-title {\n          color: var(--white);\n        }\n\n        .passage-body {\n          line-height: 1.5;\n          font-family: 'Times New Roman', Georgia, serif;\n          color: #333;\n        }\n\n        .dark-mode .passage-body {\n          color: var(--gray-200);\n        }\n\n        .phrase-block {\n          margin-bottom: 8px;\n          padding: 8px 12px;\n          background: #ffffff;\n          border-left: 3px solid #007bff;\n          border-radius: 2px;\n        }\n\n        .dark-mode .phrase-block {\n          background: var(--gray-700);\n          border-left-color: var(--blue-400);\n        }\n\n        .phrase-english {\n          font-size: 16px;\n          line-height: 1.6;\n          margin-bottom: 6px;\n          font-family: 'Times New Roman', 'Georgia', serif;\n          display: flex;\n          flex-wrap: wrap;\n          gap: 8px;\n          align-items: flex-start;\n        }\n\n        .word-card {\n          display: inline-flex;\n          flex-direction: column;\n          align-items: center;\n          padding: 2px 5px;\n          margin: 1px;\n          background: #f8f9fa;\n          border: 1px solid #dee2e6;\n          border-radius: 4px;\n          cursor: pointer;\n          transition: all 0.2s;\n          min-width: 60px;\n        }\n\n        .dark-mode .word-card {\n          background: var(--gray-700);\n          border-color: var(--gray-600);\n        }\n\n        .word-card:hover {\n          background: #e7f3ff;\n          border-color: #007bff;\n        }\n\n        .dark-mode .word-card:hover {\n          background: var(--gray-600);\n          border-color: var(--blue-400);\n        }\n\n        .word-card.unknown {\n          background: #ffc107;\n          color: #000;\n          border-color: #ff9800;\n          font-weight: bold;\n        }\n\n        .word-card.phrase-card {\n          background: #e8f5e9;\n          border-color: #4caf50;\n        }\n\n        .dark-mode .word-card.phrase-card {\n          background: var(--gray-700);\n          border-color: var(--green-400);\n        }\n\n        .word-card.phrase-card:hover {\n          background: #c8e6c9;\n        }\n\n        .dark-mode .word-card.phrase-card:hover {\n          background: var(--gray-600);\n        }\n\n        .word-card.punctuation-card {\n          min-width: 20px;\n          background: transparent;\n          border: none;\n          cursor: default;\n          padding: 2px 4px;\n        }\n\n        .word-card.punctuation-card:hover {\n          background: transparent;\n          border: none;\n        }\n\n        .word-card-word {\n          font-size: 16px;\n          font-weight: 500;\n          color: #333;\n          text-align: center;\n          font-family: 'Times New Roman', Georgia, serif;\n        }\n\n        .dark-mode .word-card-word {\n          color: var(--gray-200);\n        }\n\n        .phrase-card .word-card-word {\n          font-size: 15px;\n          color: #2e7d32;\n          font-family: 'Times New Roman', Georgia, serif;\n        }\n\n        .dark-mode .phrase-card .word-card-word {\n          color: var(--green-400);\n        }\n\n        .word-card-meaning {\n          font-size: 12px;\n          color: #666;\n          margin-top: 1px;\n          text-align: center;\n          padding: 1px 3px;\n          background: rgba(255, 255, 255, 0.8);\n          border-radius: 2px;\n          min-height: 14px;\n        }\n\n        .dark-mode .word-card-meaning {\n          color: var(--gray-300);\n          background: rgba(48, 48, 48, 0.8);\n        }\n\n        .word-segment {\n          display: inline-block;\n          padding: 2px 4px;\n          margin: 0 2px;\n          cursor: pointer;\n          border-radius: 3px;\n          transition: all 0.2s;\n          font-family: 'Times New Roman', Georgia, serif;\n        }\n\n        .word-segment:hover {\n          background: #e7f3ff;\n        }\n\n        .word-segment.unknown {\n          background: #ffc107;\n          color: #000;\n          font-weight: bold;\n        }\n\n        .show-translation-btn {\n          background: #f8f9fa;\n          border: 1px solid #ddd;\n          padding: 8px 16px;\n          border-radius: 4px;\n          cursor: pointer;\n          color: #666;\n          font-size: 14px;\n        }\n\n        .show-translation-btn:hover {\n          background: #e9ecef;\n        }\n\n        .phrase-translation {\n          margin-top: 10px;\n          padding: 15px;\n          background: white;\n          border-radius: 4px;\n          border: 1px solid #dee2e6;\n        }\n\n        .dark-mode .phrase-translation {\n          background: var(--gray-800);\n          border-color: var(--gray-600);\n        }\n\n        .translation-text {\n          font-size: 16px;\n          color: #333;\n          margin-bottom: 10px;\n          font-weight: 500;\n        }\n\n        .dark-mode .translation-text {\n          color: var(--gray-200);\n        }\n\n        .word-meanings {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 10px;\n          font-size: 14px;\n          color: #666;\n        }\n\n        .dark-mode .word-meanings {\n          color: var(--gray-300);\n        }\n\n        .word-meaning-pair {\n          background: #e7f3ff;\n          padding: 4px 8px;\n          border-radius: 3px;\n        }\n\n        .dark-mode .word-meaning-pair {\n          background: var(--gray-700);\n          color: var(--gray-200);\n        }\n\n        .error-message, .empty-container {\n          text-align: center;\n          padding: 50px;\n          font-size: 18px;\n          color: #666;\n        }\n\n        .dark-mode .error-message,\n        .dark-mode .empty-container {\n          color: var(--gray-300);\n        }\n\n        .error-message {\n          color: #dc3545;\n        }\n\n        .dark-mode .error-message {\n          color: var(--red-400);\n        }\n\n        /* 単語ポップアップのスタイル */\n        .word-popup-overlay {\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          background: transparent;\n          z-index: 999;\n        }\n\n        .word-popup {\n          position: absolute;\n          left: var(--popup-x, 0);\n          top: var(--popup-y, 0);\n          background: white;\n          border: 2px solid #007bff;\n          border-radius: 8px;\n          padding: 16px;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);\n          z-index: 1000;\n          max-width: 400px;\n          min-width: 250px;\n        }\n\n        .dark-mode .word-popup {\n          background: var(--gray-800);\n          border-color: var(--blue-400);\n          color: var(--gray-200);\n        }\n\n        .popup-close {\n          position: absolute;\n          top: 8px;\n          right: 8px;\n          background: #f8f9fa;\n          border: none;\n          border-radius: 4px;\n          width: 24px;\n          height: 24px;\n          cursor: pointer;\n          font-size: 16px;\n          line-height: 1;\n          color: #666;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n        }\n\n        .popup-close:hover {\n          background: #e9ecef;\n          color: #000;\n        }\n\n        .popup-word {\n          font-size: 20px;\n          font-weight: bold;\n          color: #007bff;\n          margin-bottom: 4px;\n          padding-right: 30px;\n        }\n\n        .popup-reading {\n          font-size: 14px;\n          color: #666;\n          margin-bottom: 8px;\n        }\n\n        .popup-meaning {\n          font-size: 16px;\n          color: #333;\n          margin-bottom: 12px;\n          padding: 8px;\n          background: #f0f8ff;\n          border-radius: 4px;\n        }\n\n        .popup-etymology {\n          font-size: 13px;\n          color: #555;\n          margin-bottom: 8px;\n          padding: 6px;\n          background: #f8f9fa;\n          border-radius: 4px;\n        }\n\n        .popup-related {\n          font-size: 13px;\n          color: #555;\n          padding: 6px;\n          background: #f8f9fa;\n          border-radius: 4px;\n        }\n\n        .popup-etymology strong,\n        .popup-related strong {\n          color: #007bff;\n        }\n\n        .full-text-display, .full-translation-display {\n          background: white;\n          padding: 20px;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          margin-top: 20px;\n        }\n\n        .dark-mode .full-text-display,\n        .dark-mode .full-translation-display {\n          background: var(--gray-800);\n          color: var(--gray-100);\n        }\n\n        .full-text-display h3, .full-translation-display h3 {\n          margin: 0 0 15px 0;\n          color: #667eea;\n        }\n\n        .dark-mode .full-text-display h3,\n        .dark-mode .full-translation-display h3 {\n          color: var(--blue-400);\n        }\n\n        .full-text-content {\n          font-size: 1.1em;\n          line-height: 1.8;\n          color: #333;\n          font-family: 'Times New Roman', 'Georgia', serif;\n        }\n\n        .full-text-content .paragraph-en {\n          margin-bottom: 1.5em;\n          text-indent: 2em;\n          text-align: left;\n        }\n\n        .full-text-content .paragraph-en:first-child {\n          margin-top: 0;\n        }\n\n        /* 会話形式の行スタイル */\n        .full-text-content .conversation-line {\n          text-indent: 0;\n          margin-bottom: 1em;\n          padding-left: 1em;\n          border-left: 3px solid #667eea;\n        }\n\n        .full-translation-content {\n          font-size: 1.05em;\n          line-height: 2;\n          color: #333;\n        }\n\n        .full-translation-text {\n          white-space: pre-wrap;\n          line-height: 2;\n        }\n\n        .full-translation-content .paragraph-ja {\n          margin-bottom: 1.5em;\n          text-indent: 1em;\n          text-align: left;\n        }\n\n        .full-translation-content .paragraph-ja:first-child {\n          margin-top: 0;\n        }\n\n        /* 会話形式の日本語訳スタイル */\n        .full-translation-content .conversation-line {\n          text-indent: 0;\n          margin-bottom: 1em;\n          padding-left: 1em;\n          border-left: 3px solid #667eea;\n        }\n\n        .translation-line {\n          margin-bottom: 10px;\n          padding: 8px;\n          background: #f8f9fa;\n          border-radius: 4px;\n        }\n      `}</style>\n    </div>\n  );\n}\n\nexport default ComprehensiveReadingView;\n"],"names":["extractTitleFromPath","filePath","fileName","parts","PASSAGE_FILES_RAW","PASSAGE_FILES","passage","getPassageList","loadOriginalPassage","passageId","metadata","p","logger","originalPath","response","error","loadPassage","content","sections","parsePassageContent","lines","currentSection","line","trimmed","PASSAGE_FILE_BASE_BY_ID","resolvePassageFileBase","getLemma","word","cleaned","base","loadFullTranslation","fileBase","candidates","translationFilePath","_error","loadJapanesePhrases","jaFilePath","convertPassageToReadingFormat","wordDictionary","loaded","japanesePhrases","fullTranslation","originalText","japaneseIndex","phrases","section","paragraph","fullText","words","segments","processWord","leadingQuote","lemma","wordData","meaning","result","punctuationMatch","cleanWord","punctuation","japanese","phraseText","loadPhraseLearningJSON","path","res","data","_a","loadAllPassagesAsReadingFormat","passages","meta","cache","fetchJson","err","cached","key","parseTrailingNumber","id","match","n","sortByIdNumber","items","a","b","loadParagraphReadingPatterns","loadSentenceReadingPatterns","mapDependencyTokensToSVOCMByStartIndex","tokens","byId","childrenByHead","roleById","t","head","arr","deprelLower","uposUpper","isPunct","root","findChild","headId","deprel","kids","tok","collectSubtree","excludeDeprels","out","stack","cur","k","cop","isCopular","rel","exclude","upos","role","VERBS","PREPOSITIONS","CONJUNCTIONS","DETERMINERS","PRONOUNS","ADJECTIVES","ADVERBS","getTagColor","tag","getTagDescription","classifyWord","index","lower","next","nextLower","_b","getPunctuationMeaning","_tokenizeWithStartIndices","sentence","cursor","idx","analyzeSentence","EVERY_TIME_NOUNS","results","foundVerb","foundSubject","foundObjectOrComplement","lastVerbLower","BE_VERBS","i","analyzeSentenceWithDependency","dependencyTokens","roleByStart","tokenized","token","start","PHRASAL_EXPRESSIONS","detectPhrasalExpressions","detected","lowerWords","w","expression","exprLower","j","GRAMMAR_PATTERNS","detectGrammarPatterns","pattern","_getLevelLabel","level","normalizeSentenceKey","text","isPunctuationToken","getComponentTextAndUnderlineClasses","component","componentFromCuratedLabel","label","mapGrammarTagToComponent","CURATED_READING_STRUCTURES","CURATED_READING_TRANSLATIONS","tryBuildPhrasalMap","phrasals","phrasalMap","phrasalWordIndices","usedStarts","expr","span","ComprehensiveReadingView","onSaveUnknownWords","customQuestionSets","onAddWordToCustomSet","onRemoveWordFromCustomSet","onOpenCustomSetManagement","setPassages","useState","selectedPassageId","setSelectedPassageId","phraseTranslations","setPhraseTranslations","wordMeaningsVisible","setWordMeaningsVisible","difficultyFilter","setDifficultyFilter","setError","setWordDictionary","readingDictionary","setReadingDictionary","wordPopup","setWordPopup","showSettings","setShowSettings","readingStarted","_setReadingStarted","readingSubTab","setReadingSubTab","_currentPhraseIndex","_setCurrentPhraseIndex","isFullTextSpeaking","setIsFullTextSpeaking","isFullTextPaused","setIsFullTextPaused","selectedSentenceIndex","setSelectedSentenceIndex","selectedSentenceDetails","setSelectedSentenceDetails","dependencyParsedPassage","setDependencyParsedPassage","showReadingDebugPanel","setShowReadingDebugPanel","isLoading","setIsLoading","sentencePatterns","setSentencePatterns","paragraphPatterns","setParagraphPatterns","useEffect","sentenceData","paragraphData","cancelled","loadDependencyParsedPassage","parsed","readingProgressKey","progressData","phrase","pIdx","seg","sIdx","csvText","dictionary","row","cell","_err","dictData","readingDict","info","useCallback","normalized","deduped","getMeaning","existingMeaning","lowerWord","readingWord","checkSpeechStatus","isSpeaking","isPaused","savedProgress","stored","e","loadedPassages","restoredPassages","saved","levelOrder","sortedData","levelA","levelB","wordCountA","wordCountB","currentPassage","useMemo","filteredPassages","filtered","handleSelectPassage","phraseIdx","event","isSpeechSynthesisSupported","speakEnglish","element","handleSaveUnknownWords","unknownWords","segment","prev","handleReset","jsxs","jsx","unknownCount","count","s","Fragment","sentences","reconstructedSentences","depSentence","findDependencySentenceByText","grammarAnalysis","lineText","lastWasPeriod","sentenceKey","curated","u","c","hasPeriod","components","firstS","firstV","firstOC","target","comp","display","filteredAnalysis","numberWordToDigit","getLiteralMeaning","groupWords","exact","d","digit","m","phrasalExpressions","startIdx","found","ew","ei","actualIdx","_","groups","phrasalExpr","w0","naturalLine","g","getGroupMeaning","analysis","dictMeaning","simpleItems","AddToCustomButton","patterns","keywords","matched","ids","sp","step","isFirstSentence","paragraphKeywords","pp","resumeSpeaking","pauseSpeaking","stopSpeaking","firstPhraseText","isFirstPhraseTitle","paragraphs","currentParagraph","wordCount","targetWordsPerParagraph","sentenceWordCount","allSentences","handleSentenceClick","para","translatedSentences","currentSentence","phraseWords","isEndOfSentence","sentencesPerParagraph","paragraphSentences"],"mappings":"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F,CAIF,UAAWc,KAAKJ,EACVS,EAAQL,CAAC,GACRD,EAAS,IAAIC,EAAE,EAAE,GAAGD,EAAS,IAAIC,EAAE,GAAI,GAAG,EAGjD,MAAMc,MAAU,IAChB,UAAWd,KAAKJ,EAAQ,CACtB,MAAM2B,EAAOxB,EAAS,IAAIC,EAAE,EAAE,EACzBuB,GACLT,EAAI,IAAId,EAAE,MAAOuB,CAAI,CACvB,CACA,OAAOT,CACT,CC9GA,MAAMU,OAAY,IAAI,CACpB,KACA,KACA,KACA,MACA,MACA,OACA,OACA,QACA,OACA,MACA,MACA,SACA,KACA,OACA,MACA,OACA,QACA,MACA,QACA,OACA,QACA,QACA,SACA,MACA,QACA,OACA,KACA,OACA,OACA,OACA,QACA,MACA,OACA,MACA,SACA,UACA,OACA,QACA,OACA,SACA,OACA,QACA,OACA,QACA,SACA,MACA,OACA,MACA,OACA,SACA,OACA,QACA,OACA,SACA,OACA,QACA,SACA,UACA,MACA,OACA,OACA,QACA,OACA,QACA,QACA,UACA,OACA,QACA,OACA,QACA,SACA,OACA,QACA,OACA,UACA,OACA,QACA,SACA,UACA,OACA,QACA,SACA,UACA,MACA,QACA,QACA,SACA,MACA,OACA,QACA,SACA,OACA,QACA,SACA,UACA,OACA,QACA,OACA,UACA,SACA,UACA,SACA,WACA,QACA,SACA,OACA,UACA,MACA,OACA,UACA,OACA,QACA,QACA,UACA,OACA,QACA,OACA,UACA,MACA,OACA,UACA,QACA,SACA,QACA,QACA,YACA,OACA,QACA,SACA,UACA,OACA,QACA,SACA,UACA,OACA,QACA,SACA,UACA,OACA,QACA,SACA,UACA,QACA,SACA,UACA,WACA,OACA,QACA,SACA,QACA,UACA,OACA,QACA,QACA,UACA,OACA,QACA,SACA,UACA,MACA,OACA,MACA,UACA,OACA,QACA,QACA,SACA,OACA,QACA,QACA,SACA,OACA,QACA,QACA,SACA,UACA,WACA,WACA,YACA,QACA,SACA,UACA,WACA,SACA,UACA,WACA,YACA,QACA,SACA,QACA,UACA,UACA,MACA,OACA,MACA,UACA,QACA,SACA,QACA,WACA,OACA,QACA,OACA,SACA,MACA,OACA,OACA,SACA,OACA,QACA,MACA,UACA,UACA,WACA,WACA,YACA,WACA,YACA,YACA,aACA,MACA,OACA,UACA,QACA,SACA,UACA,WACA,SACA,UACA,UACA,WACA,OACA,QACA,MACA,UACA,aACA,cACA,aACA,gBACA,QACA,UACA,UACA,WACA,SACA,UACA,WACA,YACA,OACA,QACA,UACA,WACA,SACA,UACA,UACA,WACA,QACA,SACA,QACA,SACA,WACA,OACA,QACA,UACA,QACA,SACA,QACA,WACA,OACA,QACA,OACA,QACA,UACA,OACA,QACA,SACA,UACA,OACA,QACA,SACA,UACA,MACA,OACA,MACA,UACA,QACA,UACA,SACA,WACA,QACA,SACA,UACA,WACA,WACA,YACA,aACA,cACA,WACA,YACA,aACA,cACA,SACA,UACA,WACA,YACA,MACA,OACA,SACA,SACA,QACA,SACA,SACA,UACA,MACA,OACA,OACA,QACA,OACA,QACA,OACA,UACA,QACA,SACA,QACA,WACA,OACA,QACA,SACA,UACA,OACA,QACA,OACA,SACA,UACA,MACA,OACA,UACA,QACA,UACA,UACA,WACA,OACA,QACA,SACA,UACA,QACA,SACA,SACA,UACA,OACA,SACA,SACA,UACA,OACA,QACA,OACA,UACA,SACA,UACA,UACA,WACA,SACA,UACA,WACA,YACA,UACA,WACA,YACA,aACA,OACA,QACA,QACA,SACA,UACA,WACA,YACA,aACA,QACA,UACA,UACA,WACA,QACA,SACA,QACA,SACA,WACA,UACA,WACA,WACA,YACA,QACA,SACA,SACA,WACA,UACA,WACA,YACA,aACA,MACA,OACA,UACA,UACA,WACA,WACA,YACA,MACA,OACA,MACA,QACA,SACA,QACA,SACA,UACA,WACA,QACA,UACA,SACA,WACA,OACA,QACA,OACA,QACA,UACA,OACA,QACA,OACA,QACA,SACA,QACA,UACA,UACA,WACA,OACA,SACA,SACA,UACA,UACA,WACA,WACA,YACA,QACA,SACA,UACA,UACF,CAAC,EAEKC,OAAmB,IAAI,CAC3B,KACA,KACA,KACA,KACA,MACA,OACA,OACA,KACA,QACA,KACA,OACA,OACA,UACA,QACA,OACA,UACA,MACA,UACA,SACA,UACA,SACA,QACA,SACA,QACA,KACA,IACF,CAAC,EAEKC,OAAmB,IAAI,CAC3B,MACA,MACA,KACA,KACA,MACA,MACA,MACA,UACA,WACA,KACA,OACA,QACA,QACA,SACA,OACA,QACA,MACA,OACA,QACA,OACF,CAAC,EAEKC,OAAkB,IAAI,CAC1B,MACA,IACA,KACA,OACA,OACA,QACA,QACA,KACA,OACA,MACA,MACA,MACA,MACA,QACA,OACA,MACA,KACA,QACA,OACA,SACA,UACA,OACA,OACA,OACA,OACA,MACA,SACA,SACF,CAAC,EAEKC,OAAe,IAAI,CACvB,IACA,MACA,KACA,MACA,KACA,KACA,OACA,KACA,MACA,MACA,KACA,OACA,SACA,WACA,UACA,UACA,SACA,YACA,YACF,CAAC,EAEKC,OAAiB,IAAI,CACzB,OACA,MACA,QACA,OACA,OACA,QACA,SACA,MACA,QACA,MACA,QACA,MACA,OACA,YACA,QACA,QACA,OACA,QACA,QACA,YACA,MACA,SACA,MACA,OACA,OACA,QACA,OACF,CAAC,EAEKC,OAAc,IAAI,CACtB,MACA,KACA,KACA,MACA,OACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,OACA,QACA,KACA,KACA,MACA,OACA,QACA,SACA,UACA,UACA,QACA,QACA,QACF,CAAC,EAKD,SAASC,GAAYC,EAAyB,CAc5C,MAb6C,CAC3C,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,KAAM,UACN,KAAM,UACN,IAAK,UACL,IAAK,UACL,IAAK,UACL,QAAS,SAAA,EAEKA,CAAG,CACrB,CAKA,SAASC,GAAkBD,EAAyB,CAc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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAA,CAulBN,CAAA,EACJ,CAEJ"}