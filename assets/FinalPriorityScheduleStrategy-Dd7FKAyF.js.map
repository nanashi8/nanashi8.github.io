{"version":3,"mappings":"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","names":["FinalPriorityScheduleStrategy","BaseScheduleStrategy","context","params","startTime","dependencies","scheduler","scheduleContext","signals","progressCache","allProgress","currentTab","totalAttempts","masteredCount","stillLearningCount","incorrectCount","newCount","wp","pos","PositionCalculator","aiSessionStats","HybridScheduleStrategy","__vitePreload","m","prioritized","question","wordProgress","cachedStatus","position","fallbackAttempts","fallbackCorrect","status","positionToCategory","aiResult","gamificationAI","GamificationAI","boostedPrioritized","pq","_a","adjustedForNew","sorted","a","b","interleaved","top30Final","idx","_b","writeDebugJSON","statsPayload","questions","vibrationScore","processingTime","logger"],"ignoreList":[],"sources":["../../src/ai/scheduler/strategies/FinalPriorityScheduleStrategy.ts"],"sourcesContent":["/**\n * FinalPriorityScheduleStrategy - FinalPriorityモードのスケジューリング戦略\n *\n * AICoordinatorのfinalPriorityを主軸にしたスケジューリング戦略（variant=C）\n *\n * 【特徴】\n * - AICoordinatorの7AI統合評価（finalPriority）を主因として使用\n * - Position計算は補助的に使用\n * - GamificationAIによる「まだまだ語」のブースト\n * - 新規語のインターリーブで「分からない連打で新規が一切出ない」を回避\n *\n * 【使用例】\n * ```typescript\n * const strategy = new FinalPriorityScheduleStrategy(dependencies);\n * const result = await strategy.schedule(context);\n * ```\n */\n\nimport type { ScheduleResult, PrioritizedQuestion as PQ, WordStatus } from '../types';\nimport type { ScheduleContext } from './ScheduleStrategy';\nimport { BaseScheduleStrategy } from './ScheduleStrategy';\nimport { logger } from '@/utils/logger';\nimport { PositionCalculator } from '../PositionCalculator';\nimport { positionToCategory } from '@/ai/utils/categoryDetermination';\nimport { writeDebugJSON } from '@/utils/debugStorage';\nimport { DebugTracer } from '@/utils/DebugTracer';\nimport { GamificationAI } from '@/ai/specialists/GamificationAI';\n\nexport class FinalPriorityScheduleStrategy extends BaseScheduleStrategy {\n  /**\n   * FinalPriorityモードでスケジューリング\n   *\n   * @param context - スケジューリングコンテキスト\n   * @returns スケジューリング結果\n   */\n  async schedule(context: ScheduleContext): Promise<ScheduleResult> {\n    const { params, startTime, dependencies } = context;\n    const scheduler = dependencies.scheduler; // QuestionScheduler（Context）\n\n    this.log('FinalPriorityモード開始', {\n      questionCount: params.questions.length,\n      mode: params.mode,\n    });\n\n    // 1. コンテキスト構築\n    const scheduleContext = scheduler.buildContext(params);\n\n    // 2. シグナル検出\n    const signals = scheduler.detectSignals(scheduleContext);\n\n    // 3. 進捗データ取得\n    const progressCache = scheduler.loadProgressCache();\n    const allProgress: Record<string, any> = (progressCache?.wordProgress ?? {}) as Record<\n      string,\n      any\n    >;\n\n    // 4. AICoordinator用のセッション統計構築\n    const currentTab: 'memorization' | 'grammar' | 'comprehensive' =\n      params.mode === 'grammar'\n        ? 'grammar'\n        : params.mode === 'memorization'\n          ? 'memorization'\n          : 'comprehensive';\n\n    const totalAttempts =\n      (params.sessionStats.correct || 0) +\n      (params.sessionStats.incorrect || 0) +\n      (params.sessionStats.still_learning || 0) +\n      (params.sessionStats.mastered || 0);\n\n    // 学習段階の分布計算\n    let masteredCount = 0;\n    let stillLearningCount = 0;\n    let incorrectCount = 0;\n    let newCount = 0;\n    for (const wp of Object.values(allProgress)) {\n      const calculator = new PositionCalculator(\n        params.mode as 'memorization' | 'translation' | 'spelling' | 'grammar'\n      );\n      const pos = calculator.calculate(wp);\n      if (pos >= 70) incorrectCount++;\n      else if (pos >= 40) stillLearningCount++;\n      else if (pos >= 20) newCount++;\n      else masteredCount++;\n    }\n\n    const aiSessionStats = {\n      totalAttempts,\n      correctAnswers: params.sessionStats.correct || 0,\n      incorrectAnswers: params.sessionStats.incorrect || 0,\n      stillLearningAnswers: params.sessionStats.still_learning || 0,\n      sessionStartTime: scheduleContext.sessionStartTime,\n      sessionDuration: (params.sessionStats.duration || 0) as number,\n      consecutiveIncorrect: 0,\n      masteredCount,\n      stillLearningCount,\n      incorrectCount,\n      newCount,\n      consecutiveCorrect: params.sessionStats.consecutiveCorrect || 0,\n    };\n\n    // 5. AICoordinatorチェック\n    if (!dependencies.aiCoordinator) {\n      this.logError('AICoordinatorが未初期化、ハイブリッドモードにフォールバック');\n      // HybridScheduleStrategyにフォールバック\n      const HybridScheduleStrategy = await import('./HybridScheduleStrategy').then(\n        (m) => m.HybridScheduleStrategy\n      );\n      const hybrid = new HybridScheduleStrategy(dependencies);\n      return hybrid.schedule(context);\n    }\n\n    // 6. デバッグトレース開始\n    let beforeAISpanId: string | undefined;\n    if (import.meta.env.DEV) {\n      const weakWordsInInput = params.questions.filter((q) => {\n        const wp = allProgress[q.word] ?? scheduleContext.wordProgress[q.word] ?? null;\n        if (!wp) return false;\n        const attempts = wp.memorizationAttempts ?? wp.totalAttempts ?? 0;\n        if (attempts <= 0) return false;\n        const calculator = new PositionCalculator(\n          params.mode as 'memorization' | 'translation' | 'spelling' | 'grammar'\n        );\n        const pos = calculator.calculate(wp);\n        return pos >= 40;\n      });\n\n      beforeAISpanId = DebugTracer.startSpan('FinalPriorityScheduleStrategy.beforeAI', {\n        weakWordsCount: weakWordsInInput.length,\n        totalCount: params.questions.length,\n        weakWords: weakWordsInInput.map((q) => q.word),\n      });\n    }\n\n    // 7. 各問題にAICoordinatorのfinalPriorityを取得\n    const prioritized: PQ[] = [];\n    for (const question of params.questions) {\n      const wordProgress =\n        allProgress[question.word] ?? scheduleContext.wordProgress[question.word] ?? null;\n\n      const cachedStatus = scheduler.getWordStatusFromCache(\n        question.word,\n        scheduleContext.mode,\n        progressCache\n      );\n\n      // Position決定\n      const position =\n        cachedStatus?.position ??\n        new PositionCalculator(\n          params.mode as 'memorization' | 'translation' | 'spelling' | 'grammar'\n        ).calculate(wordProgress);\n\n      // モード別attempts取得\n      let fallbackAttempts = 0;\n      let fallbackCorrect = 0;\n      if (wordProgress) {\n        switch (params.mode) {\n          case 'memorization':\n            fallbackAttempts = wordProgress.memorizationAttempts || 0;\n            fallbackCorrect = wordProgress.memorizationCorrect || 0;\n            break;\n          case 'translation':\n            fallbackAttempts = wordProgress.translationAttempts || 0;\n            fallbackCorrect = wordProgress.translationCorrect || 0;\n            break;\n          case 'spelling':\n            fallbackAttempts = wordProgress.spellingAttempts || 0;\n            fallbackCorrect = wordProgress.spellingCorrect || 0;\n            break;\n          case 'grammar':\n            fallbackAttempts = wordProgress.grammarAttempts || 0;\n            fallbackCorrect = wordProgress.grammarCorrect || 0;\n            break;\n          default:\n            break;\n        }\n      }\n\n      const status: WordStatus = cachedStatus ?? {\n        category: positionToCategory(position),\n        position,\n        lastStudied: wordProgress?.lastStudied || 0,\n        attempts: fallbackAttempts,\n        correct: fallbackCorrect,\n        streak: wordProgress?.consecutiveCorrect || 0,\n        forgettingRisk: 0,\n        reviewInterval: 1,\n      };\n\n      // AICoordinator分析\n      const aiResult = await dependencies.aiCoordinator.analyzeAndCoordinate(\n        {\n          word: {\n            word: question.word,\n            meaning: question.meaning,\n            reading: question.reading,\n            difficulty: question.difficulty,\n            category: question.category,\n            source: question.source,\n            type: question.type,\n            isPhraseOnly: question.isPhraseOnly,\n          },\n          progress: wordProgress,\n          sessionStats: aiSessionStats,\n          currentTab,\n          allProgress,\n        },\n        position / 100 // basePriority（0-1）\n      );\n\n      prioritized.push({\n        question,\n        position,\n        finalPriority: aiResult.finalPriority,\n        status,\n        attempts: status?.attempts ?? 0,\n        timeBoost: 1.0,\n      });\n    }\n\n    // 8. デバッグトレース終了\n    if (import.meta.env.DEV && beforeAISpanId) {\n      const weakWordsAfterLoop = prioritized.filter((pq: PQ) => {\n        if (!pq.status) return false;\n        const attempts = pq.status.attempts ?? 0;\n        if (attempts <= 0) return false;\n        return pq.position >= 40;\n      });\n      DebugTracer.endSpan(beforeAISpanId, {\n        weakWordsCount: weakWordsAfterLoop.length,\n        totalCount: prioritized.length,\n        weakWords: weakWordsAfterLoop.map((pq: PQ) => pq.question.word),\n      });\n    }\n\n    // 9. GamificationAI: まだまだ語をブースト\n    const gamificationAI = new GamificationAI();\n    const boostedResult = gamificationAI.boostStillLearningQuestions(prioritized);\n    const boostedPrioritized = boostedResult.result;\n\n    // まだまだ語のfinalPriorityをブースト（Position 60-69）\n    for (const pq of boostedPrioritized) {\n      if (pq.position >= 60 && pq.position < 70 && (pq.status?.attempts ?? 0) > 0) {\n        pq.finalPriority = (pq.finalPriority ?? 0) + 100.0;\n      }\n    }\n\n    // 10. 新規混入（Position分散 → インターリーブ）\n    const { result: adjustedForNew } =\n      gamificationAI.adjustPositionForInterleaving(boostedPrioritized);\n\n    // 11. finalPriority降順ソート\n    const sorted = [...adjustedForNew].sort(\n      (a: PQ, b: PQ) => (b.finalPriority ?? 0) - (a.finalPriority ?? 0)\n    );\n\n    // 12. カテゴリ別インターリーブ\n    const interleaved = gamificationAI.interleaveByCategory(sorted);\n\n    // 13. デバッグ情報保存\n    try {\n      const top30Final = interleaved.slice(0, 30).map((pq: PQ, idx: number) => ({\n        rank: idx + 1,\n        word: pq.question.word,\n        position: pq.position,\n        finalPriority: pq.finalPriority ?? 0,\n        category: pq.status?.category,\n        attempts: pq.status?.attempts ?? 0,\n      }));\n      writeDebugJSON('debug_finalPriority_output', top30Final, { mode: scheduleContext.mode });\n\n      const statsPayload = {\n        currentTab,\n        totalQuestions: params.questions.length,\n        allProgressCount: Object.keys(allProgress || {}).length,\n        aiSessionStats,\n        timestamp: new Date().toISOString(),\n        mode: scheduleContext.mode,\n      };\n      writeDebugJSON('debug_finalPriority_sessionStats', statsPayload, {\n        mode: scheduleContext.mode,\n      });\n    } catch {\n      // localStorage失敗は無視\n    }\n\n    // 14. 後処理\n    const questions = scheduler.postProcess(interleaved, scheduleContext);\n\n    // 15. 振動スコア計算\n    const vibrationScore = dependencies.antiVibration.calculateVibrationScore(\n      interleaved,\n      scheduleContext.recentAnswers,\n      20\n    );\n\n    const processingTime = performance.now() - startTime;\n\n    logger.info(`[FinalPriorityScheduleStrategy] スケジューリング完了`, {\n      processingTime: Math.round(processingTime) + 'ms',\n      vibrationScore,\n      aiEnabled: true,\n      totalCount: questions.length,\n      top5FinalPriority: interleaved.slice(0, 5).map((pq: PQ) => ({\n        word: pq.question.word,\n        finalPriority: (pq.finalPriority ?? 0).toFixed(3),\n        position: pq.position,\n      })),\n    });\n\n    return this.buildResult(interleaved, {\n      source: 'FinalPriorityScheduleStrategy',\n      elapsed: processingTime,\n      vibrationScore,\n      signalCount: signals.length,\n    });\n  }\n}\n"],"file":"assets/FinalPriorityScheduleStrategy-Dd7FKAyF.js"}