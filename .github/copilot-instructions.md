# SimpleWord プロジェクト固有指示

**最終更新**: 2025年11月5日  
**バージョン**: v1.17.0

---

## 技術スタック

- Swift 専用（Objective-C は使用しない）
- SwiftUI + Combine
- Xcode プロジェクト（15.0以上）
- iOS 16.0以上

---

## アーキテクチャ

- Feature-First / Vertical Slice Architecture を採用
- 各 Feature は `Features/` 配下に配置
- View と ViewModel は責務を分離し、別ファイルで管理

---

## データ管理

### CSV仕様

- CSV ファイルからの読み込みを基本とする
- **CSV列は7列固定**（語句、読み/発音、意味/和訳/史実名、語源/解説、関連語、関連分野、難易度）
- **列3（意味/和訳/史実名）が選択肢として使用される**ため、この列のデータ品質が重要
- 列数の整合性チェックを必須とする
- パース失敗時は適切なエラーハンドリングを行う
- `QuestionItem.rawColumns` に生のCSVデータを保存し、固定列順でのアクセスを可能にする

### 選択肢生成ロジック

**重要**: 選択肢自体は**CSV固定列3（`rawColumns[2]`：意味/和訳/史実名）**から生成されます。これにより、ヘッダ駆動型パーサの影響を受けずに正確な選択肢が表示されます。

---

## CSV種類別表示順序

**実装日**: 2025年10月28日  
**対応内容**: CSV種類別に最適化された選択肢カード詳細表示の実装

---

## 📋 実装概要

回答後の選択肢カードの詳細表示を、CSV種類（中学歴史、中学古典単語、中学英単語・英会話など）に応じて最適な順序で表示するように実装しました。

**重要**: 選択肢自体は**CSV固定列3（`rawColumns[2]`：意味/和訳/史実名）**から生成されます。これにより、ヘッダ駆動型パーサの影響を受けずに正確な選択肢が表示されます。

### CSV種類の判定ロジック

**ファイル**: `SimpleWord/QuizComponents/ChoiceCardView.swift`

**CSV種類の定義**:
```swift
private enum CSVType {
    case history    // 中学歴史
    case classical  // 中学古典単語
    case english    // 中学英単語・英熟語・英会話
}
```

**判定方法**:
CSVヘッダラベル（`headerLabels`）の内容から自動判定：
- **中学歴史**: `term`に「年号」、`reading`に「登場人物」、`meaning`に「史実」が含まれる
- **中学古典単語**: `reading`に「ひらがな」が含まれる
- **中学英単語・英会話**: `reading`に「カタカナ」または「発音」が含まれる、または`meaning`に「和訳」が含まれる

---

## 命名規則

- View: `〇〇View.swift`
- ViewModel: `〇〇ViewModel.swift`
- Model: `〇〇Model.swift`

---

## 保守性

- エラー修正や改修は、可能な限り短いセッションで完了できる構造とする
- Viewファイルは項目の内容が分かる日本語コメントを付ける

---

## ファイル分割基準

### 行数の目安
- View ファイル: 200〜300行を超えたら分割を検討
- ViewModel ファイル: 300〜400行を超えたら分割を検討
- 単一の構造体/クラス: 1つの責務に集中させる

### 分割すべきサイン
- スクロールしないと全体が把握できない
- 複数の独立した機能が混在している
- テストが書きにくい構造になっている

### 分割パターン
- **View の部品化**: Components サブディレクトリに UI 部品を分離
- **ViewModel のロジック分離**: Services サブディレクトリにビジネスロジックを分離
- **Model の関心分離**: Models サブディレクトリにデータ構造、バリデーション、変換処理を分離

### ディレクトリ構造例
```
Features/〇〇/
├── 〇〇View.swift (メイン画面)
├── 〇〇ViewModel.swift (メインロジック)
├── Components/ (UI部品)
├── Services/ (ビジネスロジック)
└── Models/ (データ構造)
```

### 注意事項
- 過度な分割は避ける（10行程度のファイルを大量に作らない）
- 密接に関連する処理は同じファイルに置く
- 分割後のファイル名で役割が明確に分かるようにする

---

## 表示順序パターン（各CSV種類）

### パターン1: 中学歴史
**表示順序**: 年号 → 史実名（表示済み） → 解説 → 登場人物 → 関連史実 → 関連分野 & 難易度

**実装関数**: `displayHistoryDetails(_:_:)`

**表示例**:
```
大和政権の成立 ✓

年号: 4世紀頃
解説: 弥生時代後期に各地の豪族が力を持つようになる...
登場人物: 大和朝廷の豪族たち
関連史実: 古墳文化・律令以前の統合過程
関連分野: その他  難易度: 2
```

**特徴**:
- 史実名（meaning）はメインテキストで既に表示されているため詳細では省略
- 時系列がわかる「年号」を最初に表示
- 「解説」で史実の背景を説明
- 「登場人物」で関係者を明示

### パターン2: 中学古典単語
**表示順序**: 語句 → 発音 → 意味（表示済み） → 用法 → 関連語 → 関連分野 & 難易度

**実装関数**: `displayClassicalDetails(_:_:)`

**表示例**:
```
しみじみとした情趣 ✓

語句: あはれ
読み: あはれ
用法: 感動詞「あはれ」から
関連語: 「もののあはれ」
関連分野: 文学・美学  難易度: 2
```

**特徴**:
- 意味（meaning）はメインテキストで既に表示されているため詳細では省略
- 「語句」と「読み」を並べて表示（古典単語の学習に重要）
- 「用法」として語源等解説を表示（古典では用法が重要）

### パターン3: 中学英単語・英熟語・英会話
**表示順序**: 語句(発音) → 和訳（表示済み） → 語源等解説 → 関連語と意味 → 関連分野 & 難易度

**実装関数**: `displayEnglishDetails(_:_:)`

**表示例**:
```
こんにちは！ ✓

語句: Hello! (ハロー)
語源等解説: 古英語の挨拶語
関連語と意味: Hi / やあ
関連分野: 挨拶  難易度: 1
```

**特徴**:
- 和訳（meaning）はメインテキストで既に表示されているため詳細では省略
- **発音を語句の直後に括弧付きで表示**（英語学習に重要）
- 「語源等解説」で単語の由来を説明
- 「関連語と意味」で類似表現を学習

---

## 🎯 共通仕様

### 1. メインテキストとの重複回避
すべてのパターンで、選択肢のメインテキスト（`meaning`）は詳細情報では表示しません。
- **理由**: 情報の重複を避け、画面をすっきりさせるため
- **効果**: ユーザーが必要な情報を見つけやすくなる

### 2. 関連分野と難易度の1行表示
すべてのパターンで、関連分野と難易度を1行にまとめて表示します。
- **理由**: 画面スペースの効率的な利用
- **表示**: `関連分野: その他  難易度: 2`

### 3. 動的なラベル表示
CSVヘッダの実際の列名を優先的に使用します。
- **例**: CSVヘッダが「史実名」なら「史実名:」と表示
- **フォールバック**: ヘッダがない場合はデフォルトラベルを使用

---

## 実装詳細

### ViewBuilder構文の活用
各表示関数は`@ViewBuilder`を使用し、条件付きレンダリングを実現：
```swift
@ViewBuilder
private func displayHistoryDetails(_ questionItem: QuestionItem, _ textColor: Color) -> some View {
    Group {
        if !questionItem.term.isEmpty {
            // 年号を表示
        }
        if !questionItem.etymology.isEmpty {
            // 解説を表示
        }
        // ...
    }
}
```

### 共通ヘルパー関数
`labelFor(_:fallback:)`関数でラベル取得ロジックを共通化：
```swift
private func labelFor(_ key: String, fallback: String) -> String {
    if let header = headerLabels[key], !header.isEmpty {
        return header.hasSuffix(":") ? header : "\(header):"
    }
    return fallback
}
```

### CSV種類の自動判定
ヘッダラベルの内容から自動的にCSV種類を判定し、適切な表示関数を呼び出し：
```swift
let csvType = detectCSVType(from: headerLabels)

switch csvType {
case .history:
    displayHistoryDetails(questionItem, textColor)
case .classical:
    displayClassicalDetails(questionItem, textColor)
case .english:
    displayEnglishDetails(questionItem, textColor)
}
```

---

## 対応するCSVファイル

### 自動判定されるCSV種類

1. **中学歴史** (`history`)
   - ヘッダ: `年号,登場人物,史実名,解説,関連史実,関連分野,難易度`
   - 判定条件: 「年号」「登場人物」「史実」が含まれる

2. **中学古典単語** (`classical`)
   - ヘッダ: `語句,読み（ひらがな）,意味,語源等解説（日本語）,関連語と意味,関連分野,難易度`
   - 判定条件: 「ひらがな」が含まれる

3. **中学英単語・英熟語・英会話** (`english`)
   - ヘッダ: `語句,発音（カタカナ）,和訳,語源等解説（日本語）,関連語（英語）と意味（日本語）,関連分野（日本語）,難易度`
   - 判定条件: 「カタカナ」「発音」「和訳」が含まれる

---

## 拡張性

### 新しいCSV種類の追加

新しいCSV種類を追加する場合：

1. `CSVType` enumに新しいケースを追加
2. `detectCSVType`関数に判定ロジックを追加
3. 専用の表示関数を作成（例: `displayNewTypeDetails`）
4. `switch`文に新しいケースを追加

### カスタマイズ可能な点

- 表示順序の変更（関数内の順序を入れ替え）
- 表示する項目の追加/削除（条件分岐で制御）
- ラベルのカスタマイズ（`labelFor`のフォールバック値を変更）
