import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
import type { Notifier } from '../ui/Notifier';

const writeFile = promisify(fs.writeFile);
const chmod = promisify(fs.chmod);
const exists = promisify(fs.exists);
const rename = promisify(fs.rename);
const lstat = promisify(fs.lstat);
const readlink = promisify(fs.readlink);
const unlink = promisify(fs.unlink);

/**
 * HookInstaller
 *
 * Git hooksã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚
 * - pre-commit hookã®ç”Ÿæˆã¨ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
 * - æ—¢å­˜hookã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
 * - hookã®å‰Šé™¤ã¨ãƒªã‚¹ãƒˆã‚¢
 */
export class HookInstaller {
  private outputChannel: vscode.OutputChannel;
  private notifier?: Notifier;

  constructor(outputChannel: vscode.OutputChannel, notifier?: Notifier) {
    this.outputChannel = outputChannel;
    this.notifier = notifier;
  }

  /**
   * pre-commit hookã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æˆåŠŸãªã‚‰true
   */
  async installPreCommitHook(hooksDir: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, 'pre-commit');
      const backupPath = path.join(hooksDir, 'pre-commit.backup');

      // æ—¢ã« repo æ¨™æº–ã®ãƒªãƒ³ã‚¯æ§‹æˆï¼ˆ.git/hooks/pre-commit -> scripts/pre-commit-ai-guard.shï¼‰ãªã‚‰
      // æ‹¡å¼µã¯ä¸Šæ›¸ãã—ãªã„ï¼ˆãƒªãƒ³ã‚¯å…ˆã® scripts/* ã‚’ç ´å£Šã™ã‚‹ãƒªã‚¹ã‚¯ãŒã‚ã‚‹ãŸã‚ï¼‰
      if (await exists(hookPath)) {
        const isRepoGuardSymlink = await this.isSymlinkToRepoPreCommitGuard(hooksDir, hookPath);
        if (isRepoGuardSymlink) {
          this.outputChannel.appendLine(
            '[HookInstaller] Detected symlink pre-commit -> scripts/pre-commit-ai-guard.sh; leaving it untouched'
          );
          return true;
        }
      }

      // æ—¢å­˜hookã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      if (await exists(hookPath)) {
        this.outputChannel.appendLine('[HookInstaller] Backing up existing pre-commit hook');
        await this.backupHookByRename(hookPath, backupPath);
      }

      // æ–°ã—ã„hookã‚’ç”Ÿæˆ
      const hookContent = this.generatePreCommitHook();
      await this.safeWriteHookFile(hookPath, hookContent);

      // å®Ÿè¡Œæ¨©é™ã‚’ä»˜ä¸ (Unixç³»ã®ã¿)
      if (process.platform !== 'win32') {
        await chmod(hookPath, 0o755);
      }

      this.outputChannel.appendLine('[HookInstaller] Pre-commit hook installed successfully');
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`[HookInstaller] Error installing hook: ${error}`);
      this.notifier?.commandError(`Failed to install pre-commit hook: ${error}`);
      return false;
    }
  }

  /**
   * pre-commit hookã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç”Ÿæˆ
   *
   * @returns hookã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å†…å®¹
   */
  private generatePreCommitHook(): string {
    return `#!/bin/sh
# Servant Pre-Commit Hook
# Auto-generated by Servant VSCode Extension

echo "ğŸ” Running Servant validation..."

# Prefer repo-local guard script if available (works even when VS Code CLI is not installed)
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || true)
GUARD_SCRIPT="$REPO_ROOT/scripts/pre-commit-ai-guard.sh"

if [ -n "$REPO_ROOT" ] && [ -f "$GUARD_SCRIPT" ]; then
  echo "ğŸ›¡ï¸  Found repo-local guard: $GUARD_SCRIPT"
  if [ -x "$GUARD_SCRIPT" ]; then
    "$GUARD_SCRIPT"
    GUARD_EXIT=$?
  else
    # File exists but isn't executable (e.g., on fresh clones)
    sh "$GUARD_SCRIPT"
    GUARD_EXIT=$?
  fi

  if [ $GUARD_EXIT -ne 0 ]; then
    exit $GUARD_EXIT
  fi

  echo "âœ… Repo guard passed."
fi

# VSCodeã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦æ¤œè¨¼ã‚’å®Ÿè¡Œ
# æ³¨: VSCodeãŒèµ·å‹•ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™

if ! command -v code >/dev/null 2>&1; then
  # If repo guard exists and passed, do not block commit just because VS Code CLI is missing.
  if [ -n "$REPO_ROOT" ] && [ -f "$GUARD_SCRIPT" ]; then
    echo "â„¹ï¸  VS Code CLI (code) not found; skipping VS Code validation (repo guard already passed)."
    exit 0
  fi

  echo "âŒ VS Code CLI (code) not found."
  echo "ğŸ’¡ Install/enable 'code' command in PATH or run validation manually:"
  echo "   - VS Code Command Palette: 'Servant: Validate Before Commit'"
  exit 1
fi

# æ–°ã—ã„IDã‚’å„ªå…ˆã—ã€äº’æ›ã®ãŸã‚æ—§IDã‚‚è©¦ã™
code --command servant.validateBeforeCommit >/dev/null 2>&1 || code --command instructionsValidator.validateBeforeCommit

EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
  echo "âŒ Servant validation failed!"
  echo "ğŸ’¡ Fix the violations using Quick Fix in VSCode, then try committing again."
  exit 1
fi

echo "âœ… Servant validation passed!"
exit 0
`;
  }

  /**
   * commit-msg hookã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æˆåŠŸãªã‚‰true
   */
  async installCommitMsgHook(hooksDir: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, 'commit-msg');
      const backupPath = path.join(hooksDir, 'commit-msg.backup');

      // æ—¢å­˜hookã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      if (await exists(hookPath)) {
        this.outputChannel.appendLine('[HookInstaller] Backing up existing commit-msg hook');
        await this.backupHookByRename(hookPath, backupPath);
      }

      // æ–°ã—ã„hookã‚’ç”Ÿæˆ
      const hookContent = this.generateCommitMsgHook();
      await this.safeWriteHookFile(hookPath, hookContent);

      // å®Ÿè¡Œæ¨©é™ã‚’ä»˜ä¸
      if (process.platform !== 'win32') {
        await chmod(hookPath, 0o755);
      }

      this.outputChannel.appendLine('[HookInstaller] Commit-msg hook installed successfully');
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`[HookInstaller] Error installing commit-msg hook: ${error}`);
      return false;
    }
  }

  /**
   * commit-msg hookã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç”Ÿæˆ
   */
  private generateCommitMsgHook(): string {
    return `#!/bin/sh
# Servant Commit-Msg Hook
# Auto-generated by Servant VSCode Extension

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

echo "ğŸ“ Checking commit message..."

# Conventional Commitså½¢å¼ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
# å½¢å¼: type(scope): message
# ä¾‹: feat(ui): add new button component

if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf)(\\(.+\\))?: .+"; then
  echo "âš ï¸  Commit message doesn't follow Conventional Commits format"
  echo "ğŸ’¡ Recommended format: type(scope): message"
  echo "   Example: feat(ui): add new button component"
  echo ""
  echo "   Types: feat, fix, docs, style, refactor, test, chore, perf"
  # è­¦å‘Šã®ã¿ã€ã‚³ãƒŸãƒƒãƒˆã¯è¨±å¯
fi

echo "âœ… Commit message validation passed"
exit 0
`;
  }

  /**
   * hooksã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒªã‚¹ãƒˆã‚¢ï¼‰
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @param hookName - hookã®åå‰ï¼ˆ'pre-commit'ã¾ãŸã¯'commit-msg'ï¼‰
   */
  async uninstallHook(hooksDir: string, hookName: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, hookName);
      const backupPath = path.join(hooksDir, `${hookName}.backup`);

      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå­˜åœ¨ã™ã‚Œã°å¾©å…ƒ
      if (await exists(backupPath)) {
        this.outputChannel.appendLine(`[HookInstaller] Restoring ${hookName} from backup`);
        await this.restoreHookByRename(hookPath, backupPath);
      } else {
        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒãªã‘ã‚Œã°hookã‚’å‰Šé™¤
        this.outputChannel.appendLine(`[HookInstaller] Removing ${hookName}`);
        if (await exists(hookPath)) {
          await unlink(hookPath);
        }
      }

      this.outputChannel.appendLine(`[HookInstaller] ${hookName} uninstalled successfully`);
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`[HookInstaller] Error uninstalling hook: ${error}`);
      return false;
    }
  }

  /**
   * hookãŒæ—¢ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @param hookName - hookã®åå‰
   * @returns ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãªã‚‰true
   */
  async isHookInstalled(hooksDir: string, hookName: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, hookName);
      if (!await exists(hookPath)) {
        return false;
      }

       // repo æ¨™æº–ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ§‹æˆã‚’ã€Œã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã€ã¨è¦‹ãªã™
       if (hookName === 'pre-commit') {
         const isRepoGuardSymlink = await this.isSymlinkToRepoPreCommitGuard(hooksDir, hookPath);
         if (isRepoGuardSymlink) {
           return true;
         }
       }

      const content = await promisify(fs.readFile)(hookPath, 'utf8');
      // Servant/Instructions Validatorã®ã‚·ã‚°ãƒãƒãƒ£ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå¾Œæ–¹äº’æ›ï¼‰
      return content.includes('Servant VSCode Extension') || content.includes('Instructions Validator');
    } catch {
      return false;
    }
  }

  private async isSymlinkToRepoPreCommitGuard(hooksDir: string, hookPath: string): Promise<boolean> {
    try {
      const st = await lstat(hookPath);
      if (!st.isSymbolicLink()) return false;

      const linkTarget = await readlink(hookPath);
      const hooksDirReal = hooksDir;
      const repoRoot = path.resolve(hooksDirReal, '..', '..');
      const expected = path.join(repoRoot, 'scripts', 'pre-commit-ai-guard.sh');
      const resolved = path.resolve(path.dirname(hookPath), linkTarget);
      return path.normalize(resolved) === path.normalize(expected);
    } catch {
      return false;
    }
  }

  private async backupHookByRename(hookPath: string, backupPath: string): Promise<void> {
    // æ—¢å­˜ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒã‚ã‚Œã°ä¸Šæ›¸ãï¼ˆå†…å®¹ã‚ˆã‚Šã€Œç¾ç‰©ã€ã‚’æ®‹ã™ï¼‰
    if (await exists(backupPath)) {
      try {
        await unlink(backupPath);
      } catch {
        // ignore
      }
    }
    await rename(hookPath, backupPath);
  }

  private async restoreHookByRename(hookPath: string, backupPath: string): Promise<void> {
    if (await exists(hookPath)) {
      try {
        const st = await lstat(hookPath);
        if (st.isSymbolicLink()) {
          await unlink(hookPath);
        } else {
          await unlink(hookPath);
        }
      } catch {
        // ignore
      }
    }

    await rename(backupPath, hookPath);
    if (process.platform !== 'win32') {
      await chmod(hookPath, 0o755);
    }
  }

  private async safeWriteHookFile(hookPath: string, content: string): Promise<void> {
    // hookPath ãŒã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ãƒªãƒ³ã‚¯å…ˆã‚’æ›¸ãæ›ãˆãªã„ã‚ˆã†ãƒªãƒ³ã‚¯ã‚’è§£é™¤ã—ã¦ã‹ã‚‰æ›¸ãè¾¼ã‚€
    if (await exists(hookPath)) {
      try {
        const st = await lstat(hookPath);
        if (st.isSymbolicLink()) {
          await unlink(hookPath);
        }
      } catch {
        // ignore
      }
    }

    await writeFile(hookPath, content, 'utf8');
  }

  /**
   * å…¨ã¦ã®hooksã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns å…¨ã¦ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒæˆåŠŸã—ãŸã‚‰true
   */
  async installAllHooks(hooksDir: string): Promise<boolean> {
    const config = vscode.workspace.getConfiguration('servant');
    const legacyConfig = vscode.workspace.getConfiguration('instructionsValidator');

    const installPreCommit =
      config.get<boolean>('preCommit.enabled') ??
      legacyConfig.get<boolean>('preCommit.enabled', true);
    const installCommitMsg =
      config.get<boolean>('commitMsg.enabled') ??
      legacyConfig.get<boolean>('commitMsg.enabled', false);

    let success = true;

    if (installPreCommit) {
      success = await this.installPreCommitHook(hooksDir) && success;
    }

    if (installCommitMsg) {
      success = await this.installCommitMsgHook(hooksDir) && success;
    }

    return success;
  }

  /**
   * å…¨ã¦ã®hooksã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns å…¨ã¦ã®ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒæˆåŠŸã—ãŸã‚‰true
   */
  async uninstallAllHooks(hooksDir: string): Promise<boolean> {
    let success = true;
    success = await this.uninstallHook(hooksDir, 'pre-commit') && success;
    success = await this.uninstallHook(hooksDir, 'commit-msg') && success;
    return success;
  }
}
