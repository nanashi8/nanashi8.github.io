import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
import type { Notifier } from '../ui/Notifier';

const writeFile = promisify(fs.writeFile);
const readFile = promisify(fs.readFile);
const chmod = promisify(fs.chmod);
const exists = promisify(fs.exists);

/**
 * HookInstaller
 *
 * Git hooksã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚
 * - pre-commit hookã®ç”Ÿæˆã¨ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
 * - æ—¢å­˜hookã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
 * - hookã®å‰Šé™¤ã¨ãƒªã‚¹ãƒˆã‚¢
 */
export class HookInstaller {
  private outputChannel: vscode.OutputChannel;
  private notifier?: Notifier;

  constructor(outputChannel: vscode.OutputChannel, notifier?: Notifier) {
    this.outputChannel = outputChannel;
    this.notifier = notifier;
  }

  /**
   * pre-commit hookã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æˆåŠŸãªã‚‰true
   */
  async installPreCommitHook(hooksDir: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, 'pre-commit');
      const backupPath = path.join(hooksDir, 'pre-commit.backup');

      // æ—¢å­˜hookã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      if (await exists(hookPath)) {
        this.outputChannel.appendLine('[HookInstaller] Backing up existing pre-commit hook');
        const existingContent = await readFile(hookPath, 'utf8');
        await writeFile(backupPath, existingContent, 'utf8');
      }

      // æ–°ã—ã„hookã‚’ç”Ÿæˆ
      const hookContent = this.generatePreCommitHook();
      await writeFile(hookPath, hookContent, 'utf8');

      // å®Ÿè¡Œæ¨©é™ã‚’ä»˜ä¸ (Unixç³»ã®ã¿)
      if (process.platform !== 'win32') {
        await chmod(hookPath, 0o755);
      }

      this.outputChannel.appendLine('[HookInstaller] Pre-commit hook installed successfully');
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`[HookInstaller] Error installing hook: ${error}`);
      this.notifier?.commandError(`Failed to install pre-commit hook: ${error}`);
      return false;
    }
  }

  /**
   * pre-commit hookã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç”Ÿæˆ
   *
   * @returns hookã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å†…å®¹
   */
  private generatePreCommitHook(): string {
    return `#!/bin/sh
# Servant Pre-Commit Hook
# Auto-generated by Servant VSCode Extension

echo "ğŸ” Running Servant validation..."

# VSCodeã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦æ¤œè¨¼ã‚’å®Ÿè¡Œ
# æ³¨: VSCodeãŒèµ·å‹•ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™

if ! command -v code >/dev/null 2>&1; then
  echo "âŒ VS Code CLI (code) not found."
  echo "ğŸ’¡ Install/enable 'code' command in PATH or run validation manually:"
  echo "   - VS Code Command Palette: 'Servant: Validate Before Commit'"
  exit 1
fi

# æ–°ã—ã„IDã‚’å„ªå…ˆã—ã€äº’æ›ã®ãŸã‚æ—§IDã‚‚è©¦ã™
code --command servant.validateBeforeCommit >/dev/null 2>&1 || code --command instructionsValidator.validateBeforeCommit

EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
  echo "âŒ Servant validation failed!"
  echo "ğŸ’¡ Fix the violations using Quick Fix in VSCode, then try committing again."
  exit 1
fi

echo "âœ… Servant validation passed!"
exit 0
`;
  }

  /**
   * commit-msg hookã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æˆåŠŸãªã‚‰true
   */
  async installCommitMsgHook(hooksDir: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, 'commit-msg');
      const backupPath = path.join(hooksDir, 'commit-msg.backup');

      // æ—¢å­˜hookã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      if (await exists(hookPath)) {
        this.outputChannel.appendLine('[HookInstaller] Backing up existing commit-msg hook');
        const existingContent = await readFile(hookPath, 'utf8');
        await writeFile(backupPath, existingContent, 'utf8');
      }

      // æ–°ã—ã„hookã‚’ç”Ÿæˆ
      const hookContent = this.generateCommitMsgHook();
      await writeFile(hookPath, hookContent, 'utf8');

      // å®Ÿè¡Œæ¨©é™ã‚’ä»˜ä¸
      if (process.platform !== 'win32') {
        await chmod(hookPath, 0o755);
      }

      this.outputChannel.appendLine('[HookInstaller] Commit-msg hook installed successfully');
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`[HookInstaller] Error installing commit-msg hook: ${error}`);
      return false;
    }
  }

  /**
   * commit-msg hookã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç”Ÿæˆ
   */
  private generateCommitMsgHook(): string {
    return `#!/bin/sh
# Servant Commit-Msg Hook
# Auto-generated by Servant VSCode Extension

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

echo "ğŸ“ Checking commit message..."

# Conventional Commitså½¢å¼ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
# å½¢å¼: type(scope): message
# ä¾‹: feat(ui): add new button component

if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf)(\\(.+\\))?: .+"; then
  echo "âš ï¸  Commit message doesn't follow Conventional Commits format"
  echo "ğŸ’¡ Recommended format: type(scope): message"
  echo "   Example: feat(ui): add new button component"
  echo ""
  echo "   Types: feat, fix, docs, style, refactor, test, chore, perf"
  # è­¦å‘Šã®ã¿ã€ã‚³ãƒŸãƒƒãƒˆã¯è¨±å¯
fi

echo "âœ… Commit message validation passed"
exit 0
`;
  }

  /**
   * hooksã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒªã‚¹ãƒˆã‚¢ï¼‰
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @param hookName - hookã®åå‰ï¼ˆ'pre-commit'ã¾ãŸã¯'commit-msg'ï¼‰
   */
  async uninstallHook(hooksDir: string, hookName: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, hookName);
      const backupPath = path.join(hooksDir, `${hookName}.backup`);

      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå­˜åœ¨ã™ã‚Œã°å¾©å…ƒ
      if (await exists(backupPath)) {
        this.outputChannel.appendLine(`[HookInstaller] Restoring ${hookName} from backup`);
        const backupContent = await readFile(backupPath, 'utf8');
        await writeFile(hookPath, backupContent, 'utf8');

        if (process.platform !== 'win32') {
          await chmod(hookPath, 0o755);
        }

        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
        await promisify(fs.unlink)(backupPath);
      } else {
        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒãªã‘ã‚Œã°hookã‚’å‰Šé™¤
        this.outputChannel.appendLine(`[HookInstaller] Removing ${hookName}`);
        if (await exists(hookPath)) {
          await promisify(fs.unlink)(hookPath);
        }
      }

      this.outputChannel.appendLine(`[HookInstaller] ${hookName} uninstalled successfully`);
      return true;
    } catch (error) {
      this.outputChannel.appendLine(`[HookInstaller] Error uninstalling hook: ${error}`);
      return false;
    }
  }

  /**
   * hookãŒæ—¢ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @param hookName - hookã®åå‰
   * @returns ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãªã‚‰true
   */
  async isHookInstalled(hooksDir: string, hookName: string): Promise<boolean> {
    try {
      const hookPath = path.join(hooksDir, hookName);
      if (!await exists(hookPath)) {
        return false;
      }

      const content = await readFile(hookPath, 'utf8');
      // Servant/Instructions Validatorã®ã‚·ã‚°ãƒãƒãƒ£ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå¾Œæ–¹äº’æ›ï¼‰
      return content.includes('Servant VSCode Extension') || content.includes('Instructions Validator');
    } catch {
      return false;
    }
  }

  /**
   * å…¨ã¦ã®hooksã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns å…¨ã¦ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒæˆåŠŸã—ãŸã‚‰true
   */
  async installAllHooks(hooksDir: string): Promise<boolean> {
    const config = vscode.workspace.getConfiguration('servant');
    const legacyConfig = vscode.workspace.getConfiguration('instructionsValidator');

    const installPreCommit =
      config.get<boolean>('preCommit.enabled') ??
      legacyConfig.get<boolean>('preCommit.enabled', true);
    const installCommitMsg =
      config.get<boolean>('commitMsg.enabled') ??
      legacyConfig.get<boolean>('commitMsg.enabled', false);

    let success = true;

    if (installPreCommit) {
      success = await this.installPreCommitHook(hooksDir) && success;
    }

    if (installCommitMsg) {
      success = await this.installCommitMsgHook(hooksDir) && success;
    }

    return success;
  }

  /**
   * å…¨ã¦ã®hooksã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   *
   * @param hooksDir - .git/hooksãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹
   * @returns å…¨ã¦ã®ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒæˆåŠŸã—ãŸã‚‰true
   */
  async uninstallAllHooks(hooksDir: string): Promise<boolean> {
    let success = true;
    success = await this.uninstallHook(hooksDir, 'pre-commit') && success;
    success = await this.uninstallHook(hooksDir, 'commit-msg') && success;
    return success;
  }
}
