# Neural Servant 実装計画
## AI自己評価 × ニューラルネットワーク × 学習伝播

**目標**: サーバントが、AIの処理を自己評価させ、プロジェクトの実装結合をニューラルネットワークとして把握し、最高効率の仕事手順をAIに学習伝播させる。

---

## 📊 現在地（Phase 7完了）

### ✅ 実装済みの基盤
- **依存関係マップ**: ファイル間のインポート関係を抽出（`ProjectContextDB`）
- **違反パターン学習**: 15回サイクルで自動学習、Instructions自動生成（`AdaptiveGuard`）
- **Git履歴解析**: コミット履歴からホットスポット検出（`GitHistoryAnalyzer`）
- **AI向けコンテキスト**: タスクに関連するファイル・警告・例を収集

### 🔧 技術的制約
- VSCode拡張の実行環境（Node.js、VSCode API）
- ローカル処理のみ（クラウドAI連携なし）
- GitHub Copilot APIは限定的（vscode.lm API使用可能）

---

## 🎯 実装計画全体像

### Phase 8: AI自己評価とフィードバックループ（20工程）
AIが自分の処理結果を評価し、次回の改善につなげる基盤を構築。

### Phase 9: ニューラルネットワーク的依存関係グラフ（25工程）
実装の結合を重み付きグラフとして構築し、ノード間の相互作用を学習。

### Phase 10: 学習伝播と最適化エンジン（18工程）
AIに最高効率の作業手順を学習させ、伝播させる機構。

**総工程数: 63工程**（約3-4週間の開発期間を想定）

---

## 📋 Phase 8: AI自己評価とフィードバックループ（20工程）

### 目標
AIが実行したタスク（コード生成、リファクタリング、バグ修正）の結果を自己評価し、次回の改善につなげる。

### 工程詳細

#### 8.1: AI処理追跡システム（5工程）
**目的**: AIがどのファイルをどう変更したかを記録

1. **8.1.1**: `AIActionTracker` クラス作成
   - タスクID、開始/終了時刻、変更ファイル、AIモデル情報を記録
   - `.vscode/ai-action-log.json` にデータ蓄積

2. **8.1.2**: VSCode拡張APIでのファイル変更監視
   - `vscode.workspace.onDidSaveTextDocument` で保存イベントをキャッチ
   - Copilot起動中のみ追跡（通常の手動編集と区別）

3. **8.1.3**: Git diff 統合
   - 変更前後の差分を自動計算
   - 追加行数、削除行数、変更ファイル数を記録

4. **8.1.4**: タスク分類システム
   - `bug-fix`, `feature`, `refactor`, `test`, `docs` に分類
   - コミットメッセージやブランチ名から自動推定

5. **8.1.5**: デバッグログとテスト
   - AIアクション追跡の動作確認
   - 10件のサンプルタスクで検証

---

#### 8.2: AI自己評価メトリクス（8工程）
**目的**: AIの処理結果を定量的に評価

6. **8.2.1**: `AIPerformanceMetrics` 型定義
   - `taskCompletionRate`: タスク完了率（0-100）
   - `violationRate`: 違反発生率（0-100）
   - `codeQualityScore`: コード品質（0-100）
   - `efficiencyScore`: 効率スコア（時間ベース）

7. **8.2.2**: タスク完了率の計算
   - タスク開始→終了までの成功/失敗判定
   - エラーログ、例外発生、コンパイルエラーを検出

8. **8.2.3**: 違反発生率の計算
   - AI変更後の `Servant: Validate Instructions` 実行
   - 変更前後の違反数を比較

9. **8.2.4**: コード品質スコアの計算
   - 行数の変動率（増えすぎ/減りすぎを検出）
   - コメント率、テストカバレッジ（可能な範囲で）
   - ESLint/TSエラー数の増減

10. **8.2.5**: 効率スコアの計算
    - タスク完了までの時間
    - ファイル変更数 vs 時間の比率
    - 振動（同じファイルの繰り返し変更）を検出

11. **8.2.6**: `AIEvaluator` クラス実装
    - 上記メトリクスを統合評価
    - 総合スコア（0-100）を算出

12. **8.2.7**: 評価結果の保存
    - `.vscode/ai-performance-history.json` に蓄積
    - 時系列でスコア推移を記録

13. **8.2.8**: デバッグログとテスト
    - 評価システムの動作確認
    - 既存のAI変更履歴で検証

---

#### 8.3: フィードバックループ（7工程）
**目的**: 評価結果を次回のAI作業に反映

14. **8.3.1**: `FeedbackCollector` クラス作成
    - 評価結果から「良かった点」「悪かった点」を抽出
    - 改善提案を生成

15. **8.3.2**: Instructions 自動生成の拡張
    - 既存の `AdaptiveGuard` に AI評価を統合
    - 「AIが頻繁に失敗するパターン」を自動検出

16. **8.3.3**: AI向けコンテキスト強化
    - `ProjectContextDB.collectContextForAI()` に評価履歴を追加
    - 「このタスクは過去に失敗率が高い」などの警告

17. **8.3.4**: vscode.lm API 統合（実験的）
    - GitHub Copilot Chat に評価結果を通知
    - 「前回のリファクタリングで違反が増えたので注意」などのヒント

18. **8.3.5**: ユーザー通知機能
    - AIスコアが低下した場合に警告
    - 改善提案をポップアップで表示

19. **8.3.6**: 設定オプション追加
    - `servant.ai.selfEvaluation.enabled`
    - `servant.ai.selfEvaluation.notifyOnLowScore`
    - `servant.ai.selfEvaluation.minimumScore`

20. **8.3.7**: Phase 8 総合テスト
    - AI自己評価システム全体の動作確認
    - 実プロジェクトで1週間運用テスト

---

## 📋 Phase 9: ニューラルネットワーク的依存関係グラフ（25工程）

### 目標
プロジェクトの実装結合を「ニューラルネットワーク」として表現し、ノード（ファイル）間の相互作用を学習。

### 工程詳細

#### 9.1: 重み付き依存関係グラフ（8工程）
**目的**: 単純な依存関係を「重み」を持つグラフに拡張

21. **9.1.1**: `DependencyNode` 型定義
    - `file`: ファイルパス
    - `weight`: 重要度（0-1、情報ゲインベース）
    - `entropy`: エントロピー（コードの複雑さ、0-1）
    - `informationGain`: 理解することで得られる価値（0-1）
    - `pageRankScore`: 依存関係グラフでのPageRank（0-1）
    - `activationLevel`: 活性化レベル（0-1、時間減衰）
    - `connections`: 接続先とその重み `Map<string, EdgeWeight>`
    - `clusterCoefficient`: クラスタ係数（周辺ファイルとの結合密度）

**EdgeWeight型**:
    - `importStrength`: インポート関係の強さ（0-1）
    - `coChangeRate`: 同時変更率（0-1）
    - `mutualInformation`: 相互情報量（0-1）
    - `semanticSimilarity`: コード内容の類似度（0-1）
    - `taskRelevance`: タスクでの関連度（0-1）
    - `totalWeight`: 総合重み（重み付き合計）

22. **9.1.2**: 重要度（weight）の計算
    - **変更頻度**: Git履歴から（高頻度 = 不安定 = 低重要度）
    - **依存数**: インポート/インポート元の数（多い = ハブ = 高重要度）
    - **違反発生頻度**: AdaptiveGuardのデータ（高頻度 = リスク大）
    - **エントロピー**: コードの複雑さ `H = -Σ p(pattern) * log2(p(pattern))`
    - **情報ゲイン**: このファイルを理解することで得られる全体理解度
    - **PageRankスコア**: 依存関係グラフでのPageRank（Googleのアルゴリズム）

23. **9.1.3**: 活性化レベル（activationLevel）の計算
    - **最近の使用頻度**: Git履歴の直近30日
    - **AIによる変更頻度**: 自動生成・リファクタリング回数
    - **ユーザーの閲覧頻度**: VSCode のファイル開閉イベント（可能な範囲で）
    - **時間減衰**: 古い活動は指数関数的に減衰 `activation = Σ e^(-λt)`

24. **9.1.4**: 接続の重み計算（情報理論ベース）
    - **インポート強度**: 直接インポート 0.8、間接 0.3
    - **同時変更率**: `P(A変更 | B変更)` をGit履歴から計算
    - **相互情報量**: `I(A;B) = H(A) + H(B) - H(A,B)`
    - **意味的類似度**: コード内容のコサイン類似度（TF-IDF/埋め込みベクトル）
    - **タスク関連度**: 同じタスクで変更される確率
    - **総合重み**: `w = α*import + β*coChange + γ*mutualInfo + δ*semantic`

25. **9.1.5**: `NeuralDependencyGraph` クラス実装
    - `buildGraph()`: グラフ構築
    - `getNode(file)`: ノード取得
    - `getConnections(file)`: 接続取得

26. **9.1.6**: グラフの可視化（JSON出力）
    - `.vscode/neural-graph.json` に保存
    - Mermaid形式での図示も生成

27. **9.1.7**: グラフの更新機構
    - Git commit 後に自動更新
    - AI作業後に重みを再計算

28. **9.1.8**: デバッグログとテスト
    - グラフ構築の動作確認
    - 実プロジェクトで構造検証

---

#### 9.2: ノード間の相互作用学習（9工程）
**目的**: ニューラルネットワーク的に「伝播」を実装

29. **9.2.1**: 伝播アルゴリズムの設計
    - 順伝播: タスク→関連ファイルの推論
    - 逆伝播: 失敗→原因ファイルの推定

30. **9.2.2**: 順伝播（Forward Propagation）実装
    - 起点ファイルから接続の重みに基づいて「影響度」を計算
    - 深さ3まで伝播（A→B→C→D）

31. **9.2.3**: 活性化関数の実装
    - シグモイド関数で活性化レベルを計算
    - `activation = 1 / (1 + exp(-weighted_sum))`

32. **9.2.4**: 逆伝播（Backpropagation）実装
    - 違反発生時、原因ファイルを逆算
    - 重みを更新（失敗したパスの重みを減少）

33. **9.2.5**: 学習率の設定
    - `learningRate = 0.01`（小さく調整）
    - 過学習防止のための正則化

34. **9.2.6**: エポックベースの学習
    - 10回の違反で1エポック
    - 重みの収束を監視

35. **9.2.7**: `NeuralLearningEngine` クラス実装
    - `propagateForward(startFile, task)`: 順伝播
    - `propagateBackward(failureFile, error)`: 逆伝播
    - `updateWeights(feedback)`: 重み更新

36. **9.2.8**: 学習履歴の記録
    - `.vscode/neural-learning-history.json`
    - エポックごとの重み変動を保存

37. **9.2.9**: デバッグログとテスト
    - 伝播アルゴリズムの動作確認
    - シミュレーションで学習効果を検証

---

#### 9.3: AIへのグラフ提供（8工程）
**目的**: ニューラルグラフをAIが理解できる形式で提供

38. **9.3.1**: グラフのサマリー生成
    - 「重要なノード TOP10」
    - 「影響が大きい接続 TOP10」
    - 「リスクの高いクラスタ」

39. **9.3.2**: タスク向け経路推論
    - `inferOptimalPath(task)`: タスクに最適なファイル順序
    - 活性化レベルと重みから最短経路を計算

40. **9.3.3**: リスク予測
    - 「このファイルを変更すると他の5ファイルに影響」
    - 「このファイルは過去に失敗率が高い」

41. **9.3.4**: `ProjectContextDB` 統合
    - `collectContextForAI()` にグラフ情報を追加
    - `neuralContext` フィールドを追加

42. **9.3.5**: 自然言語での説明生成
    - 「src/main.tsは重要度が高く、5ファイルと強く結合しています」
    - 「このタスクは src/utils/ から始めるのが効率的です」

43. **9.3.6**: vscode.lm API 連携（実験的）
    - Copilot Chat にグラフ情報を提供
    - 「このファイルを変更する場合の推奨手順」を通知

44. **9.3.7**: 設定オプション追加
    - `servant.neural.enabled`
    - `servant.neural.propagationDepth`
    - `servant.neural.learningRate`

45. **9.3.8**: Phase 9 総合テスト
    - ニューラルグラフの動作確認
    - 実プロジェクトで1週間運用テスト

---

## 📋 Phase 10: 学習伝播と最適化エンジン（18工程）

### 目標
AIに「最高効率の仕事手順」を学習させ、プロジェクト全体に伝播。

### 工程詳細

#### 10.1: 作業手順の学習（7工程）
**目的**: 成功パターンを学習し、再現可能にする

46. **10.1.1**: `WorkflowPattern` 型定義
    - `taskType`: タスク種別（bug-fix, feature, etc）
    - `sequence`: ファイル変更の順序
    - `successRate`: 成功率
    - `avgTime`: 平均所要時間
    - `violations`: 違反発生率

47. **10.1.2**: 成功パターンの抽出
    - Git履歴から「成功したタスク」を解析
    - コミットメッセージ＋違反なし＋短時間で完了

48. **10.1.3**: 失敗パターンの抽出
    - 「失敗したタスク」を解析
    - 違反発生＋長時間＋複数回の修正

49. **10.1.4**: パターンのクラスタリング
    - 類似タスクをグループ化
    - K-means法または階層的クラスタリング

50. **10.1.5**: `WorkflowLearner` クラス実装
    - `learnFromHistory()`: 履歴から学習
    - `classifyTask(task)`: タスクを分類
    - `suggestWorkflow(task)`: 推奨手順を提案

51. **10.1.6**: 学習データの蓄積
    - `.vscode/workflow-patterns.json`
    - 時系列で学習効果を記録

52. **10.1.7**: デバッグログとテスト
    - ワークフロー学習の動作確認
    - 既存履歴で検証

---

#### 10.2: 最適化エンジン（6工程）
**目的**: リアルタイムで最高効率の手順を提案

53. **10.2.1**: `OptimizationEngine` クラス実装
    - `optimizeTaskOrder(files)`: ファイル変更順序の最適化
    - `predictRisk(file)`: リスク予測
    - `suggestNextAction(currentState)`: 次のアクション提案

54. **10.2.2**: 最適化アルゴリズム
    - ニューラルグラフの重み
    - ワークフローパターン
    - AI自己評価履歴
    - → 総合スコアで順序を決定

55. **10.2.3**: リアルタイム提案システム
    - ファイル編集中に「次はこのファイルを編集すべき」と通知
    - 違反リスクの高い操作を警告

56. **10.2.4**: A/Bテスト機構
    - 最適化あり/なしで効果を比較
    - 統計的に有意な改善を検証

57. **10.2.5**: 設定オプション追加
    - `servant.optimization.enabled`
    - `servant.optimization.realTimeHints`
    - `servant.optimization.riskThreshold`

58. **10.2.6**: デバッグログとテスト
    - 最適化エンジンの動作確認
    - シミュレーションで効果測定

---

#### 10.3: 学習伝播システム（5工程）
**目的**: 学習結果をAI・チーム・プロジェクト全体に伝播

59. **10.3.1**: AI向け学習データの生成
    - `.aitk/instructions/neural-optimized-workflows.instructions.md`
    - 「このプロジェクトでの推奨作業手順」を自動生成

60. **10.3.2**: vscode.lm API 統合
    - Copilot に学習結果を常時提供
    - 「このタスクは過去に平均15分で完了しています」などのヒント

61. **10.3.3**: チーム共有機能（オプション）
    - `.vscode/neural-graph.json` をGitで共有
    - チームメンバー全員が学習結果を利用

62. **10.3.4**: 継続的学習システム
    - 毎日自動で学習を実行
    - 新しいコミットから常に最新パターンを抽出

63. **10.3.5**: Phase 10 総合テスト
    - 学習伝播システム全体の動作確認
    - 実プロジェクトで2週間運用テスト

---

## 🎯 実装優先順位

### 最優先（MVP: Minimum Viable Product）
1. **Phase 8.1-8.2**: AI追跡と自己評価（工程1-13）
2. **Phase 9.1**: 重み付きグラフ（工程21-28）
3. **Phase 10.1**: 作業手順学習（工程46-52）

### 高優先
4. **Phase 8.3**: フィードバックループ（工程14-20）
5. **Phase 9.2**: ノード間相互作用（工程29-37）

### 中優先
6. **Phase 9.3**: AIへのグラフ提供（工程38-45）
7. **Phase 10.2**: 最適化エンジン（工程53-58）

### 実験的
8. **Phase 10.3**: 学習伝播（工程59-63）

---

## 📅 推奨実装スケジュール

### Week 1-2: Phase 8（AI自己評価）
- AI処理追跡（5工程）
- 自己評価メトリクス（8工程）
- フィードバックループ（7工程）

### Week 3-4: Phase 9.1-9.2（ニューラルグラフ基礎）
- 重み付きグラフ（8工程）
- ノード間相互作用（9工程）

### Week 5-6: Phase 9.3 + Phase 10.1（統合と学習）
- AIへのグラフ提供（8工程）
- 作業手順学習（7工程）

### Week 7-8: Phase 10.2-10.3（最適化と伝播）
- 最適化エンジン（6工程）
- 学習伝播（5工程）
- 総合テストと調整

---

## 🔧 技術的考慮事項

### パフォーマンス
- ニューラルグラフの計算はバックグラウンドで実行
- キャッシュを活用（`.vscode/neural-cache/`）
- ファイル数が多い場合は段階的にインデックス化

### 拡張性
- プラグインアーキテクチャで機能追加可能に
- AIモデルは差し替え可能（vscode.lm API → 他のAPI）
- データ形式はJSON（外部ツールでも解析可能）

### セキュリティ
- 学習データはローカルのみ（クラウド送信なし）
- `.vscode/` ディレクトリは `.gitignore` に追加を推奨
- チーム共有は明示的にオプトイン

### 互換性
- 既存のPhase 1-7機能と完全互換
- 段階的に有効化可能（各Phase独立）
- 無効化しても既存機能に影響なし

---

## 📊 期待される効果

### Phase 8完了時
- AIの失敗率を30%削減
- 違反発生の早期検出
- 継続的な品質改善ループ

### Phase 9完了時
- プロジェクト構造の深い理解
- リスク予測精度 80%以上
- 影響範囲の自動特定

### Phase 10完了時
- 作業時間を平均20%短縮
- AIによる最適な作業順序の提案
- チーム全体の生産性向上

---

## 🎉 最終ゴール

**「Servantが、AIを教育し、プロジェクトを理解し、最高効率の作業をAIに伝播させる」**

- AIは過去の失敗から学び、同じ間違いを繰り返さない
- プロジェクトの実装結合を「ニューラルネットワーク」として理解
- 最適な作業手順を自動提案し、常に改善し続ける

**これが実現すれば、Servantは真の意味で「育つAIサーバント」になる。**
