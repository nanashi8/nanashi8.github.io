<!--
    ファイル: 参考資料/横断検索と補修モード診断ガイド.md
    目的: 学習モードとバッチサイズの関係、Quiz の補修モードが表示されない原因とデバッグ手順、横断検索の利点/欠点をまとめる。
    作成者: 自動生成（GitHub Copilot 風）
    注意: このドキュメントはエンジニアが現地で実行・検証するための手順とコマンドを含みます。
-->

# 横断検索と補修モード診断ガイド

概要
- 目的: QuizView に「補修モード」が表示されない問題の原因特定と解決手順を一箇所にまとめる。
- 対象読者: iOS (Swift / SwiftUI) 開発者、永続化（UserDefaults / CoreData）や ViewModel の挙動を確認したい人。

---

## 目次
1. 要約
2. 背景知識: 学習モードとバッチサイズの関係（参考）
3. 現象: 補修モードを保存しても QuizView に反映されない
4. 考えられる原因（優先度順）
5. 優先確認チェックリスト（即実行）
6. 詳細なデバッグ手順（UserDefaults / SwiftUI / CoreData 別）
7. 横断検索（workspace-wide search）の実行方法と注意点
8. 推奨される最小修正例とログ追加ポイント
9. 次のアクション / 推奨ワークフロー

---

## 1. 要約
- 多くの場合、表示不整合は「保存処理は正しく行われているが、View がその変更を購読していない」か、「保存先（キー/型）が View 側と一致していない」ことに起因します。
- SwiftUI なら `ObservableObject` + `@Published` と `@StateObject` / `@ObservedObject` / `@EnvironmentObject` の組合せを正しく使うことが重要です。
- CoreData を使う場合は、背景コンテキストからの保存後に main コンテキストへマージする（または通知して更新する）必要があります。

---

## 2. 背景知識: 学習モードとバッチサイズの関係（簡潔）
（この節は本件の直接的修正ではなく理解の補助として短くまとめる）
- `model.train()` と `model.eval()` の違い: Dropout の ON/OFF、BatchNorm の統計参照方法が切り替わる。
- バッチサイズの影響: 小バッチは統計が不安定、BatchNorm に影響。大バッチは安定だが一般化に影響がある。
- 実務: BatchNorm の問題があるなら `GroupNorm` 等に代替するか、SyncBatchNorm を検討する。

---

## 3. 現象
- 操作: 出題設定で「補修モード」を有効にして保存する（アプリ上の設定画面など）。
- 期待: `QuizView` に "補修モード: ON" と表示される。
- 実際: 保存は成功している（または成功している可能性あり）にも関わらず `QuizView` 側が ON を表示しない。

---

## 4. 考えられる原因（優先度順）
1. 保存キー／型の不一致（例: 保存先は `Bool` だが View 側は `Int`／`enum` を参照している）。
2. 設定オブジェクトが `ObservableObject` になっていない、または `@Published` が使われていない。
3. `QuizView` が値の変更を購読していない（`@StateObject` ではなく `@ObservedObject` を誤用／親から正しく注入されていない）。
4. 保存が別スレッド／別永続化コンテキストで行われたが、メインコンテキストへ変更が反映されていない（CoreData の場合）。
5. 表示がキャッシュ・静的な状態で作られており、再評価されない（`body` が再評価されないケース）。
6. 保存処理自体が失敗している（例外／エラーが握りつぶされている）。
7. 複数の設定ソースが存在し、異なる箇所を書き換えている（キーの重複や名前衝突）。

---

## 5. 優先確認チェックリスト（即実行）
- [ ] 保存時のキー名と読み取り時のキー名が完全一致しているか（大文字小文字含む）。
- [ ] 保存される値の型が期待どおりか（Bool / Int / String / enum の rawValue 等）。
- [ ] `Settings` オブジェクトが `ObservableObject` で `@Published` を付与しているか。
- [ ] `QuizView` は正しい注入方法で `Settings` を購読しているか（親で `@StateObject` を作成し、子で `@ObservedObject` を受け取る、または `@EnvironmentObject` を利用する）。
- [ ] CoreData を使っているなら、背景保存の後に mainContext でマージされているか確認。
- [ ] 保存処理にログを埋めて、実際に保存が成功しているかを確認する（print / os_log 等）。
- [ ] アプリ起動時に UserDefaults（や DB）から期待値が読み込まれているかを確認する。

---

## 6. 詳細なデバッグ手順
ここでは典型的な実装パターン別に、最小限のログ・確認ポイントを示す。

### A. UserDefaults を使っている場合
1. 保存時に必ずログを出す:

```swift
// 例: SettingsStore.swift
print("[SettingsStore] saveRemediationMode: \(isRemediationMode) -> saving to UserDefaults key=\(Self.key)")
UserDefaults.standard.set(isRemediationMode, forKey: Self.key)
```

2. QuizView 側 onAppear や ViewModel の init で UserDefaults を読んでログを出す:

```swift
let val = UserDefaults.standard.bool(forKey: "isRemediationMode")
print("[QuizView] onAppear UserDefaults isRemediationMode=\(val)")
```

3. 値の型が期待通りか確認（UserDefaults では `nil` と `false` の区別に注意）。

4. タイミング問題: 保存直後に別スレッドで読み出している場合、主スレッドでの動作確認も行う。

### B. SwiftUI の購読パターン確認
1. 親で `@StateObject var settings = SettingsStore()` を作っているか。子で `@ObservedObject var settings: SettingsStore` を受け取るか、あるいは `@EnvironmentObject` を利用する。
2. `@StateObject` を View のイニシャライザ内で繰り返し生成してしまうと購読がリセットされるので注意。
3. デバッグ用に ViewModel に `sink` を追加して値変化をログ化する。

### C. CoreData を使っている場合
1. 背景コンテキストで保存するなら、保存後に mainContext にマージするか、通知を受け取って `mergeChanges(fromContextDidSave:)` を呼ぶ。

```swift
NotificationCenter.default.addObserver(forName: .NSManagedObjectContextDidSave, object: backgroundContext, queue: .main) { note in
    mainContext.mergeChanges(fromContextDidSave: note)
}
```

2. 保存エラーが握りつぶされていないか確認する（catch 節でログを出す）。
3. フェッチ結果がキャッシュされている場合は再フェッチを行う。

---

## 7. 横断検索（workspace-wide search）の実行方法と注意点
横断検索が有効なケース: 設定フラグが複数箇所で使われている、キー名がライブラリや他ファイルで上書きされている疑いがある、またはどのファイルが参照しているか分からない場合。

推奨コマンド（プロジェクトルートで実行）:

```bash
# ripgrep がある場合（推奨）
rg "isRemediationMode|補修モード|remediation" --hidden

# なければ grep
grep -Rn "isRemediationMode\|補修モード\|remediation" .
```

注意点（デメリット）:
- 機密情報や大量のノイズが出る可能性があるため、検索範囲を限定する（例: `Sources/` や `SimpleWord/`）こと。
- バイナリやビルド成果物、`.git` 内は除外する。
- 検索実行前にチームの同意が必要な場合がある。

---

## 8. 推奨される最小修正例とログ追加ポイント
- `SettingsStore`:
  - `@Published var isRemediationMode: Bool` を用意し、`didSet` で UserDefaults に保存しログを出す。
- `QuizViewModel`:
  - `SettingsStore` を注入して `$isRemediationMode` を購読、受け取った値は main スレッドで View 更新用に公開する。
- `QuizView`:
  - 親で `@StateObject var settings = SettingsStore()` を作成し、子に `settings` を渡す（`@ObservedObject` または `@EnvironmentObject`）。

ログ箇所（最低限）:
- 保存処理（保存前・保存後）
- ViewModel の受信ハンドラ
- View の `onAppear`（初期読み込み状態）

---

## 9. 次のアクション / 推奨ワークフロー
1. このドキュメントに書かれたコマンドを使い、該当フラグに関する横断検索を実行する（出力を共有してください）。
2. 見つかったファイルのうち `SettingsStore` / `QuizViewModel` / `QuizView` / `PersistenceController` を送ってください。こちらで具体的な修正案を作成します。
3. 実装修正後は、ログが期待どおり出ることを確認し、View の描画が変わるかを検証してください。

---

## 付録: よくあるミス（チェックリスト形式）
- `UserDefaults` のキーを文字列リテラルで複数個所書いている（定数化していない）。
- `@StateObject` を複数の View で再初期化してしまっている。
- CoreData の background save を main context にマージしていない。
- 保存エラーが `try?` で握りつぶされている。

---

ドキュメント作成日: 2025-10-24
