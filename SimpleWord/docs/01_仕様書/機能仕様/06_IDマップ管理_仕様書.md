# IDマップ管理（単語識別子の整合性管理）

**最終更新: 2025-10-19**

この文書は、「IDマップ管理」機能の編集・実装ガイドです。

## 概要

### 何を実現しているか
- 各単語に一意のUUID（識別子）を割り当て
- CSV更新後も同じ単語には同じIDを維持
- 学習履歴・成績データとの紐付けを保証
- IDの整合性チェックと修復

### なぜ必要か
- CSV行の順序が変わっても学習履歴が保持される
- 単語の追加・削除があっても既存の成績が維持される
- 複数CSVで同じ単語が出ても個別に管理できる

## 画面構成

### ID一覧
```
┌─────────────────────────────────┐
│ example                          │
│ ID: 550e8400-e29b-41d4-a716-... │
│ 出題回数: 5回                    │
├─────────────────────────────────┤
│ practice                         │
│ ID: 6ba7b810-9dad-11d1-80b4-... │
│ 出題回数: 3回                    │
└─────────────────────────────────┘
```

### 整合性チェック
```
[チェック実行]
✓ 重複ID: なし
✓ 孤立した成績データ: なし
⚠ IDのない単語: 2件
```

## 関係するファイル

### 画面
- **IDMapAdminView.swift** - IDマップ管理画面

### ユーティリティ
- **IDFactory.swift** - ID生成とマッピング
- **IDMapper.swift** - ID整合性管理（存在する場合）

### データモデル
- **QuestionItem.swift** - 各問題にIDを保持
- **WordScoreStore.swift** - IDベースで成績を管理

### ストレージ
- **FileStudyProgressRepository.swift** - ID別の学習進捗

## ID管理の仕組み

### ID生成ルール
```swift
struct IDFactory {
    // 単語のterminとmeaningから一意のIDを生成
    static func generateID(term: String, meaning: String) -> UUID {
        let combined = "\(term):\(meaning)"
        // 安定したUUIDを生成（同じ入力なら同じUUID）
        return UUID(uuidString: combined.md5Hash) ?? UUID()
    }
    
    // または、CSV読み込み時に既存IDマップから取得
    static func getOrCreateID(term: String, meaning: String) -> UUID {
        if let existingID = idMap["\(term):\(meaning)"] {
            return existingID
        }
        let newID = UUID()
        idMap["\(term):\(meaning)"] = newID
        return newID
    }
}
```

### IDマップの永続化
```swift
class IDMapper {
    private var mapping: [String: UUID] = [:]  // "term:meaning" -> UUID
    
    func save() {
        let encoder = JSONEncoder()
        if let data = try? encoder.encode(mapping) {
            UserDefaults.standard.set(data, forKey: "IDMapping")
        }
    }
    
    func load() {
        guard let data = UserDefaults.standard.data(forKey: "IDMapping") else {
            return
        }
        let decoder = JSONDecoder()
        mapping = (try? decoder.decode([String: UUID].self, from: data)) ?? [:]
    }
}
```

## 編集時の注意点

### ID生成の一貫性
**重要**: 同じ単語には必ず同じIDを割り当てる

```swift
// ❌ 毎回新しいIDを生成（学習履歴が失われる）
let item = QuestionItem(
    id: UUID(),  // これはダメ
    term: "example",
    meaning: "例"
)

// ✅ IDマップから取得または生成
let item = QuestionItem(
    id: IDFactory.getOrCreateID(term: "example", meaning: "例"),
    term: "example",
    meaning: "例"
)
```

**チェックポイント**:
- [ ] CSV再読み込み後もIDが変わらない
- [ ] 同じ単語が複数CSVにあっても同じID
- [ ] 大文字小文字の違いを考慮する

### 整合性チェックの実装
```swift
func checkConsistency() -> ConsistencyReport {
    var report = ConsistencyReport()
    
    // 1. 重複IDチェック
    let allIDs = items.map { $0.id }
    let uniqueIDs = Set(allIDs)
    if allIDs.count != uniqueIDs.count {
        report.duplicateIDs = allIDs.count - uniqueIDs.count
    }
    
    // 2. 孤立した成績データチェック
    let scoreIDs = Set(wordScoreStore.allIDs())
    let currentIDs = Set(items.map { $0.id })
    report.orphanedScores = scoreIDs.subtracting(currentIDs).count
    
    // 3. IDのない単語チェック（nilの場合）
    report.missingIDs = items.filter { $0.id == UUID() }.count
    
    return report
}
```

### ID修復の実装
```swift
func repairIDs() {
    var fixed = 0
    
    for (index, item) in items.enumerated() {
        // 既存のIDマップから正しいIDを取得
        let correctID = IDFactory.getOrCreateID(
            term: item.term,
            meaning: item.meaning
        )
        
        if item.id != correctID {
            items[index].id = correctID
            fixed += 1
        }
    }
    
    // CSVに保存
    saveCSV()
    
    print("修復完了: \(fixed)件")
}
```

## テスト観点

### ID生成
- [ ] 同じ単語に同じIDが割り当てられる
- [ ] CSV再読み込み後もIDが保持される
- [ ] 大文字小文字の違いが適切に処理される

### 整合性チェック
- [ ] 重複IDが検出される
- [ ] 孤立した成績データが検出される
- [ ] IDのない単語が検出される

### ID修復
- [ ] 誤ったIDが正しいIDに修正される
- [ ] 学習履歴が正しく引き継がれる
- [ ] CSVに変更が保存される

### パフォーマンス
- [ ] 1000件の単語でも高速にチェックできる
- [ ] ID生成が高速（ハッシュ化）

## よくある編集パターン

### CSV移行時のID引き継ぎ
```swift
func migrateCSV(from oldCSV: String, to newCSV: String) {
    // 旧CSVのIDマップを読み込み
    let oldItems = loadCSV(oldCSV)
    let oldIDMap = oldItems.reduce(into: [:]) { map, item in
        map["\(item.term):\(item.meaning)"] = item.id
    }
    
    // 新CSVに旧IDを適用
    var newItems = loadCSV(newCSV)
    for (index, item) in newItems.enumerated() {
        let key = "\(item.term):\(item.meaning)"
        if let existingID = oldIDMap[key] {
            newItems[index].id = existingID  // 既存IDを使用
        }
    }
    
    saveCSV(newCSV, items: newItems)
}
```

### バッチID更新
```swift
func batchUpdateIDs(items: [QuestionItem]) -> [QuestionItem] {
    return items.map { item in
        var updated = item
        updated.id = IDFactory.getOrCreateID(
            term: item.term,
            meaning: item.meaning
        )
        return updated
    }
}
```

## トラブルシューティング

### 学習履歴が消えた
- IDが変わっていないか確認
- IDマップが正しく保存されているか確認
- WordScoreStore のキーを確認

### 重複IDが発生
- ID生成ロジックの一貫性を確認
- CSV読み込み時のID割り当てを確認
- 整合性チェックを実行して修復

### パフォーマンスが遅い
- IDマップをメモリにキャッシュ
- ハッシュ計算を最適化
- バッチ処理を検討

## 関連ドキュメント
- `.copilot/structure-map.md` - データフロー全体像
- `WordScoreStore.swift` - IDベースの成績管理
- `QuestionItem.swift` - IDの定義
