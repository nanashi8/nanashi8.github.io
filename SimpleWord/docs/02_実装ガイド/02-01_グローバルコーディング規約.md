# グローバルコーディング規約

**作成日**: 2025-11-08  
**最終更新**: 2025-11-08  
**対応内容**: プロジェクト全体に適用される基本的なコーディング規約

---

## 📋 目次

1. [基本方針](#基本方針)
2. [アーキテクチャ原則](#アーキテクチャ原則)
3. [実装ガイドライン](#実装ガイドライン)
4. [セキュリティとパフォーマンス](#セキュリティとパフォーマンス)

---

## 基本方針

### インデント

- **インデントはスペース4つを基本とする**
- タブ文字は使用しない
- エディタの設定で統一する

```swift
// ✅ 正しい例
func calculateScore() -> Double {
    guard total > 0 else {
        return 0.0
    }
    return Double(correct) / Double(total)
}

// ❌ 間違った例（スペース2つまたはタブ）
func calculateScore() -> Double {
  guard total > 0 else {
    return 0.0
  }
  return Double(correct) / Double(total)
}
```

### 命名

- **命名は説明的にし、必要な型情報を明示する**
- 略語は避ける（一般的なもの以外）
- Bool型には`is`/`has`/`can`などの接頭辞を使用

```swift
// ✅ 正しい例
let isCompleted: Bool
let hasError: Bool
let questionItems: [QuestionItem]

// ❌ 間違った例
let complete: Bool  // 型が不明確
let err: Bool       // 略語
let items: [Any]    // 型情報が不足
```

### コメント

- **ファイル冒頭やコードには日本語コメントで意図を補足する**
- 複雑なロジックには必ずコメントを追加
- コードの「何を」ではなく「なぜ」を説明する

```swift
// ✅ 正しい例
// CSV固定列3から選択肢を生成（ヘッダに依存しない安全な実装）
let correctAnswer = correctItem.rawColumns.count > 2 
    ? correctItem.rawColumns[2] 
    : correctItem.meaning

// ❌ 間違った例（コードの直訳）
// rawColumnsのcountが2より大きい場合、rawColumns[2]を使用
let correctAnswer = correctItem.rawColumns.count > 2 
    ? correctItem.rawColumns[2] 
    : correctItem.meaning
```

---

## アーキテクチャ原則

### オブジェクト指向と責務分離

- **オブジェクト指向を基本とし、責務分離を徹底する**
- 各クラスは単一の責務を持つ（Single Responsibility Principle）
- 関数は1つのことだけを行う

```swift
// ✅ 正しい例：責務が明確
class CSVLoader {
    func load(from url: URL) throws -> [QuestionItem] {
        // CSV読み込みのみ
    }
}

class QuizSessionStore {
    func startSession(with items: [QuestionItem]) {
        // セッション管理のみ
    }
}

// ❌ 間違った例：責務が混在
class QuizManager {
    func loadAndStartSession(from url: URL) {
        // CSV読み込み + セッション管理 + 統計計算...
    }
}
```

### 単一実装・単一管理・単一路線

- **過度なラッパーや多段継承は避け、単一の実装・単一路線・単一管理点に集約する**
- 不要な抽象化を避ける
- 実装は1箇所にまとめる

```swift
// ✅ 正しい例：直接使用
let items = try await CSVDataSource().load(from: url)

// ❌ 間違った例：不要なラッパー
class DataManager {
    private let loader = DataLoader()
    
    func loadData() {
        let items = loader.load()  // 単なるラッパー
    }
}

class DataLoader {
    private let source = CSVDataSource()
    
    func load() {
        let items = source.load()  // さらにラッパー
    }
}
```

### オーバーエンジニアリングの回避

- **オーバーエンジニアリングを避け、容易性・可読性・保守性・拡張性を優先する**
- YAGNI原則（You Aren't Gonna Need It）を守る
- シンプルな解決策を優先

```swift
// ✅ 正しい例：シンプルで明確
func filterQuestions(by difficulty: Int) -> [QuestionItem] {
    return questions.filter { $0.difficulty == difficulty }
}

// ❌ 間違った例：過度に複雑
protocol QuestionFilter {
    func filter(_ items: [QuestionItem]) -> [QuestionItem]
}

class DifficultyFilter: QuestionFilter {
    let targetDifficulty: Int
    
    init(difficulty: Int) {
        self.targetDifficulty = difficulty
    }
    
    func filter(_ items: [QuestionItem]) -> [QuestionItem] {
        return items.filter { $0.difficulty == self.targetDifficulty }
    }
}

class QuestionFilterManager {
    func applyFilter(_ filter: QuestionFilter, to items: [QuestionItem]) -> [QuestionItem] {
        return filter.filter(items)
    }
}
```

---

## 実装ガイドライン

### 既存資産の優先利用

- **既存の設計・コード・仕組み・パッケージを優先的に利用し、目的の達成に支障がない限り、書き換えや再発明を避ける**
- 車輪の再発明をしない
- 標準ライブラリを活用する
- 既存のパターンと一貫性を保つ

```swift
// ✅ 正しい例：標準ライブラリを活用
let uniqueItems = Array(Set(items))

// ✅ 正しい例：既存のパターンを踏襲
// プロジェクトで既に使用されているパターンを使用
class NewFeatureStore: ObservableObject {
    @Published var items: [Item] = []
    // 既存のStoreパターンに従う
}

// ❌ 間違った例：独自実装
func removeDuplicates(_ items: [QuestionItem]) -> [QuestionItem] {
    var result: [QuestionItem] = []
    for item in items {
        var isDuplicate = false
        for existing in result {
            if item.id == existing.id {
                isDuplicate = true
                break
            }
        }
        if !isDuplicate {
            result.append(item)
        }
    }
    return result
}
```

### 副作用の最小化

- **副作用は必要最小限に留める。テスタビリティを考慮する**
- 純粋関数を優先
- 状態変更は明示的に行う

```swift
// ✅ 正しい例：純粋関数
func calculateScore(correct: Int, total: Int) -> Double {
    guard total > 0 else { return 0.0 }
    return Double(correct) / Double(total) * 100
}

// ❌ 間違った例：副作用がある
var globalScore: Double = 0.0

func calculateScore(correct: Int, total: Int) {
    globalScore = Double(correct) / Double(total) * 100  // グローバル変数を変更
}
```

### テスタビリティ

- **テスタビリティを考慮する**
- 依存性を注入可能にする
- モック可能な設計

```swift
// ✅ 正しい例：テスト可能
protocol QuestionDataSource {
    func load() -> [QuestionItem]
}

class QuizSession {
    private let dataSource: QuestionDataSource
    
    init(dataSource: QuestionDataSource) {
        self.dataSource = dataSource
    }
    
    func start() {
        let questions = dataSource.load()
        // ...
    }
}

// テストでモックを注入可能
class MockDataSource: QuestionDataSource {
    func load() -> [QuestionItem] {
        return [/* テストデータ */]
    }
}

// ❌ 間違った例：テスト困難
class QuizSession {
    func start() {
        let dataSource = CSVDataSource()  // 固定依存
        let questions = dataSource.load()
        // ...
    }
}
```

---

## セキュリティとパフォーマンス

### 必須要件への準拠

本プロジェクトでは、以下の14の必須要件を厳守します：

1. ✅ **Swift 6.0の使用と並行性** - actor、async/await、@MainActorの活用
2. ✅ **雑な例外処理を禁止** - try?/try!の禁止、適切なエラーハンドリング
3. ✅ **可変引数を使用しない** - 型安全性の確保
4. ✅ **任意のコード実行・SQL文実行の禁止** - セキュリティの確保
5. ✅ **ログに内部情報・個人情報を出力しない** - プライバシーの保護
6. ✅ **時刻はタイムゾーンを設定する** - 環境依存を排除
7. ✅ **浮動小数点の丸め方を統一する** - 計算の一貫性
8. ✅ **ライブラリの警告を無視しない** - すべての警告に対応
9. ✅ **同期・非同期が機能停止を引き起こさない** - デッドロックの防止
10. ✅ **リソースを解放する** - メモリリークの防止
11. ✅ **ハードコードしない** - 設定ファイルで管理
12. ✅ **遅いコードを書かない** - 効率的なアルゴリズム
13. ✅ **一般乱数を使用しない** - セキュリティ用途での適切な乱数
14. ✅ **ログ出力でパフォーマンスを落とさない** - OSLogの活用

**詳細は必ず以下のドキュメントを参照してください：**

⭐ **[02-03_セキュリティとパフォーマンス設計方針.md](02-03_セキュリティとパフォーマンス設計方針.md)**

---

## まとめ

### 基本方針の要約

1. ✅ **インデントはスペース4つ**
2. ✅ **説明的な命名、必要な型情報を明示**
3. ✅ **日本語コメントで意図を補足**

### アーキテクチャ原則の要約

1. ✅ **単一責任の原則（SRP）**
2. ✅ **単一実装・単一管理・単一路線**
3. ✅ **オーバーエンジニアリング回避**

### 実装ガイドラインの要約

1. ✅ **既存資産の優先利用**
2. ✅ **副作用の最小化**
3. ✅ **テスタビリティの考慮**

### セキュリティとパフォーマンス

1. ✅ **14の必須要件を厳守**
2. ✅ **詳細は02-03を必読**

---

## 関連ドキュメント

- **[02-02_コーディング規約.md](02-02_コーディング規約.md)** - 詳細なコーディングルール
- **[02-03_セキュリティとパフォーマンス設計方針.md](02-03_セキュリティとパフォーマンス設計方針.md)** ⭐ **必読**
- **[01-02_アーキテクチャ仕様.md](../01_仕様書/01-02_アーキテクチャ仕様.md)** - システム設計

---

**これらの原則を守ることで、保守性が高く、理解しやすく、セキュアで高パフォーマンスなコードベースを実現します。**
